 useEffect
//this useEffect is set the date to the form
  // useEffect(() => {
  //   const searchParams = new URLSearchParams(location.search);
  //   const dateFromQuery = searchParams.get('date');
   
  //   // Use the date from addTask if dateFromQuery is null
  //   const selectedDate = dateFromQuery || addTask.date || dayjs().format('YYYY-MM-DD');
  //   //console.log("dateFromQuery", selectedDate);
  //   // Update selectedDate state
  //   setSelectedDate(selectedDate);

  //   // Autofill the date in the form
  //   setAddTask((prevTask) => ({ ...prevTask, date: selectedDate }));
  
  //   // Update the filteredTaskList based on the selected date
  //   const tasksForSelectedDate = taskList.filter((task) => task.date === selectedDate);
  //   console.log("tasksForSelectedDate",tasksForSelectedDate)
  //   // Update the slNo in filteredTaskList
  //   setFilteredTaskList(tasksForSelectedDate.map((task, index) => ({ ...task, slNo: index + 1 })));
  //   console.log("useeffect filter", filteredTaskList);
  // }, [location.search, taskList, addTask.date]);
hanldeEditTask 2
 // const handleEditTask = (date: string, startTime: string, endTime: string) => {
  //   // if (selectedFilter === 'Month' || selectedFilter === 'Week') {
  //   //   notification.warning({
  //   //     message: 'Restricted',
  //   //     description: 'Cannot edit tasks during the selected period.',
  //   //   });
  //   //   return;
  //   // }
  
  //   setIsEdited(true);
  //   //setIsSelected(false);
  //   const selectedTask = taskList.find((task)=>task.date===date && task.startTime===startTime && task.endTime);
  //   const startOfRange = () => {
  //     if (selectedFilter === 'week') {
  //       return dayjs(addTask.date).startOf('week');
  //     } else if (selectedFilter === 'month') {
  //       return dayjs(addTask.date).startOf('month');
  //     }
     
  //   };
  //   const endOfRange = () => {
  //     if (selectedFilter === 'week') {
  //       return dayjs(addTask.date).endOf('week');
  //     } else if (selectedFilter === 'month') {
  //       return dayjs(addTask.date).endOf('month');
  //     }
  //   };
  //   //console.log(index);
  //   if (selectedTask) {
  //     setAddTask(selectedTask);
  
      
  //   // Update the filteredTaskList based on the selected view (week or month)
  //   const tasksForSelectedRange = taskList.filter((task) => {
  //     const taskDate = dayjs(task.date);
  //     return (
  //       taskDate.isAfter(startOfRange()) &&
  //       taskDate.isBefore(endOfRange())
  //     );
  //   });
  //   setFilteredTaskList(
  //     tasksForSelectedRange.map((task, i) => ({ ...task, slNo: i + 1 }))
  //   );
  // }
  // };

handleEditTask 3
//   const handleEditTask = (date: string, startTime: string, endTime: string) => {
//   setIsEdited(true);

//   // Find the selected task for editing
//   const selectedTask = taskList.find(
//     (task) => task.date === date && task.startTime === startTime && task.endTime === endTime
//   );

//   if (selectedTask) {
//     setAddTask(selectedTask);

//     // Update the filteredTaskList based on the selected view (week or month)
//     const startOfRange = () => {
//       if (selectedFilter === 'Week') {
//         return dayjs(currentWeekStart).startOf('week');
//       } else if (selectedFilter === 'Month') {
//         return dayjs(currentMonthStart).startOf('month');
//       }
//       return dayjs(currentDateStart); // Default to the date itself if no filter matches
//     };

//     const endOfRange = () => {
//       if (selectedFilter === 'Week') {
//         return dayjs(currentWeekStart).endOf('week');
//       } else if (selectedFilter === 'Month') {
//         return dayjs(currentMonthStart).endOf('month');
//       }
//       return dayjs(currentDateStart); // Default to the date itself if no filter matches
//     };

//     const tasksForSelectedRange = taskList.filter((task) => {
//       const taskDate = dayjs(task.date);
//       return taskDate.isAfter(startOfRange()) && taskDate.isBefore(endOfRange());
//     });

//     setFilteredTaskList(
//       tasksForSelectedRange.map((task, i) => ({ ...task, slNo: i + 1, idx: i + 1 }))
//     );
//   }
// };

 
 
handleEditTask
// Update the filteredTaskList based on the selected task's date
    //   const tasksForSelectedDate = taskList.filter((task) => task.date === selectedTask.date);
    //   setFilteredTaskList(tasksForSelectedDate.map((task, i) => ({ ...task, slNo: i + 1 })));
    //   console.log("filtered", filteredTaskList);
    // }

handleDeletTask
// setTaskList((prevTaskList) => {
    //   const updatedList = prevTaskList.filter(
    //     (task) => !(task.date === date && task.startTime === startTime && task.endTime === endTime)
    //   );
  
    //   localStorage.setItem('taskList', JSON.stringify(updatedList));
  
    //   // Update filteredTaskList based on the selected view
    //   const tasksForSelectedRange = updatedList.filter((task) => {
    //     const taskDate = dayjs(task.date);
    //     return taskDate.isAfter(startOfRange()) && taskDate.isBefore(endOfRange());
    //   });
  
    //   setFilteredTaskList(tasksForSelectedRange.map((task, i) => ({ ...task, slNo: i + 1 })));
  
    //   return updatedList.map((task, i) => ({ ...task, slNo: i + 1 }));
    // });


AddTask.tsx (fullcode)

// import React, { useState, useEffect } from 'react';
// import { Input, TimePicker, notification, DatePicker} from 'antd';
// import { SearchOutlined } from '@mui/icons-material';
// import dayjs from 'dayjs';
// import { Link, useNavigate, useLocation } from 'react-router-dom';
// import { useMsal } from '@azure/msal-react';
// import '../Styles/CreateUser.css';
// import DashboardLayout from './Layout';
// import '../Styles/AddTask.css';
// import {Table} from 'antd';
// import { ColumnsType } from "antd/es/table";
// import { EditOutlined, DeleteOutlined } from '@ant-design/icons';
// import { LeftOutlined, RightOutlined } from '@ant-design/icons';
// import Dashboard from './Dashboard';
// export interface Task {
//   date: string;
//   userId: string;
//   task: string;
//   startTime: string;
//   endTime: string;
//   description: string;
//   reportingTo: string;
//   slNo?: number;
//   idx?:number;
// }
// interface AddTaskProps {
//   setPieChartData: (data: { [key: string]: number }) => void;
// }
// const AddTask: React.FC<AddTaskProps> = ({ setPieChartData }) => {
//   const navigate = useNavigate();
//   const location = useLocation();
//   const [formWidth, setFormWidth] = useState(800);
//   const [addTask, setAddTask] = useState<Task>({
//     date: '',
//     userId: '',
//     task: '',
//     startTime: '',
//     endTime: '',
//     description: '',
//     reportingTo: '',
//   });
//   const [isFormEnabled, setIsFormEnabled] = useState(false);
//   let selectedRow = 0;
//   const [taskList, setTaskList] = useState<Task[]>([]);
//   const reportingOptions = ['ManagerA', 'ManagerB', 'ManagerC'];
//   const taskOptions = ['Task','Project','Learning','Training','Meeting'];
  // const [currentWeekStart, setCurrentWeekStart] = useState<string>(dayjs().startOf('week').format('YYYY-MM-DD'));
  // const [currentMonthStart, setCurrentMonthStart] = useState<string>(dayjs().startOf('month').format('YYYY-MM-DD'));
  // const [currentDateStart, setCurrentDateStart] = useState<string>(dayjs().startOf('date').format('YYYY-MM-DD'));
//   const [filteredTaskList, setFilteredTaskList] = useState<Task[]>([]);
//   const [selectedDate, setSelectedDate] = useState<string>(dayjs().format('YYYY-MM-DD'));
//   const [formSelectDate, setFormSelectDate]= useState('')
//   const [selectedFilter, setSelectedFilter] = useState('Date');
//   const [ isEdited, setIsEdited]= useState(false);
//   const [isSelected, setIsSelected]= useState(false);
//   const [isDropdownVisible, setDropdownVisible] = useState(false);
//   const handleMouseEnter = () => {
//     setDropdownVisible(true);
//   };

//   const handleMouseLeave = () => {
//     setDropdownVisible(false);
//   };

//   const handlePrev = () => {
    
//     if (selectedFilter === 'Month') {
//       setIsSelected(true);
//       handlePrevMonth();
//     } else if (selectedFilter === 'Week') {
//       setIsSelected(true);
//       handlePrevWeek();
//     }else{
//       setIsSelected(false);
//       handlePrevDate();
//     }
//   };

//   const handleNext = () => {
    
//     if (selectedFilter === 'Month') {
//       setIsSelected(true);
//       handleNextMonth();

//     } else if (selectedFilter === 'Week') {
//       setIsSelected(true);
//       handleNextWeek();
//     } else{
//       setIsSelected(false);
//       handleNextDate();
//     }
//   };

//   const handleFilterChange = (selectedValue:any) => {
//     setSelectedFilter(selectedValue);
    
//     // Handle filter change based on the selected value
//     if (selectedValue === 'Month') {
      
//       setIsSelected(true);
//       handleFilterByMonth();
//     } else if (selectedValue === 'Week') {
      
//       setIsSelected(true);
//       handleFilterByWeek();
//     } else{
//       setIsSelected(false);
//       handleFilterByDate();
//     }
     
      
//   };

//   useEffect(() => {
//     const updateFormWidth = () => {
//       const formElement = document.getElementById('myForm');
//       if (formElement) {
//         const newWidth = formElement.offsetWidth;
//         setFormWidth(newWidth);
//       }
//     };

//     window.addEventListener('resize', updateFormWidth);
//     updateFormWidth();

//     return () => {
//       window.removeEventListener('resize', updateFormWidth);
//     };
//   }, []);

//   const borderStyle = {
//     border: '1px solid black',
//     margin: '10px 20px',
//     paddingRight: '0',
//     width: formWidth + 'px', // Set the width dynamically
//   };

//   useEffect(() => {
//     // Load data from localStorage when the component mounts
//     const storedTaskList = JSON.parse(localStorage.getItem('taskList') || '[]');
//     setTaskList(storedTaskList);
//   }, []); // Empty dependency array ensures this effect runs once on mount


//    useEffect(() => {
//     // const searchParams = new URLSearchParams(location.search);
//     // console.log("searchParams",searchParams);
//     // const dateFromQuery = searchParams.get('date');
//     // console.log("dateFromQuery", addTask)
//     // const selectedDate =  addTask.date || dayjs().format('YYYY-MM-DD');
//     // console.log("selectedDate", selectedDate);
//     // setSelectedDate(selectedDate);
//     // setAddTask((prevTask) => ({ ...prevTask, date: selectedDate }));
  
//     if (selectedFilter === 'Week') {
//       // Fetch tasks for the selected week
//       const startOfWeek = dayjs(selectedDate).startOf('week');
//       const endOfWeek = dayjs(selectedDate).endOf('week');
//       const tasksForSelectedRange = taskList.filter((task) =>
//         ((dayjs(task.date).isSame(startOfWeek) || dayjs(task.date).isAfter(startOfWeek)) && (dayjs(task.date).isSame(endOfWeek) || dayjs(task.date).isBefore(endOfWeek)))
//       );
//       console.log("tasksForSelectedRange",tasksForSelectedRange)
//       setFilteredTaskList(tasksForSelectedRange.map((task, index) => ({ ...task, slNo: index + 1 })));
//     } else if (selectedFilter === 'Month') {
//       // Fetch tasks for the selected month
//       const startOfMonth = dayjs(selectedDate).startOf('month');
//       const endOfMonth = dayjs(selectedDate).endOf('month');
//       const tasksForSelectedRange = taskList.filter((task) =>
//       ((dayjs(task.date).isSame(startOfMonth) || dayjs(task.date).isAfter(startOfMonth)) && (dayjs(task.date).isSame(endOfMonth) || dayjs(task.date).isBefore(endOfMonth)))
//       );
  
//       setFilteredTaskList(tasksForSelectedRange.map((task, index) => ({ ...task, slNo: index + 1 })));
//     } else {
//       // Fetch tasks for the selected date
//       console.log("taskListttt",selectedDate)
//       const tasksForSelectedDate = taskList.filter((task) => task.date === currentDateStart);
//       setFilteredTaskList(tasksForSelectedDate ? tasksForSelectedDate.map((task, index) => ({ ...task, slNo: index + 1 })) : []);
//     }
//   }, [ taskList, selectedFilter]);

//   const handleDateChange = (selectedDate:any) => {
//     // Update the state variable when the date changes
//     setFormSelectDate(selectedDate);
//     // Use the selected date to update the display below
//     setCurrentDateStart(dayjs(selectedDate).format('YYYY-MM-DD'));
//     // Assuming you have a function to filter tasks based on the selected date
//   const tasksForSelectedDate = taskList.filter((task) => task.date === currentDateStart);

//   // Update the task list and filtered task list
//   setFilteredTaskList(tasksForSelectedDate.map((task, i) => ({ ...task, slNo: i + 1, idx: i + 1 })));
//   setAddTask({
//     date: selectedDate,
//     userId: '',
//     task: '',
//     startTime: '',
//     endTime: '',
//     description: '',
//     reportingTo: '',
//   });
//   };
 
//   const handleInputChange = (field: keyof Task, value: string) => {
//     setAddTask((prevTask) => ({ ...prevTask, [field]: value }));
//   };
  
//   const handleFormSubmit = () => {
//   //   if (isSelected) {
//   //   // Display a notification and return early
//   //   notification.warning({
//   //     message: 'Restricted',
//   //     description: 'Please select the date in the calendar to add a task.',
//   //   });
//   //   return;
//   // }
//    // Check for overlapping tasks in the specified time range
//   const overlappingTask = taskList.find((task) => {
//   const newTaskStartTime = dayjs(addTask.startTime, 'hh:mm A');
//   const newTaskEndTime = dayjs(addTask.endTime, 'hh:mm A');
//   const taskStartTime = dayjs(task.startTime, 'hh:mm A');
//   const taskEndTime = dayjs(task.endTime, 'hh:mm A');

//   // Check if the new task overlaps with any existing task
//   return (
//     !isEdited && task.date === addTask.date &&
//     // ((newTaskStartTime.isSame(taskStartTime) && newTaskStartTime.isBefore(taskEndTime)) && newTaskEndTime.isSame(taskEndTime))
//     (
//       ((newTaskStartTime.isSame(taskStartTime) || newTaskStartTime.isAfter(taskStartTime))&& newTaskStartTime.isBefore(taskEndTime)) ||
//       ((newTaskEndTime.isSame(taskStartTime) || newTaskEndTime.isAfter(taskStartTime))&& newTaskEndTime.isBefore(taskEndTime)) ||
//       (newTaskStartTime.isBefore(taskStartTime) && (newTaskEndTime.isSame(taskEndTime)|| newTaskEndTime.isAfter(taskEndTime)))
//     )
//   );
// });
  
//     if (overlappingTask) {
//       notification.warning({
//         message: 'Restricted',
//         description: 'Task already exists in the specified time range.',
//       });
//       return;
//     }
//     const startOfRange = () => {
//       if (selectedFilter === 'week') {
//         return dayjs(addTask.date).startOf('week');
//       } else if (selectedFilter === 'month') {
//         return dayjs(addTask.date).startOf('month');
//       }
     
//     };
//     const endOfRange = () => {
//       if (selectedFilter === 'week') {
//         return dayjs(addTask.date).endOf('week');
//       } else if (selectedFilter === 'month') {
//         return dayjs(addTask.date).endOf('month');
//       }
//     };

//     if (addTask.slNo !== undefined) {
//       // Editing an existing task
//       const editedTaskIndex = taskList.findIndex((task) => task.slNo === addTask.slNo);
//       if (editedTaskIndex !== -1) {
//         const updatedTaskList = [...taskList];
//         updatedTaskList[editedTaskIndex] = { ...addTask };
//         console.log("addTask-one",updatedTaskList)
//         setTaskList(updatedTaskList);
//         //setFilteredTaskList(updatedTaskList); // Update filteredTaskList directly
//         // Update filteredTaskList based on the selected view
//         const tasksForSelectedRange = updatedTaskList.filter((task) => {
//           const taskDate = dayjs(task.date);
//           return (
//             taskDate.isAfter(startOfRange()) &&
//             taskDate.isBefore(endOfRange())
//           );
//         });
//         setFilteredTaskList(tasksForSelectedRange.map((task, i) => ({ ...task, slNo: i + 1, idx: i + 1 })));
//         }
//         console.log("addTask-two",addTask)
//         setIsEdited(false);
//         setAddTask({
//           date: addTask.date,
//           userId: '',
//           task: '',
//           startTime: '',
//           endTime: '',
//           description: '',
//           reportingTo: '',
//         });
//         // Trigger handleFilterChange with the selected filter value
//       handleFilterChange(selectedFilter);
//     } 
//   else {
//     // Adding a new task
//     const nextSlNo = taskList.length + 1;
//     const nextIdx = taskList.length + 1;
//     const newTask = { ...addTask, slNo: nextSlNo, date: addTask.date, idx: nextIdx }; // Include idx in the new task
  
//     const updatedTaskList = [...taskList, newTask];
//     setTaskList(updatedTaskList);
//     setFilteredTaskList((prevFilteredTaskList) => [...prevFilteredTaskList, newTask]);
  
//     // Increment idx for the next task
//     setAddTask({
//       date:addTask.date,
//       userId: '',
//       task: '',
//       startTime: '',
//       endTime: '',
//       description: '',
//       reportingTo: '',
//     });
//     // Trigger handleFilterChange with the selected filter value
//     handleFilterChange(selectedFilter);
//     // Update filteredTaskList based on the selected view
//     const tasksForSelectedRange = updatedTaskList.filter((task) => {
//       const taskDate = dayjs(task.date);
//       return taskDate.isAfter(startOfRange()) && taskDate.isBefore(endOfRange());
//     });
//     setFilteredTaskList(tasksForSelectedRange.map((task, i) => ({ ...task, slNo: i + 1, idx: i + 1 })));
//   }
  
//     // Use the callback function of setTaskList to ensure the state is updated before updating localStorage
//   setTaskList((updatedTaskList) => {
//     localStorage.setItem('taskList', JSON.stringify(updatedTaskList));

//     // Update filteredTaskList based on the selected date
//     // const tasksForSelectedDate = updatedTaskList.filter((task) => task.date === addTask.date);
//     // setFilteredTaskList(tasksForSelectedDate.map((task, i) => ({ ...task, slNo: i + 1, idx: i + 1 })));
//     const tasksForSelectedRange = taskList.filter((task) => {
//       const taskDate = dayjs(task.date);
//       return taskDate.isAfter(startOfRange()) && taskDate.isBefore(endOfRange());
//     });
//     setFilteredTaskList(tasksForSelectedRange.map((task, i) => ({ ...task, slNo: i + 1, idx: i + 1 })));
//     // Update selectedDate to the date of the added task
//     setSelectedDate(addTask.date);
//     return updatedTaskList;
//   });
//   };
  
//   const handleFilterByDate = () => {
//     console.log("incoming")
//     //setisSelected(false);
//     // Calculate the start and end of the current date dynamically
//     const startOfDate = dayjs().startOf('day').format('YYYY-MM-DD');
//     console.log("startOfDate",startOfDate)
//     const endOfDate = dayjs().endOf('day').format('YYYY-MM-DD');
//     console.log("startOfDate",endOfDate)
  
//     setCurrentDateStart(startOfDate); // Update currentDateStart here
  
//     const tasksForSelectedDate = taskList.filter(
//       (task) => task.date >= startOfDate && task.date <= endOfDate
//     );
//     console.log("startOfDate",tasksForSelectedDate)
  
//     setFilteredTaskList(tasksForSelectedDate ? tasksForSelectedDate.map((task, index) => ({ ...task, slNo: index + 1 })) : []);
//   };

//   console.log("setCurrentDateStart",filteredTaskList)
  
//  const handlePrevDate = () => {
//   //setIsSelected(true);
//     // Calculate the start and end of the previous week dynamically
//     const startOfPrevDate = dayjs(currentDateStart).subtract(1, 'day').startOf('day').format('YYYY-MM-DD');
//     const endOfPrevDate = dayjs(currentDateStart).subtract(1, 'day').endOf('day').format('YYYY-MM-DD');

//     setCurrentDateStart(startOfPrevDate);

//     const tasksForPrevDate = taskList.filter(
//       (task) => task.date >= startOfPrevDate && task.date <= endOfPrevDate
//     );

//     setFilteredTaskList(tasksForPrevDate.map((task, index) => ({ ...task, slNo: index + 1 })));
//   };

//   const handleNextDate = () => {
//     console.log("--AAcurrentDateStart",currentDateStart)
//     //setIsSelected(true);
//     const startOfNextDate = dayjs(currentDateStart).add(1, 'day').startOf('day').format('YYYY-MM-DD');
//     const endOfNextDate = dayjs(currentDateStart).add(1, 'day').endOf('day').format('YYYY-MM-DD');
// console.log("startOfNextDate",startOfNextDate)
// console.log("--AAendOfNextDate",endOfNextDate)
//     // Check if the start of the next week is after today's date
//     if (dayjs().isBefore(startOfNextDate)) {
//       // Display a notification or handle the restriction as needed
//       notification.warning({
//         message: 'Restricted',
//         description: 'Cannot navigate to future weeks.',
//       });
//       return;
//     }
  
//     setCurrentDateStart(startOfNextDate);
//     const tasksForNextDate = taskList.filter((task) => task.date >= startOfNextDate && task.date <= endOfNextDate);
//     setFilteredTaskList(tasksForNextDate.map((task, index) => ({ ...task, slNo: index + 1 })));
//   };
  
//   const handleFilterByWeek = () => {
//     setIsSelected(true);
//     // Calculate the start and end of the current week dynamically
//     const startOfWeek = dayjs().startOf('week').format('YYYY-MM-DD');
//     const endOfWeek = dayjs().endOf('week').format('YYYY-MM-DD');

//     const tasksForSelectedWeek = taskList.filter(
//       (task) => task.date >= startOfWeek && task.date <= endOfWeek
//     );

//     setFilteredTaskList(tasksForSelectedWeek.map((task, index) => ({ ...task, slNo: index + 1 })));
//     console.log("week filter", filteredTaskList);
//   };

//  const handlePrevWeek = () => {
//   setIsSelected(true);
//     // Calculate the start and end of the previous week dynamically
//     const startOfPrevWeek = dayjs(currentWeekStart).subtract(1, 'week').startOf('week').format('YYYY-MM-DD');
//     const endOfPrevWeek = dayjs(currentWeekStart).subtract(1, 'week').endOf('week').format('YYYY-MM-DD');

//     setCurrentWeekStart(startOfPrevWeek);

//     const tasksForPrevWeek = taskList.filter(
//       (task) => task.date >= startOfPrevWeek && task.date <= endOfPrevWeek
//     );

//     setFilteredTaskList(tasksForPrevWeek.map((task, index) => ({ ...task, slNo: index + 1 })));
//   };

//   const handleNextWeek = () => {
//     setIsSelected(true);
//     const startOfNextWeek = dayjs(currentWeekStart).add(1, 'week').startOf('week').format('YYYY-MM-DD');
//     const endOfNextWeek = dayjs(currentWeekStart).add(1, 'week').endOf('week').format('YYYY-MM-DD');
  
//     // Check if the start of the next week is after today's date
//     if (dayjs().isBefore(startOfNextWeek)) {
//       // Display a notification or handle the restriction as needed
//       notification.warning({
//         message: 'Restricted',
//         description: 'Cannot navigate to future weeks.',
//       });
//       return;
//     }
  
//     setCurrentWeekStart(startOfNextWeek);
//     const tasksForNextWeek = taskList.filter((task) => task.date >= startOfNextWeek && task.date <= endOfNextWeek);
//     setFilteredTaskList(tasksForNextWeek.map((task, index) => ({ ...task, slNo: index + 1 })));
//   };
  
//   const handleFilterByMonth = () => {
//     setIsSelected(true);
//     // Calculate the start and end of the current week dynamically
//     const startOfMonth = dayjs().startOf('month').format('YYYY-MM-DD');
//     const endOfMonth = dayjs().endOf('month').format('YYYY-MM-DD');

//     const tasksForSelectedWeek = taskList.filter(
//       (task) => task.date >= startOfMonth && task.date <= endOfMonth
//     );

//     setFilteredTaskList(tasksForSelectedWeek.map((task, index) => ({ ...task, slNo: index + 1 })));
//   };

//  const handlePrevMonth = () => {
//   setIsSelected(true);
//     // Calculate the start and end of the previous week dynamically
//     const startOfPrevMonth = dayjs(currentMonthStart).subtract(1, 'month').startOf('month').format('YYYY-MM-DD');
//     const endOfPrevMonth = dayjs(currentMonthStart).subtract(1, 'month').endOf('month').format('YYYY-MM-DD');

//     setCurrentMonthStart(startOfPrevMonth);

//     const tasksForPrevMonth = taskList.filter(
//       (task) => task.date >= startOfPrevMonth && task.date <= endOfPrevMonth
//     );

//     setFilteredTaskList(tasksForPrevMonth.map((task, index) => ({ ...task, slNo: index + 1 })));
//   };

//   const handleNextMonth = () => {
//     setIsSelected(true);
//     const startOfNextMonth = dayjs(currentMonthStart).add(1, 'month').startOf('month').format('YYYY-MM-DD');
//     const endOfNextMonth = dayjs(currentMonthStart).add(1, 'month').endOf('month').format('YYYY-MM-DD');
  
//     // Check if the start of the next week is after today's date
//     if (dayjs().isBefore(startOfNextMonth)) {
//       // Display a notification or handle the restriction as needed
//       notification.warning({
//         message: 'Restricted',
//         description: 'Cannot navigate to future Months.',
//       });
//       return;
//     }
  
//     setCurrentMonthStart(startOfNextMonth);
//     const tasksForNextMonth = taskList.filter((task) => task.date >= startOfNextMonth && task.date <= endOfNextMonth);
//     setFilteredTaskList(tasksForNextMonth.map((task, index) => ({ ...task, slNo: index + 1 })));
//   };

  // const columns: ColumnsType<Task> = [
  //   {
  //     title: 'Sl.no',
  //     sorter: (a: Task, b: Task) => (a.slNo && b.slNo ? a.slNo - b.slNo : 0),
  //     dataIndex: 'slNo',
  //     key: 'slNo',
  //     fixed: 'left',
  //   },
  //   {
  //     title: 'User Id',
  //     sorter: (a: Task, b: Task) => a.userId.localeCompare(b.userId),
  //     dataIndex: 'userId',
  //     key: 'userId',
  //     fixed: 'left',
  //   },
  //   {
  //     title: 'Date',
  //     sorter: (a: Task, b: Task) => a.date.localeCompare(b.date),
  //     dataIndex: 'date',
  //     key: 'date',
  //     fixed: 'left',
  //   },
  //   {
  //     title: 'Start Time',
  //     sorter: (a: Task, b: Task) => a.startTime.localeCompare(b.startTime),
  //     dataIndex: 'startTime',
  //     key: 'startTime',
  //     fixed: 'left',
  //   },
  //   {
  //     title: 'End Time',
  //     sorter: (a: Task, b: Task) => a.endTime.localeCompare(b.endTime),
  //     dataIndex: 'endTime',
  //     key: 'endTime',
  //     fixed: 'left',
  //   },
  //   {
  //     title: 'Task',
  //     sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
  //     dataIndex: 'task',
  //     key: 'task',
  //     fixed: 'left',
  //   },
  //   {
  //     title: 'Description',
  //     sorter: (a: Task, b: Task) => a.description.localeCompare(b.description),
  //     dataIndex: 'description',
  //     key: 'description',
  //     fixed: 'left',
  //   },
  //   {
  //     title: 'Reporting To',
  //     sorter: (a: Task, b: Task) => a.reportingTo.localeCompare(b.reportingTo),
  //     dataIndex: 'reportingTo',
  //     key: 'reportingTo',
  //     fixed: 'left',
  //   },
    
  //   {
  //     title: 'Actions',
  //     dataIndex: 'actions',
  //     key: 'actions',
  //     render: (_, record, index) => (
  //       <div>
  //         <EditOutlined
  //           onClick={() => handleEditTask(record.date, record.startTime, record.endTime)}
  //           style={{
  //             marginRight: '8px',
  //             cursor: 'pointer',
  //             color: 'blue',
  //             fontSize: '20px',
  //           }}
  //           // style={{
  //           //   marginRight: '8px',
  //           //   cursor: selectedFilter === 'Month' || selectedFilter === 'Week' ? 'not-allowed' : 'pointer',
  //           //   color: selectedFilter === 'Month' || selectedFilter === 'Week' ? 'grey' : 'blue',
  //           //   fontSize: '20px',
  //           // }}
  //           // disabled={selectedFilter === 'Month' || selectedFilter === 'Week'}
  //         />
  //         <DeleteOutlined
  //            onClick={() => handleDeleteTask(record.date, record.startTime, record.endTime)}
  //            style={{
  //             cursor: 'pointer',
  //             color:  'red',
  //             fontSize: '20px',
  //           }}
  //           // style={{
  //           //   cursor: selectedFilter === 'Month' || selectedFilter === 'Week' ? 'not-allowed' : 'pointer',
  //           //   color: selectedFilter === 'Month' || selectedFilter === 'Week' ? 'grey' : 'red',
  //           //   fontSize: '20px',
  //           // }}
  //           // disabled={selectedFilter === 'Month' || selectedFilter === 'Week'}
  //         />
//         </div>
//       ),
//     },
//   ];

  // const handleToggleForm = () => {
  //   setIsFormEnabled((prevIsFormEnabled) => !prevIsFormEnabled);
  
  //   // If you want to reset the form when disabling it, you can reset the form state here
  //   if (!isFormEnabled) {
  //     setAddTask({
  //       date: '',
  //       userId: '',
  //       task: '',
  //       startTime: '',
  //       endTime: '',
  //       description: '',
  //       reportingTo: '',
  //     });
  //   }
  // };
  
//  const handleEditTask = (date: string, startTime: string, endTime: string) => {
//   setIsEdited(true);

//   // Find the selected task for editing
//   const selectedTask = taskList.find(
//     (task) => task.date === date && task.startTime === startTime && task.endTime === endTime
//   );
//   console.log("selectedTask",selectedTask)

//   if (selectedTask) {
//     setAddTask(selectedTask);

//     // Update the filteredTaskList based on the selected view (week, month, or date)
//     const startOfRange = () => {
//       if (selectedFilter === 'Week') {
//         return dayjs(currentWeekStart).startOf('week');
//       } else if (selectedFilter === 'Month') {
//         return dayjs(currentMonthStart).startOf('month');
//       } else {
//         // 'Date' filter
//         return dayjs(selectedTask.date);
//       }
//     };

//     const endOfRange = () => {
//       if (selectedFilter === 'Week') {
//         return dayjs(currentWeekStart).endOf('week');
//       } else if (selectedFilter === 'Month') {
//         return dayjs(currentMonthStart).endOf('month');
//       } else {

//         // 'Date' filter
//         return dayjs(selectedTask.date).endOf('day');
//       }
//     };

//     const tasksForSelectedRange = taskList.filter((task) => {
//       const taskDate = dayjs(task.date);
//       return ((taskDate.isAfter(startOfRange())|| taskDate.isSame(startOfRange()) &&(taskDate.isSame(endOfRange())|| taskDate.isBefore(endOfRange()))));
//     });

//     setFilteredTaskList(
//       tasksForSelectedRange.map((task, i) => ({ ...task, slNo: i + 1, idx: i + 1 }))
//     );
//   }
// };

//  const handleDeleteTask = (date: string, startTime: string, endTime: string) => {
//     setTaskList((prevTaskList) => {
//       const updatedList = prevTaskList.filter(
//         (task) => !(task.date === date && task.startTime === startTime && task.endTime === endTime)
//       );
  
//       localStorage.setItem('taskList', JSON.stringify(updatedList));
  
//       // Update filteredTaskList based on the selected view
//       const tasksForSelectedRange = updatedList.filter((task) => {
//         const taskDate = dayjs(task.date);
//         return ((taskDate.isAfter(startOfRange())|| taskDate.isSame(startOfRange()) &&(taskDate.isSame(endOfRange())|| taskDate.isBefore(endOfRange()))));
//       });
  
//       setFilteredTaskList(tasksForSelectedRange.map((task, i) => ({ ...task, slNo: i + 1 })));
  
//       return updatedList;
//     });
//     const startOfRange = () => {
//       if (selectedFilter === 'week') {
//         return dayjs(currentWeekStart).startOf('week');
//       } else if (selectedFilter === 'month') {
//         return dayjs(currentMonthStart).startOf('month');
//       }
//       return dayjs(currentDateStart); // Default to the date itself if no filter matches
//     };
  
//     const endOfRange = () => {
//       if (selectedFilter === 'week') {
//         return dayjs(currentWeekStart).endOf('week');
//       } else if (selectedFilter === 'month') {
//         return dayjs(currentMonthStart).endOf('month');
//       }
//       return dayjs(currentDateStart); // Default to the date itself if no filter matches
//     };
  
   
//   };
  
//  const handleSearchInputChange = (inputValue: string) => {
//   // Check if the input represents a valid date or month
//   const parsedDate = dayjs(inputValue, ['YYYY-MM-DD', 'MMMM'], true);

//   if (parsedDate.isValid()) {
//     // If it's a valid date, filter tasks based on the date
//     const tasksForSelectedDate = taskList.filter((task) => task.date === parsedDate.format('YYYY-MM-DD'));
//     setFilteredTaskList(tasksForSelectedDate.map((task, index) => ({ ...task, slNo: index + 1 })));
//   } else if (parsedDate.month() !== undefined) {
//     const startOfMonth = parsedDate.startOf('month').format('YYYY-MM-DD');
//     const endOfMonth = parsedDate.endOf('month').format('YYYY-MM-DD');
//     const tasksForSelectedMonth = taskList.filter((task) => {
//     const taskDate = dayjs(task.date, 'YYYY-MM-DD');
//     return (taskDate.isSame(startOfMonth) || taskDate.isAfter(startOfMonth)) && ( taskDate.isSame(endOfMonth) ||taskDate.isBefore(endOfMonth));
//   });

//   setFilteredTaskList(tasksForSelectedMonth.map((task, index) => ({ ...task, slNo: index + 1 })));
//   } else {
//     // If it's neither a valid date nor a valid month, you can handle it as needed
//     // For example, you might clear the filter or display a message to the user
//     // based on your application requirements.
//   //   const tasksForSelectedDate = taskList.filter((task) => task.date === selectedDate);
//   // setFilteredTaskList(tasksForSelectedDate.map((task, index) => ({ ...task, slNo: index + 1 })));
//   setFilteredTaskList([]);
//   }
// };
 
//   const handleTableSubmit = () => {
//     // Calculate the total time spent on each task
//     const totalTimeByTask: { [key: string]: number } = {};
  
//     // Update filteredTaskList based on the selected date
//     const tasksForSelectedDate = filteredTaskList; // Use filteredTaskList instead of taskList
//     setFilteredTaskList(tasksForSelectedDate);
  
//     tasksForSelectedDate.forEach((task) => {
//       const startTime = dayjs(task.startTime, 'hh:mm A');
//       const endTime = dayjs(task.endTime, 'hh:mm A');
  
//       // Calculate the time difference in hours
//       const durationInHours = endTime.diff(startTime, 'hours', true);
  
//       // Accumulate the time for each task
//       if (totalTimeByTask[task.task]) {
//         totalTimeByTask[task.task] += durationInHours;
//       } else {
//         totalTimeByTask[task.task] = durationInHours;
//       }
//     });
  
//     // Log the total time spent on each task to the console
//     //console.log('Total Time By Task:', totalTimeByTask);
  
//     // Pass the totalTimeByTask data to the PieChart component
//     setPieChartData(totalTimeByTask);
//   };
 
//   return (
//     <DashboardLayout>
//       <div className='createuser-main'>
//         <div className='header'>
//           <div>
//             <h1>Add Task</h1>
//           </div>
//           {
      //   !isEdited && selectedFilter === 'Month' ? (
      //     <>
      //       <div>From: {dayjs(currentMonthStart).format('YYYY-MM-DD')}</div>
      //       <div style={{ marginLeft: '20px' }}>To: {dayjs(currentMonthStart).endOf('month').format('YYYY-MM-DD')}</div>
      //     </>
      //   ) : !isEdited && selectedFilter === 'Week' ? (
      //     <>
      //       <div>From: {currentWeekStart}</div>
      //       <div style={{ marginLeft: '2px' }}>To: {dayjs(currentWeekStart).endOf('week').format('YYYY-MM-DD')}</div>
      //     </>
      //   ) : selectedFilter === 'Day' ? (
      //     <div className='Date'>Date: {currentDateStart}</div>
      //   ) : isEdited && selectedFilter === 'Day' ? (
      //     <div className='Date'>Date: {currentDateStart}</div>
      //   ) : (
      //     <div className='Date'>Date: {addTask.date}</div>
      //   )
      // }
//         </div>
//        {  (selectedFilter==='Date' || (isFormEnabled && selectedFilter!=='Date' )|| ((selectedFilter==='Month' || selectedFilter==='Week')&&isEdited))&&
//        (<form id="myForm" style={borderStyle}>
//           <div>
//             <div className='section-addtask'>
//             <div className='create-layout-addtask-left  '>
//                 <div style={{marginBottom:'10px'}}>
//                   <label htmlFor='addTaskID'>Date</label>
//                 </div>
//                 <input
//                   type="date"
//                   style={{ width: '100%' }}
//                   value={formSelectDate}
//                   onChange={(e) => handleDateChange(e.target.value)}
//                   className='timepicker'
//                 />
//               </div>
//               <div className='create-layout-addtask-left  '>
//                 <div style={{marginBottom:'10px'}}>
//                   <label htmlFor='addTaskID'>User ID</label>
//                 </div>
//                 <Input
//                   placeholder='Enter your Employee ID'
//                   value={addTask.userId}
//                   onChange={(e) => handleInputChange('userId', e.target.value)}
                  
//                 />
//               </div>
//             </div>
//             <div className='section-addtask'>
//               <div className='create-layout-addtask-left'>
//                 <div>
//                   <label htmlFor='startTime'>Start Time</label>
//                 </div>
//                 <TimePicker
//                   value={
//                     addTask.startTime
//                       ? dayjs(addTask.startTime, 'hh:mm A') // Convert to dayjs here
//                       : null
//                   }
//                   onChange={(time, timeString) =>
//                     handleInputChange('startTime', timeString)
//                   }
//                   className='timepicker'
//                   format='hh:mm A' // Set the format to include AM/PM
//                 />
//               </div>
//               <div className='create-layout-addtask'>
//                 <div>
//                   <label htmlFor='endTime'>End Time</label>
//                 </div>
//                 <TimePicker
//                   value={
//                     addTask.endTime
//                       ? dayjs(addTask.endTime, 'HH:mm A') // Convert to dayjs here
//                       : null
//                   }
//                   onChange={(time, timeString) =>
//                     handleInputChange('endTime', timeString)
//                   }
//                   className='timepicker'
//                   format='hh:mm A'  // <-- Change this to 'hh:mm A'
//                   rootClassName='timer'
//                 />
//               </div>
//             </div>
//             <div className='section-addtask'>
              
//               <div className='create-layout-addtask'>
//                 <div>
//                   <label htmlFor='task'>Task</label>
//                 </div>
//                 <div>
//                   <select
//                     id='task'
//                     value={addTask.task}
//                     onChange={(e) => handleInputChange('task', e.target.value)}
//                   >
//                     {taskOptions.map((option) => (
//                         <option key={option} value={option}>
//                           {option}
//                         </option>
//                       ))}
//                   </select>
//                 </div>
//               </div>
//               <div className='create-layout-addtask-reportingTo  '>
//                 <div className='create-layout-reportingTo'>
//                   <label htmlFor='reportingTo'>Reporting To</label>
//                 </div>
//                 <select
//                   id='reportingTo-addtask'
//                   value={addTask.reportingTo}
//                   onChange={(e) => handleInputChange('reportingTo', e.target.value)}
//                 >
//                   <option value=''>Select Reporting To</option>
//                   {reportingOptions.map((option) => (
//                     <option key={option} value={option}>
//                       {option}
//                     </option>
//                   ))}
//                 </select>
//               </div> 
//             </div>  
//             <div>
//               <div className='create-layout-description'>
//                 <div>
//                   <label>Description</label>
//                 </div>
//                 <textarea
//                   value={addTask.description}
//                   onChange={(e) => handleInputChange('description', e.target.value)}
//                   className='description-input'
//                 />
//               </div>
//             </div>
//           </div>
            
          
//           <div className='button'>
//             <button type='button' id='cancel-addtask'>
//               Clear
//             </button>
            // {isEdited ? (
            //   <button type='button' id='submit-addtask' onClick={handleFormSubmit}>
            //     Save
            //   </button>
            // ):(
            //   <button type='button' id='submit-addtask' onClick={handleFormSubmit}>
            //     Add Task
            //   </button>
            // )}
            
//           </div>

//         </form>)}
//       <div>
//         <div style={{ display:'flex', justifyContent:'flex-end', margin:'10px 20px' }}>
//         <Input
//             className="search-addtask"
//             placeholder="Search by Date or Month"
//             allowClear
//             suffix={<SearchOutlined style={{ color: "#04172480" }} />}
//             onChange={(e: any) => handleSearchInputChange(e.target.value)}
//             style={{marginLeft:'20px'}}
//           />
//           <button id='cancel' onClick={handleToggleForm} disabled={selectedFilter==='Date'}>{(isFormEnabled )? 'Cancel' : 'Add Task'}</button>
          // <button type='button' id='submit-less' onClick={handlePrev}>
          //   <LeftOutlined />
          // </button>

//         {/* Dropdown to select Month or Week */}
          // <select 
          //   id='submit' 
          //   style={{ appearance: 'none', WebkitAppearance: 'none', MozAppearance: 'none' }} 
          //   onChange={(e) => handleFilterChange(e.target.value)} value={selectedFilter}
          //   onMouseEnter={handleMouseEnter}
          //   onMouseLeave={handleMouseLeave}
          // >
          //   <option value='Day'>Day</option>
          //   <option value='Week'>Week</option>
          //   <option value='Month'>Month</option>
          // </select>
//           {/* {isDropdownVisible && (
//             <div
//               style={{
//                 position: 'absolute',
//                 zIndex: 1,
//                 backgroundColor: '#fff',
//                 border: '1px solid #ccc',
//                 marginTop: '1px',
//               }}
//             >
//               <div onClick={() => handleFilterChange('Month')}>Month</div>
//               <div onClick={() => handleFilterChange('Week')}>Week</div>
//             </div>)} */}
//           <button type='button' id='submit-less' onClick={handleNext}>
//             <RightOutlined />
//           </button>
//         </div>
//       </div>
      
      
//       <>
//       <Table
//           columns={columns}
//           dataSource={filteredTaskList}
//           //pagination={paginationOptions}
//         />
//           <button type='button' id='submit-overall' onClick={handleTableSubmit}>
//             Submit
//           </button>
//         </>
//         </div>
//     </DashboardLayout>
//   );
// };
// export default AddTask;
  
  

final code change





import React, { useState, useEffect } from 'react';
import { Input, TimePicker, Select, notification, DatePicker} from 'antd';
import { Filter, SearchOutlined } from '@mui/icons-material';
import dayjs from 'dayjs';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { useMsal } from '@azure/msal-react';
import '../Styles/CreateUser.css';
import DashboardLayout from './Layout';
import '../Styles/AddTask.css';
import {Table} from 'antd';
import { ColumnsType } from "antd/es/table";
import { EditOutlined, DeleteOutlined,CloseCircleOutlined,LeftOutlined, RightOutlined } from '@ant-design/icons';
import Dashboard from './Dashboard';
export interface Task {
  date: string;
  userId: string;
  task: string;
  startTime: string;
  endTime: string;
  totalHours:string;
  description: string;
  reportingTo: string;
  slNo?: number;
  idx?:number;
}
interface AddTaskProps {
  setPieChartData: (data: { [key: string]: number }) => void;
}
const AddTask: React.FC<AddTaskProps> = ({ setPieChartData }) => {
  const [formWidth, setFormWidth] = useState(800);
  const [currentDate, setCurrentDate] = useState(dayjs());
  const [currentWeek, setCurrentWeek] = useState(dayjs().startOf('week'));
  const [currentMonth, setCurrentMonth] = useState(dayjs().startOf('month'));
  const [isFormEnabled, setIsFormEnabled] = useState(false);
  const [addTask, setAddTask] = useState<Task>({
    date: currentDate.format('YYYY-MM-DD'),
    userId: '1234',
    task: '',
    startTime: '',
    endTime: '',
    totalHours:'',
    description: '',
    reportingTo: '',
  });
  const [taskList, setTaskList] = useState<Task[]>([]);
  const [filteredTasks, setFilteredTasks] = useState<Task[]>([]);
  const reportingOptions = ['ManagerA', 'ManagerB', 'ManagerC'];
  const taskOptions = ['Task','Project','Learning','Training','Meeting'];
  const [filterOption, setFilterOption] = useState('Date');
  const [isEdited, setIsEdited]= useState<boolean>(false);
  // State to manage the search input
  const [searchInput, setSearchInput] = useState('');
  const [isFormSubmitted, setIsFormSubmitted] = useState(false);
 // console.log("currentdate", currentDate); 
  const updateSlNo = (tasks: Task[]): Task[] => {
    return tasks.map((task, index) => ({ ...task, slNo: index + 1,idx: task.slNo }));
  };
  useEffect(() => {
    const updateFormWidth = () => {
      const formElement = document.getElementById('myForm');
      if (formElement) {
        const newWidth = formElement.offsetWidth;
        setFormWidth(newWidth);
      }
    };

    window.addEventListener('resize', updateFormWidth);
    updateFormWidth();

    return () => {
      window.removeEventListener('resize', updateFormWidth);
    };
  }, []);

  const borderStyle = {
    border: '1px solid black',
    margin: '10px 20px',
    paddingRight: '0',
    width: formWidth + 'px',
  };

  // const handleInputChange = (field: keyof Task, value: string) => {
  //   if (field === 'date') {
  //     const selectedDate = dayjs(value);
  
  //     if (selectedDate.isAfter(dayjs(), 'day')) {
  //       // Display a notification
  //       notification.warning({
  //         message: 'Warning',
  //         description: 'Cannot select a future date.',
  //       });
  
  //       // Set the selected date to today
  //       setCurrentDate(dayjs());
  //     } else {
  //       // Update the state with the selected date
  //       setCurrentDate(selectedDate);
  //     }
  //   }  
  //   // Keep userId constant
  // if (field === 'userId') {
  //   setAddTask((prevTask) => ({ ...prevTask, [field]: value }));
  // } else {
  //   // Update startTime or endTime with the new value
  //   const updatedTime = value || dayjs().format('hh:mm A');
  //   setAddTask((prevTask) => ({ ...prevTask, [field]: updatedTime }));

  //   // Calculate the duration and update totalHours
  //   const updatedStartTime = field === 'startTime' ? updatedTime : addTask.startTime || dayjs().format('hh:mm A');
  //   const updatedEndTime = field === 'endTime' ? updatedTime : addTask.endTime || dayjs().format('hh:mm A');
  //   const duration = dayjs(updatedEndTime, 'hh:mm A').diff(dayjs(updatedStartTime, 'hh:mm A'), 'hour', true);

  //   console.log('updatedStartTime:', updatedStartTime);
  //   console.log('updatedEndTime:', updatedEndTime);
  //   console.log('duration:', duration);

  //   setAddTask((prevTask) => ({
  //     ...prevTask,
  //     totalHours: duration.toFixed(2), // Adjust decimal places as needed
  //   }));
  // }
  // };

  const handleInputChange = (field: keyof Task, value: string) => {
    if (field === 'date') {
      const selectedDate = dayjs(value);
  
      if (selectedDate.isAfter(dayjs(), 'day')) {
        // Display a notification
        notification.warning({
          message: 'Warning',
          description: 'Cannot select a future date.',
        });
  
        // Set the selected date to today
        setCurrentDate(dayjs());
      } else {
        // Update the state with the selected date
        setCurrentDate(selectedDate);
      }
    }
  
    // Keep userId constant
    if (field === 'userId') {
      setAddTask((prevTask) => ({ ...prevTask, [field]: value }));
    } else {
      // Update startTime or endTime with the new value
      const updatedTime = value || dayjs().format('hh:mm A');
      setAddTask((prevTask) => ({ ...prevTask, [field]: updatedTime }));
  
      // Calculate the duration and update totalHours
      const updatedStartTime = field === 'startTime' ? updatedTime : addTask.startTime || dayjs().format('hh:mm A');
      const updatedEndTime = field === 'endTime' ? updatedTime : addTask.endTime || dayjs().format('hh:mm A');
      const duration = dayjs(updatedEndTime, 'hh:mm A').diff(dayjs(updatedStartTime, 'hh:mm A'), 'hour', true);
  
      setAddTask((prevTask) => ({
        ...prevTask,
        startTime: field === 'startTime' ? updatedTime : addTask.startTime,
        endTime: field === 'endTime' ? updatedTime : addTask.endTime,
        totalHours: duration.toFixed(2),
      }));
    }
  };
  
  useEffect(() => {
    // Load taskList from localStorage on component mount
    const storedTaskListString = localStorage.getItem('taskList');
    const storedTaskList = storedTaskListString ? JSON.parse(storedTaskListString) : [];
    setTaskList(storedTaskList);
    setFilteredTasks(updateSlNo(storedTaskList)); // Update slNo when loading tasks
  }, []);

  useEffect(() => {
    // Filter tasks based on the addTask.date when it changes
    if (addTask.date) {
      const filtered = taskList.filter(task => task.date === addTask.date);
      setFilteredTasks(updateSlNo(filtered)); // Update slNo when loading tasks
    } else {
      // If no date is selected, display all tasks
      setFilteredTasks(updateSlNo(taskList)); // Update slNo when loading tasks
    }
  }, [addTask.date, taskList]);

  useEffect(() => {
    // Update addTask with the current date
    if (!isEdited) {
      // Update addTask with the current date only when not in edit mode
      setAddTask((prevAddTask) => ({
        ...prevAddTask,
        date: dayjs(currentDate).format('YYYY-MM-DD'),
    }));
  }
    //setFilteredTasks(taskList);
    // Filter tasks based on the filterOption and currentDate when they change
    let filtered: Task[] = [];

    if (searchInput) {
      // If there is a search input, filter tasks based on date or month
      const searchDate = dayjs(searchInput);
      filtered = taskList.filter((task) => {
        if (filterOption === 'Date') {
          return dayjs(task.date).isSame(searchDate, 'day');
        } else if (filterOption === 'Week') {
          const startOfWeek = currentWeek.startOf('week');
          const endOfWeek = currentWeek.endOf('week');
          return (
            (dayjs(task.date).isSame(startOfWeek) || dayjs(task.date).isAfter(startOfWeek)) &&
            (dayjs(task.date).isSame(endOfWeek) || dayjs(task.date).isBefore(endOfWeek))
          );
        } else if (filterOption === 'Month') {
          // Format the searchInput in the same way as the task date
          const formattedSearchMonth = searchDate.format('MMMM');
          return dayjs(task.date).format('MMMM') === formattedSearchMonth;
        }
        return false;
      });
    }  else {
      //setFilteredTasks(taskList);
      // If no search input, apply the regular filtering based on filterOption and currentDate
      if (filterOption === 'Date') {
        filtered = taskList.filter((task) => task.date === dayjs(currentDate).format('YYYY-MM-DD'));
        setFilteredTasks(updateSlNo(filtered)); // Update slNo when loading tasks
     //   console.log("useEffect-date", filtered)
      } else if (filterOption === 'Week') {
        const startOfWeek = currentWeek.startOf('week');
        const endOfWeek = currentWeek.endOf('week');
        filtered = taskList.filter(
          (task) =>
            (dayjs(task.date).isSame(startOfWeek) || dayjs(task.date).isAfter(startOfWeek)) &&
            (dayjs(task.date).isSame(endOfWeek) || dayjs(task.date).isBefore(endOfWeek))
        );
        setFilteredTasks(updateSlNo(filtered)); // Update slNo when loading tasks
        //console.log("useeffect-week", filtered);
      } else if (filterOption === 'Month') {
        const startOfMonth = currentMonth.startOf('month');
        const endOfMonth = currentMonth.endOf('month');
        filtered = taskList.filter(
          (task) =>
            (dayjs(task.date).isSame(startOfMonth) || dayjs(task.date).isAfter(startOfMonth)) &&
            (dayjs(task.date).isSame(endOfMonth) || dayjs(task.date).isBefore(endOfMonth))
        );
        setFilteredTasks(updateSlNo(filtered));
       // console.log("useeffect-month", filtered);
      }
    }

    setFilteredTasks(updateSlNo(filtered));
    //console.log("useeffect filtered-task", filteredTasks);
  }, [isEdited, filterOption, currentDate, currentMonth, currentWeek, taskList, searchInput]);


  const handleFilterChange = (value: any) => {
    setFilterOption(value);
  };

  const handleLeftArrowClick = () => {
    if (filterOption === 'Date') {
     // console.log("handleLeftArrowClick -prev", currentDate);
      const previousDate = currentDate.subtract(1, 'day');
    //  console.log("handleLeftArrowClick previousDate",previousDate)
      setCurrentDate(previousDate);

    } else if (filterOption === 'Week') {
      const previousWeekStart = currentWeek.subtract(1, 'week').startOf('week');
      const previousWeekEnd = currentWeek.subtract(1, 'week').endOf('week');
      setCurrentWeek(previousWeekStart);
     // console.log("previousWeek",previousWeekStart)
    } else if (filterOption === 'Month') {
      const previousMonthStart = currentMonth.subtract(1, 'month').startOf('month');
      const previousMonthEnd = currentMonth.subtract(1, 'month').endOf('month');
      setCurrentMonth(previousMonthStart);
    }
  };

  const handleRightArrowClick = () => {
    if (filterOption === 'Date') {
      const nextDate = currentDate.add(1, 'day');
      if(nextDate.isAfter(dayjs(), 'day')){
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future weeks.',
        });
        return;
      }
      setCurrentDate(nextDate);
    } else if (filterOption === 'Week') {
      const nextWeekStart = currentWeek.add(1, 'week').startOf('week');
      const nextWeekEnd = currentWeek.add(1, 'week').endOf('week');
      if (nextWeekStart.isAfter(dayjs(), 'day')) {
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future weeks.',
        });
        return;
      }
      setCurrentWeek(nextWeekStart);
      //console.log("previousWeek",nextWeekStart)
      
    } else if (filterOption === 'Month') {
      const nextMonthStart = currentMonth.add(1, 'month').startOf('month');
      if (nextMonthStart.isAfter(dayjs(), 'day')) {
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future months.',
        });
        return;
      }
      setCurrentMonth(nextMonthStart);
      //console.log("nextMonthStart", nextMonthStart);
    }
    
  };

  const handleToggleForm = () => {
    setIsFormEnabled((prevIsFormEnabled) => !prevIsFormEnabled);
  
    // If you want to reset the form when disabling it, you can reset the form state here
    if (!isFormEnabled) {
      setAddTask({
        date: dayjs(currentDate).format('YYYY-MM-DD'),
        userId: '1234',
        task: '',
        startTime: '',
        endTime: '',
        totalHours:'',
        description: '',
        reportingTo: '',
      });
    }
  };

  
  const handleFormSubmit = () => {
    console.log("---fd1", dayjs(addTask.date).format('YYYY-MM-DD'), dayjs(addTask.startTime).format('hh:mm A'), dayjs(addTask.endTime).format('hh:mm A'));
    // Check for overlapping tasks in the specified time range
    const overlappingTask = taskList.find((task) => {
      const newTaskStartTime = dayjs(addTask.startTime, 'hh:mm A');
      const newTaskEndTime = dayjs(addTask.endTime, 'hh:mm A');
      const taskStartTime = dayjs(task.startTime, 'hh:mm A');
      const taskEndTime = dayjs(task.endTime, 'hh:mm A');
    
      // Check if the new task overlaps with any existing task
      return (
        !isEdited && task.date === addTask.date &&
        // ((newTaskStartTime.isSame(taskStartTime) && newTaskStartTime.isBefore(taskEndTime)) && newTaskEndTime.isSame(taskEndTime))
        (
          ((newTaskStartTime.isSame(taskStartTime) || newTaskStartTime.isAfter(taskStartTime))&& newTaskStartTime.isBefore(taskEndTime)) ||
          ((newTaskEndTime.isSame(taskStartTime) || newTaskEndTime.isAfter(taskStartTime))&& newTaskEndTime.isBefore(taskEndTime)) ||
          (newTaskStartTime.isBefore(taskStartTime) && (newTaskEndTime.isSame(taskEndTime)|| newTaskEndTime.isAfter(taskEndTime)))
        )
      );
    });
      
    if (overlappingTask) {
      notification.warning({
        message: 'Restricted',
        description: 'Task already exists in the specified time range.',
      });
      return;
    }

    if (isEdited) {
      // If editing, update the existing task
      console.log("--fd2", filteredTasks);
      console.log("---fd2", addTask.slNo);
  
      const updatedFilteredTasks = filteredTasks.map((task) =>
        task.slNo === addTask.slNo ? { ...addTask } : task
      );
  
      setFilteredTasks(updateSlNo(updatedFilteredTasks)); // Update slNo when updating tasks
  
      // Find the index of the task in the original taskList based on slNo
      const idxInTaskList = taskList.findIndex((task) => task.slNo === addTask.idx);
  
      if (idxInTaskList !== -1) {
        // If found, update the task in the taskList
        const updatedTaskList = [...taskList];
        updatedTaskList[idxInTaskList] = { ...addTask };
        setTaskList(updatedTaskList);
  
        // Update localStorage
        localStorage.setItem('taskList', JSON.stringify(updatedTaskList));
      }
  
      setIsEdited(false);
    } else{
      // Update the taskList
      const updatedTaskList = [...taskList, { ...addTask, slNo: taskList.length + 1 }];
      setTaskList(updatedTaskList);
      setFilteredTasks(updateSlNo(updatedTaskList)); // Update slNo when updating tasks
      // Update localStorage
      localStorage.setItem('taskList', JSON.stringify(updatedTaskList));

    }
    // Clear the form with the default date
    setAddTask({
      date: dayjs(currentDate).format('YYYY-MM-DD'),
      userId: '1234',
      task: '',
      startTime: '',
      endTime: '',
      totalHours:'',
      description: '',
      reportingTo: '',
    });
    //setIsEdited(false);
    setIsFormSubmitted(true);
  };


  const handleClearSubmit = () =>{
    // Clear the form with the default date
    setAddTask({
      date: dayjs(addTask.date).format('YYYY-MM-DD'),
      userId: '1234',
      task: '',
      startTime: '',
      endTime: '',
      totalHours:'',
      description: '',
      reportingTo: '',
    });
  }

  // const handleEditTask = (date: string, startTime: string, endTime: string) => {
  //   // Implement the logic to edit the task based on date, startTime, and endTime
  //   // You can use the setAddTask function to update the form fields with the selected task's details
  //   // For example:
  //   setIsEdited(true);
  //   const taskToEdit = taskList.find(
  //     (task) => task.date === date && task.startTime === startTime && task.endTime === endTime
  //   );
  //   if (taskToEdit) {
  //     setAddTask({
  //       date: taskToEdit.date,
  //       userId: taskToEdit.userId,
  //       task: taskToEdit.task,
  //       startTime: taskToEdit.startTime,
  //       endTime: taskToEdit.endTime,
  //       totalHours: taskToEdit.totalHours,
  //       description: taskToEdit.description,
  //       reportingTo: taskToEdit.reportingTo,
  //     });

  //     // Now, you can perform additional actions or display a modal for editing
  //     setCurrentDate(dayjs(date));
  //   }
  // };

  const handleEditTask = (date: string, startTime: string, endTime: string) => {
    // Implement the logic to edit the task based on date, startTime, and endTime
    // You can use the setAddTask function to update the form fields with the selected task's details
    // For example:
    setIsEdited(true);
    
    // Use filteredTasks instead of taskList to find the task
    const taskToEdit = filteredTasks.find(
      (task) => task.date === date && task.startTime === startTime && task.endTime === endTime
    );
    console.log("edit", taskToEdit);
    if (taskToEdit) {
      setAddTask({
        slNo: taskToEdit.slNo,
        idx: taskToEdit.idx,
        date: taskToEdit.date,
        userId: taskToEdit.userId,
        task: taskToEdit.task,
        startTime: taskToEdit.startTime,
        endTime: taskToEdit.endTime,
        totalHours: taskToEdit.totalHours,
        description: taskToEdit.description,
        reportingTo: taskToEdit.reportingTo,
      });
  
      // Now, you can perform additional actions or display a modal for editing
      setCurrentDate(dayjs(date));
    }
  };
  
  
  const handleDeleteTask = (date: string, startTime: string, endTime: string) => {
    // Implement the logic to delete the task based on date, startTime, and endTime
    // For example:
    const updatedTaskList = taskList.filter(
      (task) => !(task.date === date && task.startTime === startTime && task.endTime === endTime)
    );

    setTaskList(updatedTaskList);
    setFilteredTasks(updatedTaskList);

    // Update localStorage
    localStorage.setItem('taskList', JSON.stringify(updatedTaskList));

    // Additional actions after deletion
    // ...
  };


  const columns: ColumnsType<Task> = [
    {
      title: 'Sl.no',
      sorter: (a: Task, b: Task) => (a.slNo && b.slNo ? a.slNo - b.slNo : 0),
      dataIndex: 'slNo',
      key: 'slNo',
      fixed: 'left',
    },
    {
      title: 'Task',
      sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
      dataIndex: 'task',
      key: 'task',
      fixed: 'left',
    },
    {
      title: 'Date',
      sorter: (a: Task, b: Task) => a.date.localeCompare(b.date),
      dataIndex: 'date',
      key: 'date',
      fixed: 'left',
    },
    {
      title: 'Start Time',
      sorter: (a: Task, b: Task) => a.startTime.localeCompare(b.startTime),
      dataIndex: 'startTime',
      key: 'startTime',
      fixed: 'left',
    },
    {
      title: 'End Time',
      sorter: (a: Task, b: Task) => a.endTime.localeCompare(b.endTime),
      dataIndex: 'endTime',
      key: 'endTime',
      fixed: 'left',
    },
    {
      title: 'Total Hours',
      sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
      dataIndex: 'totalHours',
      key: 'totalHours',
      fixed: 'left',
    },
    {
      title: 'Description',
      sorter: (a: Task, b: Task) => a.description.localeCompare(b.description),
      dataIndex: 'description',
      key: 'description',
      fixed: 'left',
    },
    {
      title: 'Reporting To',
      sorter: (a: Task, b: Task) => a.reportingTo.localeCompare(b.reportingTo),
      dataIndex: 'reportingTo',
      key: 'reportingTo',
      fixed: 'left',
    },
    
    {
      title: 'Actions',
      dataIndex: 'actions',
      key: 'actions',
      render: (_, record, index) => (
        <div>
          <EditOutlined
            onClick={() => handleEditTask(record.date, record.startTime, record.endTime)}
            style={{
              marginRight: '8px',
              cursor: 'pointer',
              color: 'blue',
              fontSize: '20px',
            }}
            // style={{
            //   marginRight: '8px',
            //   cursor: selectedFilter === 'Month' || selectedFilter === 'Week' ? 'not-allowed' : 'pointer',
            //   color: selectedFilter === 'Month' || selectedFilter === 'Week' ? 'grey' : 'blue',
            //   fontSize: '20px',
            // }}
            // disabled={selectedFilter === 'Month' || selectedFilter === 'Week'}
          />
          <DeleteOutlined
            onClick={() => handleDeleteTask(record.date, record.startTime, record.endTime)}
             style={{
              cursor: 'pointer',
              color:  'red',
              fontSize: '20px',
            }}
            // style={{
            //   cursor: selectedFilter === 'Month' || selectedFilter === 'Week' ? 'not-allowed' : 'pointer',
            //   color: selectedFilter === 'Month' || selectedFilter === 'Week' ? 'grey' : 'red',
            //   fontSize: '20px',
            // }}
            // disabled={selectedFilter === 'Month' || selectedFilter === 'Week'}
          />
        </div>
    )}
  ]

  return (
    <DashboardLayout>
      <div className='createuser-main'>
        <div className='header'>
          <div>
            <h1>Add Task</h1>
          </div>
          { filterOption === 'Month' ? (
            <div style={{display:'flex', justifyContent:'flex-end'}}>
              <div className='date'>From: {dayjs(currentMonth).format('YYYY-MM-DD')}</div>
              <div className='date' style={{ marginLeft: '40px' }}>To: {dayjs(currentMonth).endOf('month').format('YYYY-MM-DD')}</div>
            </div>
            ) : filterOption === 'Week' ? (
              <div style={{display:'flex', justifyContent:'flex-end'}}>
                <div className='date'>From: {dayjs(currentWeek).format('YYYY-MM-DD')}</div>
                <div className='date' style={{ marginLeft: '40px' }}>To: {dayjs(currentWeek).endOf('week').format('YYYY-MM-DD')}</div>
              </div>
            )  : (
              <div className='date'>Date: {currentDate.format('YYYY-MM-DD')}</div>
            )
          }
        </div>
        {(filterOption === 'Date' || ((filterOption === 'Week' || filterOption === 'Month') && isEdited)) || isFormEnabled  ? ( <form id="myForm" style={borderStyle}>
            <div>
            {isFormEnabled && (
              <CloseCircleOutlined
                style={{ margin: '10px 20px', display: 'flex', justifyContent: 'flex-end', color: 'red' }}
                onClick={handleToggleForm} // Call the handleToggleForm function on click
              />
            )}
              <div className='section-addtask'>
              <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label htmlFor='addTaskID'>Date</label>
                  </div>
                  {/* <input
                    type="date"
                    style={{ width: '100%' }}
                    className='timepicker'
                  /> */}
                  <Input
                    type='date'
                    placeholder='Enter your Employee ID'
                    value={currentDate.format('YYYY-MM-DD')} 
                    onChange={(e) => handleInputChange('date', e.target.value)}
                  />

                </div>
                {/* <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label htmlFor='addTaskID'>User ID</label>
                  </div>
                  <Input
                    placeholder='Enter your Employee ID'
                    value={addTask.userId}
                    onChange={(e) => handleInputChange('userId', e.target.value)}
                    
                  />
                </div> */}
                 <div className='create-layout-addtask'>
                  <div>
                    <label htmlFor='task'>Task</label>
                  </div>
                  <div>
                    <select
                      id='task'
                      value={addTask.task}
                      onChange={(e) => handleInputChange('task', e.target.value)}
                    >
                      {taskOptions.map((option) => (
                          <option key={option} value={option}>
                            {option}
                          </option>
                        ))}
                    </select>
                  </div>
                </div>
              </div>
              <div className='section-addtask'>
                <div className='create-layout-addtask-left'>
                  <div>
                    <label htmlFor='startTime'>Start Time</label>
                  </div>
                  <TimePicker
                    value={
                      addTask.startTime
                        ? dayjs(addTask.startTime, 'hh:mm A') // Convert to dayjs here
                        : null
                    }
                    onChange={(time, timeString) =>
                      handleInputChange('startTime', timeString)
                    }
                    className='timepicker'
                    format='hh:mm A' // Set the format to include AM/PM
                  />
                </div>
                <div className='create-layout-addtask'>
                  <div>
                    <label htmlFor='endTime'>End Time</label>
                  </div>
                  <TimePicker
                    value={
                      addTask.endTime
                        ? dayjs(addTask.endTime, 'HH:mm A') // Convert to dayjs here
                        : null
                    }
                    onChange={(time, timeString) =>
                      handleInputChange('endTime', timeString)
                    }
                    className='timepicker'
                    format='hh:mm A'  // <-- Change this to 'hh:mm A'
                    rootClassName='timer'
                  />
                </div>
              </div>
              <div className='section-addtask'>
                
              <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label htmlFor='totalHours'>Total Hours</label>
                  </div>
                  <Input
                    placeholder='Enter your Total Hours'
                    value={addTask.totalHours}
                    onChange={(e) => handleInputChange('totalHours', e.target.value)}
                    
                  />
                </div>
                <div className='create-layout-addtask-reportingTo  '>
                  <div className='create-layout-reportingTo'>
                    <label htmlFor='reportingTo'>Reporting To</label>
                  </div>
                  <select
                    id='reportingTo-addtask'
                    value={addTask.reportingTo}
                    onChange={(e) => handleInputChange('reportingTo', e.target.value)}
                  >
                    <option value=''>Select Reporting To</option>
                    {reportingOptions.map((option) => (
                      <option key={option} value={option}>
                        {option}
                      </option>
                    ))}
                  </select>
                </div> 
              </div>  
              <div>
                <div className='create-layout-description'>
                  <div>
                    <label>Description</label>
                  </div>
                  <textarea
                    value={addTask.description}
                    onChange={(e) => handleInputChange('description', e.target.value)}
                    className='description-input'
                  />
                </div>
              </div>
            </div>
              
            
            <div className='button'>
              <button type='button' id='cancel-addtask' onClick={handleClearSubmit}>
                Clear
              </button>
              {isEdited ? (
              <button type='button' id='submit-addtask' onClick={handleFormSubmit}>
                Save
              </button>
            ):(
              <button type='button' id='submit-addtask' onClick={handleFormSubmit}>
                Add Task
              </button>
            )}
            </div>

        </form>):null}
        <>
        <div>
          <div style={{ display:'flex', justifyContent:'space-between', margin:'10px 20px' }}>
            <Input
            className="search-addtask"
            placeholder="Search by Date"
            allowClear
            suffix={<SearchOutlined style={{ color: "#04172480" }} />}
            onChange={(e) => {
            //  console.log("Search input value:", e.target.value);
              setSearchInput(e.target.value);
            }}
          />
         {/* <button id='cancel' onClick={handleToggleForm} hidden={filterOption === 'Date'}>{(isFormEnabled) ? 'Cancel' : 'Add Task'}</button> */}
         {!(filterOption === 'Date' && !isFormEnabled) && (
            <button
              id='cancel'
              onClick={handleToggleForm}
              disabled={isFormEnabled} // Disable the button when the form is enabled
            >
              Add Task
            </button>
          )}
          <div style={{display:'flex', justifyContent:'flex-end'}}>
          <button type='button' id='submit-less' onClick={handleLeftArrowClick}>
            <LeftOutlined />
          </button>

        {/* <Select
           
            style={{
              marginTop: '10px',
              display: 'flex',
              padding: '0.5em 2em',
              border: 'transparent',
              boxShadow: '2px 2px 4px rgba(0,0,0,0.4)',
              justifyContent: 'center',
              alignItems: 'center',
              gap: '10px',
              borderRadius: '4px',
              color:'white',
              background: '#0B4266',
              cursor: 'pointer',
              appearance: 'none',
              WebkitAppearance: 'none',
              MozAppearance: 'none',
            }}
            defaultValue="Date"
            onChange={handleFilterChange}
        >
          <Select.Option value="Date">Date</Select.Option>
          <Select.Option value="Week">Week</Select.Option>
          <Select.Option value="Month">Month</Select.Option>
        </Select> */}
          <select 
            id='submit' 
            style={{ appearance: 'none', WebkitAppearance: 'none', MozAppearance: 'none' }} 
            onChange={(e) => handleFilterChange(e.target.value)} value={filterOption}
          >
            <option style={{textAlign:'center'}} value='Day'>Day</option>
            <option style={{textAlign:'center'}} value='Week'>Week</option>
            <option style={{textAlign:'center'}} value='Month'>Month</option>
          </select>
          <button type='button' id='submit-less' onClick={handleRightArrowClick}>
            <RightOutlined />
          </button>
          </div>
        </div>
      </div>
        <Table
            columns={columns}
            dataSource={filteredTasks}
            //pagination={paginationOptions}
            pagination={false}
          />
            <button type='button' id='submit-overall'>
              Submit
            </button>
        </>
      </div>
    </DashboardLayout>
  );
};
export default AddTask;

current use

import React, { useState, useEffect } from 'react';
import { Input, TimePicker, Select, notification, DatePicker} from 'antd';
import { Filter, SearchOutlined } from '@mui/icons-material';
import dayjs from 'dayjs';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { useMsal } from '@azure/msal-react';
import '../Styles/CreateUser.css';
import DashboardLayout from './Layout';
import '../Styles/AddTask.css';
import {Table} from 'antd';
import { ColumnsType } from "antd/es/table";
import { EditOutlined, DeleteOutlined,CloseCircleOutlined,LeftOutlined, RightOutlined } from '@ant-design/icons';
import Dashboard from './Dashboard';
export interface Task {
  date: string;
  userId: string;
  task: string;
  startTime: string;
  endTime: string;
  totalHours:string;
  description: string;
  reportingTo: string;
  slNo?: number;
  idx?:number;
}
interface AddTaskProps {
  setPieChartData: (data: { [key: string]: number }) => void;
}
const AddTask: React.FC<AddTaskProps> = ({ setPieChartData }) => {
  const [formWidth, setFormWidth] = useState(800);
  const [currentDate, setCurrentDate] = useState(dayjs());
  const [currentWeek, setCurrentWeek] = useState(dayjs().startOf('week'));
  const [currentMonth, setCurrentMonth] = useState(dayjs().startOf('month'));
  const [isFormEnabled, setIsFormEnabled] = useState(false);
  const [addTask, setAddTask] = useState<Task>({
    date: currentDate.format('YYYY-MM-DD'),
    userId: '1234',
    task: '',
    startTime: '',
    endTime: '',
    totalHours:'',
    description: '',
    reportingTo: '',
  });
  const [taskList, setTaskList] = useState<Task[]>([]);
  const [filteredTasks, setFilteredTasks] = useState<Task[]>([]);
  const reportingOptions = ['ManagerA', 'ManagerB', 'ManagerC'];
  const taskOptions = ['Task','Project','Learning','Training','Meeting'];
  const [filterOption, setFilterOption] = useState('Date');
  const [isEdited, setIsEdited]= useState<boolean>(false);
  // State to manage the search input
  const [searchInput, setSearchInput] = useState('');
  const [isFormSubmitted, setIsFormSubmitted] = useState(false);
 // console.log("currentdate", currentDate); 
  const updateSlNo = (tasks: Task[]): Task[] => {
    return tasks.map((task, index) => ({ ...task, slNo: index + 1 }));
  };
  useEffect(() => {
    const updateFormWidth = () => {
      const formElement = document.getElementById('myForm');
      if (formElement) {
        const newWidth = formElement.offsetWidth;
        setFormWidth(newWidth);
      }
    };

    window.addEventListener('resize', updateFormWidth);
    updateFormWidth();

    return () => {
      window.removeEventListener('resize', updateFormWidth);
    };
  }, []);

  const borderStyle = {
    border: '1px solid black',
    margin: '10px 20px',
    paddingRight: '0',
    width: formWidth + 'px',
  };

  // const handleInputChange = (field: keyof Task, value: string) => {
  //   if (field === 'date') {
  //     const selectedDate = dayjs(value);
  
  //     if (selectedDate.isAfter(dayjs(), 'day')) {
  //       // Display a notification
  //       notification.warning({
  //         message: 'Warning',
  //         description: 'Cannot select a future date.',
  //       });
  
  //       // Set the selected date to today
  //       setCurrentDate(dayjs());
  //     } else {
  //       // Update the state with the selected date
  //       setCurrentDate(selectedDate);
  //     }
  //   }  
  //   // Keep userId constant
  // if (field === 'userId') {
  //   setAddTask((prevTask) => ({ ...prevTask, [field]: value }));
  // } else {
  //   // Update startTime or endTime with the new value
  //   const updatedTime = value || dayjs().format('hh:mm A');
  //   setAddTask((prevTask) => ({ ...prevTask, [field]: updatedTime }));

  //   // Calculate the duration and update totalHours
  //   const updatedStartTime = field === 'startTime' ? updatedTime : addTask.startTime || dayjs().format('hh:mm A');
  //   const updatedEndTime = field === 'endTime' ? updatedTime : addTask.endTime || dayjs().format('hh:mm A');
  //   const duration = dayjs(updatedEndTime, 'hh:mm A').diff(dayjs(updatedStartTime, 'hh:mm A'), 'hour', true);

  //   console.log('updatedStartTime:', updatedStartTime);
  //   console.log('updatedEndTime:', updatedEndTime);
  //   console.log('duration:', duration);

  //   setAddTask((prevTask) => ({
  //     ...prevTask,
  //     totalHours: duration.toFixed(2), // Adjust decimal places as needed
  //   }));
  // }
  // };

  const handleInputChange = (field: keyof Task, value: string) => {
    if (field === 'date') {
      const selectedDate = dayjs(value);
  
      if (selectedDate.isAfter(dayjs(), 'day')) {
        // Display a notification
        notification.warning({
          message: 'Warning',
          description: 'Cannot select a future date.',
        });
  
        // Set the selected date to today
        setCurrentDate(dayjs());
      } else {
        // Update the state with the selected date
        setCurrentDate(selectedDate);
      }
    }
  
    // Keep userId constant
    if (field === 'userId') {
      setAddTask((prevTask) => ({ ...prevTask, [field]: value }));
    } else {
      // Update startTime or endTime with the new value
      const updatedTime = value || dayjs().format('hh:mm A');
      setAddTask((prevTask) => ({ ...prevTask, [field]: updatedTime }));
  
      // Calculate the duration and update totalHours
      const updatedStartTime = field === 'startTime' ? updatedTime : addTask.startTime || dayjs().format('hh:mm A');
      const updatedEndTime = field === 'endTime' ? updatedTime : addTask.endTime || dayjs().format('hh:mm A');
      const duration = dayjs(updatedEndTime, 'hh:mm A').diff(dayjs(updatedStartTime, 'hh:mm A'), 'hour', true);
  
      setAddTask((prevTask) => ({
        ...prevTask,
        startTime: field === 'startTime' ? updatedTime : addTask.startTime,
        endTime: field === 'endTime' ? updatedTime : addTask.endTime,
        totalHours: duration.toFixed(2),
      }));
    }
  };
  
  useEffect(() => {
    // Load taskList from localStorage on component mount
    const storedTaskListString = localStorage.getItem('taskList');
    const storedTaskList = storedTaskListString ? JSON.parse(storedTaskListString) : [];
    setTaskList(storedTaskList);
    setFilteredTasks(updateSlNo(storedTaskList)); // Update slNo when loading tasks
  }, []);

  useEffect(() => {
    // Filter tasks based on the addTask.date when it changes
    if (addTask.date) {
      const filtered = taskList.filter(task => task.date === addTask.date);
      setFilteredTasks(updateSlNo(filtered)); // Update slNo when loading tasks
    } else {
      // If no date is selected, display all tasks
      setFilteredTasks(updateSlNo(taskList)); // Update slNo when loading tasks
    }
  }, [addTask.date, taskList]);

  useEffect(() => {
    // Update addTask with the current date
    if (!isEdited) {
      // Update addTask with the current date only when not in edit mode
      setAddTask((prevAddTask) => ({
        ...prevAddTask,
        date: dayjs(currentDate).format('YYYY-MM-DD'),
    }));
  }
    //setFilteredTasks(taskList);
    // Filter tasks based on the filterOption and currentDate when they change
    let filtered: Task[] = [];

    if (searchInput) {
      // If there is a search input, filter tasks based on date or month
      const searchDate = dayjs(searchInput);
      filtered = taskList.filter((task) => {
        if (filterOption === 'Date') {
          return dayjs(task.date).isSame(searchDate, 'day');
        } else if (filterOption === 'Week') {
          const startOfWeek = currentWeek.startOf('week');
          const endOfWeek = currentWeek.endOf('week');
          return (
            (dayjs(task.date).isSame(startOfWeek) || dayjs(task.date).isAfter(startOfWeek)) &&
            (dayjs(task.date).isSame(endOfWeek) || dayjs(task.date).isBefore(endOfWeek))
          );
        } else if (filterOption === 'Month') {
          // Format the searchInput in the same way as the task date
          const formattedSearchMonth = searchDate.format('MMMM');
          return dayjs(task.date).format('MMMM') === formattedSearchMonth;
        }
        return false;
      });
    }  else {
      //setFilteredTasks(taskList);
      // If no search input, apply the regular filtering based on filterOption and currentDate
      if (filterOption === 'Date') {
        filtered = taskList.filter((task) => task.date === dayjs(currentDate).format('YYYY-MM-DD'));
        setFilteredTasks(updateSlNo(filtered)); // Update slNo when loading tasks
     //   console.log("useEffect-date", filtered)
      } else if (filterOption === 'Week') {
        const startOfWeek = currentWeek.startOf('week');
        const endOfWeek = currentWeek.endOf('week');
        filtered = taskList.filter(
          (task) =>
            (dayjs(task.date).isSame(startOfWeek) || dayjs(task.date).isAfter(startOfWeek)) &&
            (dayjs(task.date).isSame(endOfWeek) || dayjs(task.date).isBefore(endOfWeek))
        );
        setFilteredTasks(updateSlNo(filtered)); // Update slNo when loading tasks
        //console.log("useeffect-week", filtered);
      } else if (filterOption === 'Month') {
        const startOfMonth = currentMonth.startOf('month');
        const endOfMonth = currentMonth.endOf('month');
        filtered = taskList.filter(
          (task) =>
            (dayjs(task.date).isSame(startOfMonth) || dayjs(task.date).isAfter(startOfMonth)) &&
            (dayjs(task.date).isSame(endOfMonth) || dayjs(task.date).isBefore(endOfMonth))
        );
        setFilteredTasks(updateSlNo(filtered));
       // console.log("useeffect-month", filtered);
      }
    }

    setFilteredTasks(updateSlNo(filtered));
  //  console.log("useeffect filtered-task", filteredTasks);
  }, [isEdited, filterOption, currentDate, currentMonth, currentWeek, taskList, searchInput]);


  const handleFilterChange = (value: any) => {
    setFilterOption(value);
  };

  const handleLeftArrowClick = () => {
    if (filterOption === 'Date') {
      console.log("handleLeftArrowClick -prev", currentDate);
      const previousDate = currentDate.subtract(1, 'day');
      console.log("handleLeftArrowClick previousDate",previousDate)
      setCurrentDate(previousDate);

    } else if (filterOption === 'Week') {
      const previousWeekStart = currentWeek.subtract(1, 'week').startOf('week');
      const previousWeekEnd = currentWeek.subtract(1, 'week').endOf('week');
      setCurrentWeek(previousWeekStart);
      console.log("previousWeek",previousWeekStart)
    } else if (filterOption === 'Month') {
      const previousMonthStart = currentMonth.subtract(1, 'month').startOf('month');
      const previousMonthEnd = currentMonth.subtract(1, 'month').endOf('month');
      setCurrentMonth(previousMonthStart);
    }
  };

  const handleRightArrowClick = () => {
    if (filterOption === 'Date') {
      const nextDate = currentDate.add(1, 'day');
      if(nextDate.isAfter(dayjs(), 'day')){
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future weeks.',
        });
        return;
      }
      setCurrentDate(nextDate);
    } else if (filterOption === 'Week') {
      const nextWeekStart = currentWeek.add(1, 'week').startOf('week');
      const nextWeekEnd = currentWeek.add(1, 'week').endOf('week');
      if (nextWeekStart.isAfter(dayjs(), 'day')) {
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future weeks.',
        });
        return;
      }
      setCurrentWeek(nextWeekStart);
      console.log("previousWeek",nextWeekStart)
      
    } else if (filterOption === 'Month') {
      const nextMonthStart = currentMonth.add(1, 'month').startOf('month');
      if (nextMonthStart.isAfter(dayjs(), 'day')) {
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future months.',
        });
        return;
      }
      setCurrentMonth(nextMonthStart);
      console.log("nextMonthStart", nextMonthStart);
    }
    
  };

  const handleToggleForm = () => {
    setIsFormEnabled((prevIsFormEnabled) => !prevIsFormEnabled);
  
    // If you want to reset the form when disabling it, you can reset the form state here
    if (!isFormEnabled) {
      setAddTask({
        date: dayjs(currentDate).format('YYYY-MM-DD'),
        userId: '1234',
        task: '',
        startTime: '',
        endTime: '',
        totalHours:'',
        description: '',
        reportingTo: '',
      });
    }
  };

  
  const handleFormSubmit = () => {
    console.log("---fd1", dayjs(addTask.date).format('YYYY-MM-DD'), dayjs(addTask.startTime).format('hh:mm A'), dayjs(addTask.endTime).format('hh:mm A'));
    // Check for overlapping tasks in the specified time range
    const overlappingTask = taskList.find((task) => {
      const newTaskStartTime = dayjs(addTask.startTime, 'hh:mm A');
      const newTaskEndTime = dayjs(addTask.endTime, 'hh:mm A');
      const taskStartTime = dayjs(task.startTime, 'hh:mm A');
      const taskEndTime = dayjs(task.endTime, 'hh:mm A');
    
      // Check if the new task overlaps with any existing task
      return (
        !isEdited && task.date === addTask.date &&
        // ((newTaskStartTime.isSame(taskStartTime) && newTaskStartTime.isBefore(taskEndTime)) && newTaskEndTime.isSame(taskEndTime))
        (
          ((newTaskStartTime.isSame(taskStartTime) || newTaskStartTime.isAfter(taskStartTime))&& newTaskStartTime.isBefore(taskEndTime)) ||
          ((newTaskEndTime.isSame(taskStartTime) || newTaskEndTime.isAfter(taskStartTime))&& newTaskEndTime.isBefore(taskEndTime)) ||
          (newTaskStartTime.isBefore(taskStartTime) && (newTaskEndTime.isSame(taskEndTime)|| newTaskEndTime.isAfter(taskEndTime)))
        )
      );
    });
      
    if (overlappingTask) {
      notification.warning({
        message: 'Restricted',
        description: 'Task already exists in the specified time range.',
      });
      return;
    }

    if (isEdited) {
      // If editing, update the existing task
      console.log("---fd2", addTask.date, addTask.startTime, addTask.endTime);
      const updatedTaskList = taskList.map((task) => {
        //console.log('u--task.date:', task.date);
        // console.log('u--task.startTime:', task.startTime);
        // console.log('u--task.endTime:', task.endTime);
        // console.log('u--addTask.date:', addTask.date);
        // console.log('u--addTask.startTime:', addTask.startTime);
        // console.log('u--addTask.endTime:', addTask.endTime);
      
        return task.date === addTask.date && task.startTime === addTask.startTime && task.endTime===addTask.endTime
          ? { ...addTask, slNo: task.slNo }
          : task;
      });      
      setTaskList(updatedTaskList);
     // console.log('--upt', updatedTaskList);
      //setFilteredTasks(updatedTaskList);
      setFilteredTasks(updateSlNo(updatedTaskList)); // Update slNo when updating tasks
     // console.log('--upt', updatedTaskList)
      // Update localStorage
      localStorage.setItem('taskList', JSON.stringify(updatedTaskList));
      setIsEdited(false);
    } else{
      // Update the taskList
      const updatedTaskList = [...taskList, { ...addTask, slNo: taskList.length + 1 }];
      setTaskList(updatedTaskList);
      setFilteredTasks(updateSlNo(updatedTaskList)); // Update slNo when updating tasks
      // Update localStorage
      localStorage.setItem('taskList', JSON.stringify(updatedTaskList));

    }
    // Clear the form with the default date
    setAddTask({
      date: dayjs(currentDate).format('YYYY-MM-DD'),
      userId: '1234',
      task: '',
      startTime: '',
      endTime: '',
      totalHours:'',
      description: '',
      reportingTo: '',
    });
    //setIsEdited(false);
    setIsFormSubmitted(true);
  };


  const handleClearSubmit = () =>{
    // Clear the form with the default date
    setAddTask({
      date: dayjs(addTask.date).format('YYYY-MM-DD'),
      userId: '1234',
      task: '',
      startTime: '',
      endTime: '',
      totalHours:'',
      description: '',
      reportingTo: '',
    });
  }

  const handleEditTask = (date: string, startTime: string, endTime: string) => {
    // Implement the logic to edit the task based on date, startTime, and endTime
    // You can use the setAddTask function to update the form fields with the selected task's details
    // For example:
    setIsEdited(true);
    const taskToEdit = taskList.find(
      (task) => task.date === date && task.startTime === startTime && task.endTime === endTime
    );
    if (taskToEdit) {
      setAddTask({
        date: taskToEdit.date,
        userId: taskToEdit.userId,
        task: taskToEdit.task,
        startTime: taskToEdit.startTime,
        endTime: taskToEdit.endTime,
        totalHours: taskToEdit.totalHours,
        description: taskToEdit.description,
        reportingTo: taskToEdit.reportingTo,
      });

      // Now, you can perform additional actions or display a modal for editing
      setCurrentDate(dayjs(date));
    }
  };

  
  const handleDeleteTask = (date: string, startTime: string, endTime: string) => {
    // Implement the logic to delete the task based on date, startTime, and endTime
    // For example:
    const updatedTaskList = taskList.filter(
      (task) => !(task.date === date && task.startTime === startTime && task.endTime === endTime)
    );

    setTaskList(updatedTaskList);
    setFilteredTasks(updatedTaskList);

    // Update localStorage
    localStorage.setItem('taskList', JSON.stringify(updatedTaskList));

    // Additional actions after deletion
    // ...
  };


  const columns: ColumnsType<Task> = [
    {
      title: 'Sl.no',
      sorter: (a: Task, b: Task) => (a.slNo && b.slNo ? a.slNo - b.slNo : 0),
      dataIndex: 'slNo',
      key: 'slNo',
      fixed: 'left',
    },
    {
      title: 'Task',
      sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
      dataIndex: 'task',
      key: 'task',
      fixed: 'left',
    },
    {
      title: 'Date',
      sorter: (a: Task, b: Task) => a.date.localeCompare(b.date),
      dataIndex: 'date',
      key: 'date',
      fixed: 'left',
    },
    {
      title: 'Start Time',
      sorter: (a: Task, b: Task) => a.startTime.localeCompare(b.startTime),
      dataIndex: 'startTime',
      key: 'startTime',
      fixed: 'left',
    },
    {
      title: 'End Time',
      sorter: (a: Task, b: Task) => a.endTime.localeCompare(b.endTime),
      dataIndex: 'endTime',
      key: 'endTime',
      fixed: 'left',
    },
    {
      title: 'Total Hours',
      sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
      dataIndex: 'totalHours',
      key: 'totalHours',
      fixed: 'left',
    },
    {
      title: 'Description',
      sorter: (a: Task, b: Task) => a.description.localeCompare(b.description),
      dataIndex: 'description',
      key: 'description',
      fixed: 'left',
    },
    {
      title: 'Reporting To',
      sorter: (a: Task, b: Task) => a.reportingTo.localeCompare(b.reportingTo),
      dataIndex: 'reportingTo',
      key: 'reportingTo',
      fixed: 'left',
    },
    
    {
      title: 'Actions',
      dataIndex: 'actions',
      key: 'actions',
      render: (_, record, index) => (
        <div>
          <EditOutlined
            onClick={() => handleEditTask(record.date, record.startTime, record.endTime)}
            style={{
              marginRight: '8px',
              cursor: 'pointer',
              color: 'blue',
              fontSize: '20px',
            }}
            // style={{
            //   marginRight: '8px',
            //   cursor: selectedFilter === 'Month' || selectedFilter === 'Week' ? 'not-allowed' : 'pointer',
            //   color: selectedFilter === 'Month' || selectedFilter === 'Week' ? 'grey' : 'blue',
            //   fontSize: '20px',
            // }}
            // disabled={selectedFilter === 'Month' || selectedFilter === 'Week'}
          />
          <DeleteOutlined
            onClick={() => handleDeleteTask(record.date, record.startTime, record.endTime)}
             style={{
              cursor: 'pointer',
              color:  'red',
              fontSize: '20px',
            }}
            // style={{
            //   cursor: selectedFilter === 'Month' || selectedFilter === 'Week' ? 'not-allowed' : 'pointer',
            //   color: selectedFilter === 'Month' || selectedFilter === 'Week' ? 'grey' : 'red',
            //   fontSize: '20px',
            // }}
            // disabled={selectedFilter === 'Month' || selectedFilter === 'Week'}
          />
        </div>
    )}
  ]

  return (
    <DashboardLayout>
      <div className='createuser-main'>
        <div className='header'>
          <div>
            <h1>Add Task</h1>
          </div>
          { filterOption === 'Month' ? (
            <div style={{display:'flex', justifyContent:'flex-end'}}>
              <div className='date'>From: {dayjs(currentMonth).format('YYYY-MM-DD')}</div>
              <div className='date' style={{ marginLeft: '40px' }}>To: {dayjs(currentMonth).endOf('month').format('YYYY-MM-DD')}</div>
            </div>
            ) : filterOption === 'Week' ? (
              <div style={{display:'flex', justifyContent:'flex-end'}}>
                <div className='date'>From: {dayjs(currentWeek).format('YYYY-MM-DD')}</div>
                <div className='date' style={{ marginLeft: '40px' }}>To: {dayjs(currentWeek).endOf('week').format('YYYY-MM-DD')}</div>
              </div>
            )  : (
              <div className='date'>Date: {currentDate.format('YYYY-MM-DD')}</div>
            )
          }
        </div>
        {(filterOption === 'Date' || ((filterOption === 'Week' || filterOption === 'Month') && isEdited)) || isFormEnabled  ? ( <form id="myForm" style={borderStyle}>
            <div>
            {isFormEnabled && (
              <CloseCircleOutlined
                style={{ margin: '10px 20px', display: 'flex', justifyContent: 'flex-end', color: 'red' }}
                onClick={handleToggleForm} // Call the handleToggleForm function on click
              />
            )}
              <div className='section-addtask'>
              <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label htmlFor='addTaskID'>Date</label>
                  </div>
                  {/* <input
                    type="date"
                    style={{ width: '100%' }}
                    className='timepicker'
                  /> */}
                  <Input
                    type='date'
                    placeholder='Enter your Employee ID'
                    value={currentDate.format('YYYY-MM-DD')} 
                    onChange={(e) => handleInputChange('date', e.target.value)}
                  />

                </div>
                {/* <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label htmlFor='addTaskID'>User ID</label>
                  </div>
                  <Input
                    placeholder='Enter your Employee ID'
                    value={addTask.userId}
                    onChange={(e) => handleInputChange('userId', e.target.value)}
                    
                  />
                </div> */}
                 <div className='create-layout-addtask'>
                  <div>
                    <label htmlFor='task'>Task</label>
                  </div>
                  <div>
                    <select
                      id='task'
                      value={addTask.task}
                      onChange={(e) => handleInputChange('task', e.target.value)}
                    >
                      {taskOptions.map((option) => (
                          <option key={option} value={option}>
                            {option}
                          </option>
                        ))}
                    </select>
                  </div>
                </div>
              </div>
              <div className='section-addtask'>
                <div className='create-layout-addtask-left'>
                  <div>
                    <label htmlFor='startTime'>Start Time</label>
                  </div>
                  <TimePicker
                    value={
                      addTask.startTime
                        ? dayjs(addTask.startTime, 'hh:mm A') // Convert to dayjs here
                        : null
                    }
                    onChange={(time, timeString) =>
                      handleInputChange('startTime', timeString)
                    }
                    className='timepicker'
                    format='hh:mm A' // Set the format to include AM/PM
                  />
                </div>
                <div className='create-layout-addtask'>
                  <div>
                    <label htmlFor='endTime'>End Time</label>
                  </div>
                  <TimePicker
                    value={
                      addTask.endTime
                        ? dayjs(addTask.endTime, 'HH:mm A') // Convert to dayjs here
                        : null
                    }
                    onChange={(time, timeString) =>
                      handleInputChange('endTime', timeString)
                    }
                    className='timepicker'
                    format='hh:mm A'  // <-- Change this to 'hh:mm A'
                    rootClassName='timer'
                  />
                </div>
              </div>
              <div className='section-addtask'>
                
              <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label htmlFor='totalHours'>Total Hours</label>
                  </div>
                  <Input
                    placeholder='Enter your Total Hours'
                    value={addTask.totalHours}
                    onChange={(e) => handleInputChange('totalHours', e.target.value)}
                    
                  />
                </div>
                <div className='create-layout-addtask-reportingTo  '>
                  <div className='create-layout-reportingTo'>
                    <label htmlFor='reportingTo'>Reporting To</label>
                  </div>
                  <select
                    id='reportingTo-addtask'
                    value={addTask.reportingTo}
                    onChange={(e) => handleInputChange('reportingTo', e.target.value)}
                  >
                    <option value=''>Select Reporting To</option>
                    {reportingOptions.map((option) => (
                      <option key={option} value={option}>
                        {option}
                      </option>
                    ))}
                  </select>
                </div> 
              </div>  
              <div>
                <div className='create-layout-description'>
                  <div>
                    <label>Description</label>
                  </div>
                  <textarea
                    value={addTask.description}
                    onChange={(e) => handleInputChange('description', e.target.value)}
                    className='description-input'
                  />
                </div>
              </div>
            </div>
              
            
            <div className='button'>
              <button type='button' id='cancel-addtask' onClick={handleClearSubmit}>
                Clear
              </button>
              {isEdited ? (
              <button type='button' id='submit-addtask' onClick={handleFormSubmit}>
                Save
              </button>
            ):(
              <button type='button' id='submit-addtask' onClick={handleFormSubmit}>
                Add Task
              </button>
            )}
            </div>

        </form>):null}
        <>
        <div>
          <div style={{ display:'flex', justifyContent:'space-between', margin:'10px 20px' }}>
            <Input
            className="search-addtask"
            placeholder="Search by Date"
            allowClear
            suffix={<SearchOutlined style={{ color: "#04172480" }} />}
            onChange={(e) => {
            //  console.log("Search input value:", e.target.value);
              setSearchInput(e.target.value);
            }}
          />
         {/* <button id='cancel' onClick={handleToggleForm} hidden={filterOption === 'Date'}>{(isFormEnabled) ? 'Cancel' : 'Add Task'}</button> */}
         {!(filterOption === 'Date' && !isFormEnabled) && (
            <button
              id='cancel'
              onClick={handleToggleForm}
              disabled={isFormEnabled} // Disable the button when the form is enabled
            >
              Add Task
            </button>
          )}
          <div style={{display:'flex', justifyContent:'flex-end'}}>
          <button type='button' id='submit-less' onClick={handleLeftArrowClick}>
            <LeftOutlined />
          </button>

        {/* <Select
           
            style={{
              marginTop: '10px',
              display: 'flex',
              padding: '0.5em 2em',
              border: 'transparent',
              boxShadow: '2px 2px 4px rgba(0,0,0,0.4)',
              justifyContent: 'center',
              alignItems: 'center',
              gap: '10px',
              borderRadius: '4px',
              color:'white',
              background: '#0B4266',
              cursor: 'pointer',
              appearance: 'none',
              WebkitAppearance: 'none',
              MozAppearance: 'none',
            }}
            defaultValue="Date"
            onChange={handleFilterChange}
        >
          <Select.Option value="Date">Date</Select.Option>
          <Select.Option value="Week">Week</Select.Option>
          <Select.Option value="Month">Month</Select.Option>
        </Select> */}
          <select 
            id='submit' 
            style={{ appearance: 'none', WebkitAppearance: 'none', MozAppearance: 'none' }} 
            onChange={(e) => handleFilterChange(e.target.value)} value={filterOption}
          >
            <option style={{textAlign:'center'}} value='Day'>Day</option>
            <option style={{textAlign:'center'}} value='Week'>Week</option>
            <option style={{textAlign:'center'}} value='Month'>Month</option>
          </select>
          <button type='button' id='submit-less' onClick={handleRightArrowClick}>
            <RightOutlined />
          </button>
          </div>
        </div>
      </div>
        <Table
            columns={columns}
            dataSource={filteredTasks}
            //pagination={paginationOptions}
            pagination={false}
          />
            <button type='button' id='submit-overall'>
              Submit
            </button>
        </>
      </div>
    </DashboardLayout>
  );
};
export default AddTask;


//ApprovalRequests

import React,{useEffect, useState, useRef} from 'react'
import { ColumnsType } from 'antd/es/table'
import { EditOutlined, FolderViewOutlined} from '@ant-design/icons';
import { Progress } from 'antd';
import dayjs from 'dayjs';
import { v4 as uuidv4 } from 'uuid';
import '../Styles/ApprovalRequest.css';
import {
  Avatar,
  Space,
  Button,
  Table,
  Modal,
  Form,
  Input,
  Select,
  ConfigProvider,
  Tooltip,
  Tag,
  Popover,
  message,
  Checkbox,
  Pagination,
  Menu,
  Dropdown,
} from "antd";
import moment from "moment";
import { ExpandableConfig } from 'antd/lib/table/interface';
import 'moment/locale/en-in';
import {
  UserOutlined,
  DownOutlined,
  UpOutlined,
} from "@ant-design/icons";
import { useLocation } from 'react-router-dom';
import DashboardLayout from './Layout';
import { Task } from './AddTask';
import { groupBy } from 'lodash';

interface GroupedTasks {
  key: string;
  slNo?: number;
  month: string;
  tasks: { 
    [date: string]: {
      key: string;
      tasks: Task[]; 
    } 
  }; 
  daysFilled: number;
  totalDaysInMonth: number;
}

interface TaskWithColor extends Task {
  backgroundColor?: string;
}

const ApprovalRequest:React.FC = () => {
  //const [selectedRows, setSelectedRows] = useState<React.Key[]>([]);
  const [selectedRows, setSelectedRows] = useState<string[]>([]);
  const [selectedInnerRows, setSelectedInnerRows] = useState<string[]>([]);
  //const[daysInMonth, getDaysInMonth]=useState<string[]>([]);
  const [groupedTasks, setGroupedTasks] = useState<{ [key: string]: GroupedTasks }>({});
  // State declaration with two keys
  //const [groupedTasks, setGroupedTasks] = useState<{ [month: string]: { [date: string]: GroupedTasks } }>({});
  const [expandedRow, setExpandedRow] = useState<string | null>(null);
  const [expandedInnerRow, setExpandedInnerRow] = useState<string | null>(null);
  const location = useLocation();
  const requestData: Task[] = location.state?.requestData || [];
  const [modalVisible, setModalVisible] = useState<boolean>(false);
  const [modalContent, setModalContent] = useState<JSX.Element | null>(null);
  const [selectedUserId, setSelectedUserId] = useState<string | undefined>(undefined);
  const [selectedRowKey, setSelectedRowKey] = useState<string | null>(null);
  const [comments, setComments] = useState('');
  const [commentVisible, setCommentVisible] = useState(false);

  const hasFetchedData = useRef(false);

  useEffect(() => {
      if (!hasFetchedData.current) {
          handleGroupedTasks(requestData);
          hasFetchedData.current = true;
      }
  }, [requestData]);

  const handleReject = () => {
    setCommentVisible(true);
  };

  const handleCancel = () => {
    setCommentVisible(false);
  };

  const handleInputChange = (e:any) => {
    setComments(e.target.value);
  };

  const handleSubmit = () => {
    // Handle submission logic here
    console.log('Comments:', comments);
    setCommentVisible(false);
  };

  const handleApprove = () => {
    // Filter out the selected rows from the groupedTasks state
    const updatedGroupedTasks: { [key: string]: GroupedTasks } = { ...groupedTasks };
    console.log("handleApprove", updatedGroupedTasks);
    console.log("handleApprove innterRows", selectedInnerRows);
    // Iterate through selected rows
    selectedInnerRows.forEach(rowKey => {
      // Check if the rowKey exists in updatedGroupedTasks and if its tasks property is defined
      if (updatedGroupedTasks[rowKey]?.tasks) {
        const tasks = updatedGroupedTasks[rowKey].tasks;
        // Iterate through tasks for each date
        Object.values(tasks).forEach(dateTasks => {
          // Iterate through individual tasks
          dateTasks.tasks.forEach(task => {
            // Add a special CSS class or inline style to change the background color to green
            (task as Task & { backgroundColor?: string }).backgroundColor = 'green'; // Adjust this to your styling needs
          });
        });
        console.log("handleApprove tasks", tasks);
      }
    });

    // Update the selectedInnerRows array to remove approved rows
    setSelectedInnerRows(prevSelectedRows =>
      prevSelectedRows.filter(rowKey => !selectedInnerRows.includes(rowKey))
    );
  
    // Close the modal
    setModalVisible(false);
  
    // Update the state with the modified groupedTasks
    setGroupedTasks(updatedGroupedTasks);
  };
  
  function getDaysInMonth(month: number, year: number) {
    // month is 0-based in JavaScript
    return new Date(year, month + 1, 0).getDate();
  }

//    const handleGroupedTasks = (requestData: Task[]) => {
//     // Group tasks by month
//     const grouped = groupBy(requestData, (task: Task) => dayjs(task.date).format("YYYY-MM"));

//     // Retrieve existing data from local storage
//     const existingDataJSON = localStorage.getItem('groupedTasks');
//     const existingData: { [key: string]: GroupedTasks } = existingDataJSON ? JSON.parse(existingDataJSON) : {};

//     // Process each month's tasks
//     for (const monthKey in grouped) {
//         // Extract tasks array for the month
//         console.log("monthKey",monthKey);
//         const tasksArray = grouped[monthKey] as Task[];
//         console.log("tasksArray",tasksArray)
//         // Get the first task's date in the month
//         const firstTaskDate = dayjs(tasksArray[0].date, 'YYYY-MM-DD');
//         // Format the month as "MMMM YYYY"
//         const formattedMonth = firstTaskDate.format("MMMM YYYY");
//         // Get the total days in the month
//         const totalDaysInMonth = getDaysInMonth(firstTaskDate.month(), firstTaskDate.year());

//         // Initialize tasks object for the month
//         const tasks: { [key: string]: Task[] } = {};

//         // Calculate daysFilled
//         let daysFilled = 0;

//         // Iterate through tasks to populate tasks object and calculate daysFilled
//         tasksArray.forEach(task => {
//             const dateKey = dayjs(task.date, 'YYYY-MM-DD').format('YYYY-MM-DD');
//             if (!tasks[dateKey]) {
//                 tasks[dateKey] = [];
//                 daysFilled++;
//             }
//             tasks[dateKey].push(task);
//         });

//         // Update existing data for the month key
//         if (existingData.hasOwnProperty(monthKey)) {
//             // If month key exists, check if the date key exists
//             const monthData = existingData[monthKey];
//             for (const dateKey in tasks) {
//                 if (monthData.tasks.hasOwnProperty(dateKey)) {
//                     // If date key exists, replace tasks with new tasks
//                     monthData.tasks[dateKey] = tasks[dateKey];
//                 } else {
//                     // If date key does not exist, queue the upcoming state with key-value pair
//                     monthData.tasks[dateKey] = tasks[dateKey];
//                     daysFilled++;
//                 }
//             }
//             // Update month data
//             monthData.month = formattedMonth;
//             monthData.daysFilled = daysFilled;
//             monthData.totalDaysInMonth = totalDaysInMonth;
//         } else {
//             // If month key does not exist, add the new state with month
//             existingData[monthKey] = {
//                 month: formattedMonth,
//                 daysFilled,
//                 totalDaysInMonth,
//                 tasks
//             };
//         }
//     }

//     // Set the updated data to local storage
//     localStorage.setItem('groupedTasks', JSON.stringify(existingData));

//     // Update the state with the combined data
//     setGroupedTasks(existingData);
// };

const handleGroupedTasks = (requestData: Task[]) => {
  // Group tasks by month
  const grouped = groupBy(requestData, (task: Task) => dayjs(task.date).format("YYYY-MM"));

  // Retrieve existing data from local storage
  const existingDataJSON = localStorage.getItem('groupedTasks');
  const existingData: { [key: string]: GroupedTasks } = existingDataJSON ? JSON.parse(existingDataJSON) : {};

  // Process each month's tasks
  for (const monthKey in grouped) {
    // Extract tasks array for the month
    const tasksArray = grouped[monthKey] as Task[];

    // Get the first task's date in the month
    const firstTaskDate = dayjs(tasksArray[0].date, 'YYYY-MM-DD');
    // Format the month as "MMMM YYYY"
    const formattedMonth = firstTaskDate.format("MMMM YYYY");
    // Get the total days in the month
    const totalDaysInMonth = getDaysInMonth(firstTaskDate.month(), firstTaskDate.year());

    // Calculate daysFilled
    let daysFilled = 0;

    // Initialize tasks object for the month
    const tasks: { [key: string]: { key: string; tasks: Task[] } } = {};

    // Iterate through tasks to populate tasks object and calculate daysFilled
    tasksArray.forEach(task => {
      const dateKey = dayjs(task.date, 'YYYY-MM-DD').format('YYYY-MM-DD');
      if (!tasks[dateKey]) {
        const dateUUID = uuidv4(); // Generate unique key for the date
        tasks[dateKey] = { key: dateUUID, tasks: [] };
        daysFilled++;
      }
      tasks[dateKey].tasks.push(task);
    });

    // Generate unique key for the month
    const monthUUID = existingData.hasOwnProperty(monthKey) ? existingData[monthKey].key : uuidv4();

    // If the month already exists, merge new tasks with existing tasks
    if (existingData.hasOwnProperty(monthKey)) {
      const existingMonthData = existingData[monthKey];
      for (const dateKey in tasks) {
        if (!existingMonthData.tasks[dateKey]) {
          existingMonthData.tasks[dateKey] = tasks[dateKey];
          daysFilled++;
        } else {
          // Append new tasks to existing tasks
          existingMonthData.tasks[dateKey].tasks = existingMonthData.tasks[dateKey].tasks.concat(tasks[dateKey].tasks);
          // Update daysFilled if there are new tasks
          if (tasks[dateKey].tasks.length > 0) {
            daysFilled++;
          }
        }
      }
      existingMonthData.daysFilled = daysFilled;
      existingMonthData.totalDaysInMonth = totalDaysInMonth;
    } else {
      // If the month doesn't exist, create a new entry
      existingData[monthKey] = {
        key: monthUUID,
        month: formattedMonth,
        daysFilled,
        totalDaysInMonth,
        tasks
      };
    }
  }

  // Set the updated data to local storage
  localStorage.setItem('groupedTasks', JSON.stringify(existingData));

  // Update the state with the combined data
  setGroupedTasks(existingData);
};

// const handleRowSelection = (selectedRowKeys: React.Key[]) => {
//   console.log("handleRowSelection selectedRowKeys", selectedRowKeys); // Output selectedRowKeys to console
//   const selectedRowKeysString: string[] = [];
//   // Iterate over the keys of groupedTasks
//   for (const monthKey in groupedTasks) {
//     console.log("handleRowSelection monthKey", monthKey);
//     if (groupedTasks.hasOwnProperty(monthKey)) {
//       // Check if the month has selected tasks
//       const monthData = groupedTasks[monthKey];
//       console.log("handleRowSelection monthData", monthData);
//       if (selectedRowKeys.includes(monthKey)) { // Check if the key is included in selectedRowKeys
//         selectedRowKeysString.push(monthKey);
//       }
//     }
//   }
  
//   console.log("handleRowSelection selectedRowKeysString", selectedRowKeysString);
//   setSelectedRows(selectedRowKeysString);
// };


const handleRowSelection = (selectedRowKeys: React.Key[]) => {
  console.log("handleRowSelection selectedRowKeys", selectedRowKeys); // Output selectedRowKeys to console
  setSelectedRows(selectedRowKeys as string[]);
};

const handleInnerRowSelection = (selectedInnerRowKeys: React.Key[]) => {
  console.log("handleInnerRowSelection selectedInnerRowKeys", selectedInnerRowKeys); // Output selectedInnerRowKeys to console
  setSelectedInnerRows(selectedInnerRowKeys as string[]);
};


  const handleToggleRowExpand = (record: GroupedTasks, event: React.MouseEvent<HTMLElement>) => {
    // If the expanded row is the same as the clicked row, collapse it
    if (expandedRow === record.month) {
        setExpandedRow(null);
    } else {
        // Otherwise, expand the clicked row
        setExpandedRow(record.month);
    }

    // Prevent event propagation
    event.stopPropagation();
};

const handleToggleInnerRowExpand = (record: GroupedTasks, event: React.MouseEvent<HTMLElement>) => {
  if(expandedInnerRow===Object.keys(record.tasks)[0]){
    setExpandedInnerRow(null);
  }
  else{
    setExpandedInnerRow(Object.keys(record.tasks)[0]);
  }
  // const currentExpandedRow = expandedInnerRow === Object.keys(record.tasks)[0] ? '' : Object.keys(record.tasks)[0];
  // console.log("currentExpandedRow", currentExpandedRow);
  // setExpandedInnerRow(currentExpandedRow);
  event.stopPropagation();
};
   
    const rowClassName = (record: GroupedTasks, index: number) => {
      return index % 2 === 0 ? 'even-row' : 'odd-row';
    };

    const column: ColumnsType<GroupedTasks> = [
      {
        title: 'Select All',
        dataIndex: 'date',
        key: 'date',
        width: '20%',
        fixed: 'left',
        render: (_, record) => {
          // Assuming there is a specific key for the date in the tasks object
          const taskDate = Object.keys(record.tasks)[0]; // Assuming the date is the first key
          const formattedDate = moment(taskDate).format('YYYY-MM-DD');
          return formattedDate;
        },
      },
      {
        title: '',
        dataIndex: 'tasks',
        key: 'tasks',
        width: '60%',
        render: (_, record: GroupedTasks) => {
          // Initialize variables to store task hours and total hours
          let totalHours = 0;
          const taskHours: { [key: string]: number } = {};
      
          // Iterate over each date in the record
          Object.entries(record.tasks).forEach(([date, dateTasks]) => {
            // Iterate over tasks for each date
            dateTasks.tasks.forEach(task => {
              const totalHoursForTask = parseFloat(task.totalHours || '0');
              totalHours += totalHoursForTask; // Accumulate total hours
              taskHours[task.task] = (taskHours[task.task] || 0) + totalHoursForTask; // Add task hours
            });
          });
      
          // Calculate extra hours if total hours exceed 9
          const extraHours = totalHours > 9 ? totalHours - 9 : 0;
      
          return (
            <div>
              <ul style={{ display: 'flex', flexDirection: 'row', listStyle: 'none', padding: 0}}>
                {/* Render task hours for each task */}
                {Object.entries(taskHours).map(([taskName, taskTotalHours], index) => (
                  <li key={index} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', marginBottom: '5px' }}>
                    <div style={{ paddingRight: '20px' }}>
                      <div style={{ color: 'grey', paddingBottom: '5px' }}>
                        {taskName}
                      </div>
                      <div style={{ fontWeight: "bold", fontSize: '20px', color: 'black' }}>
                        {taskTotalHours}H
                      </div>
                    </div>
                    <div>
                      <Progress
                        type="circle"
                        percent={Math.round((taskTotalHours / 9) * 100)} // Ensure it's an integer
                        width={60}
                      />
                    </div>
                  </li>
                ))}
                {/* Render extra hours and total hours */}
                <li style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', marginBottom: '5px' }}>
                  <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                    Extra Hours
                  </div>
                  <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: "bold", fontSize: '20px' }}>
                    {extraHours}H
                  </div>
                </li>
                <li style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', marginBottom: '5px' }}>
                  <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                    Total Hours
                  </div>
                  <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: 'bold', fontSize: '20px' }}>
                    {totalHours}H
                  </div>
                </li>
              </ul>
            </div>
          );
        },
      },
      // {
      //   title: 'Actions',
      //   dataIndex: 'actions',
      //   key: 'actions',
      //   fixed: 'right',
      //   width: '20%',
      //   render: (_, record: GroupedTasks) => (
      //     <div>
      //       {/* Check if the record has tasks and expand based on that */}
      //       {record.tasks && Object.keys(record.tasks).length > 0 ? (
      //         expandedInnerRow === record.month ? (
      //           <UpOutlined
      //             style={{
      //               cursor: 'pointer',
      //               color: '#0B4266',
      //               fontSize: '16px',
      //             }}
      //             onClick={(event) => handleToggleInnerRowExpand(record, event)}
      //           />
      //         ) : (
      //           <DownOutlined
      //             style={{
      //               cursor: 'pointer',
      //               color: '#0B4266',
      //               fontSize: '16px',
      //             }}
      //             onClick={(event) => handleToggleInnerRowExpand(record, event)}
      //           />
      //         )
      //       ) : null}
      //     </div>
      //   ),
      // },
      {
        title: '',
        dataIndex: 'actions',
        key: 'actions',
        fixed: 'right',
        width: '20%',
        render: (_, record: GroupedTasks) => (
          <div>
            {/* Check if the record has tasks and expand based on that */}
            {record.tasks && Object.keys(record.tasks).length > 0 ? (
              expandedInnerRow === Object.keys(record.tasks)[0] ? (
                <UpOutlined
                  style={{
                    cursor: 'pointer',
                    color: '#0B4266',
                    fontSize: '16px',
                  }}
                  onClick={(event) => handleToggleInnerRowExpand(record, event)}
                />
              ) : (
                <DownOutlined
                  style={{
                    cursor: 'pointer',
                    color: '#0B4266',
                    fontSize: '16px',
                  }}
                  onClick={(event) => handleToggleInnerRowExpand(record, event)}
                />
              )
            ) : null}
          </div>
        ),
      },      
      
    ];
    
    // const innerColumn: ColumnsType<GroupedTasks> = [
    //   {
    //     title: 'Sl.no',
    //     sorter: (a: GroupedTasks, b: GroupedTasks) => (a.slNo && b.slNo ? a.slNo - b.slNo : 0),
    //     dataIndex: 'slNo',
    //     key: 'slNo',
    //     fixed: 'left',
    //   },
    //   {
    //     title: 'Task',
    //     sorter: (a: GroupedTasks, b: GroupedTasks) => {
    //       const aTasks = Object.values(a.tasks).flat(); // Flattening the array of tasks for group 'a'
    //       const bTasks = Object.values(b.tasks).flat(); // Flattening the array of tasks for group 'b'
    
    //       // Assuming task objects have a 'name' property for comparison
    //       const aTaskNames = aTasks.map(task => task.task).join('');
    //       const bTaskNames = bTasks.map(task => task.task).join('');
    
    //       return aTaskNames.localeCompare(bTaskNames);
    //     },
    //     dataIndex: 'task',
    //     key: 'task',
    //     fixed: 'left',
    //   },
    //   {
    //     title: 'Start Time',
    //     sorter: (a: GroupedTasks, b: GroupedTasks) => {
    //       const aTasks = Object.values(a.tasks).flat(); // Flattening the array of tasks for group 'a'
    //       const bTasks = Object.values(b.tasks).flat(); // Flattening the array of tasks for group 'b'
    
    //       // Assuming task objects have a 'name' property for comparison
    //       const aTaskNames = aTasks.map(task => task.startTime).join('');
    //       const bTaskNames = bTasks.map(task => task.startTime).join('');
    
    //       return aTaskNames.localeCompare(bTaskNames);
    //     },
    //     dataIndex: 'startTime',
    //     key: 'startTime',
    //     fixed: 'left',
    //   },
    //   {
    //     title: 'End Time',
    //     sorter: (a: GroupedTasks, b: GroupedTasks) => {
    //       const aTasks = Object.values(a.tasks).flat(); // Flattening the array of tasks for group 'a'
    //       const bTasks = Object.values(b.tasks).flat(); // Flattening the array of tasks for group 'b'
    
    //       // Assuming task objects have a 'name' property for comparison
    //       const aTaskNames = aTasks.map(task => task.endTime).join('');
    //       const bTaskNames = bTasks.map(task => task.endTime).join('');
    
    //       return aTaskNames.localeCompare(bTaskNames);
    //     },
    //     dataIndex: 'endTime',
    //     key: 'endTime',
    //     fixed: 'left',
    //   },
    //   {
    //     title: 'Total Hours',
    //     sorter: (a: GroupedTasks, b: GroupedTasks) => {
    //       const aTasks = Object.values(a.tasks).flat(); // Flattening the array of tasks for group 'a'
    //       const bTasks = Object.values(b.tasks).flat(); // Flattening the array of tasks for group 'b'
    
    //       // Assuming task objects have a 'name' property for comparison
    //       const aTaskNames = aTasks.map(task => task.totalHours).join('');
    //       const bTaskNames = bTasks.map(task => task.totalHours).join('');
    
    //       return aTaskNames.localeCompare(bTaskNames);
    //     },
    //     dataIndex: 'totalHours',
    //     key: 'totalHours',
    //     fixed: 'left',
    //   },
    //   {
    //     title: 'Description',
    //     sorter: (a: GroupedTasks, b: GroupedTasks) => {
    //       const aTasks = Object.values(a.tasks).flat(); // Flattening the array of tasks for group 'a'
    //       const bTasks = Object.values(b.tasks).flat(); // Flattening the array of tasks for group 'b'
    
    //       // Assuming task objects have a 'name' property for comparison
    //       const aTaskNames = aTasks.map(task => task.description).join('');
    //       const bTaskNames = bTasks.map(task => task.description).join('');
    
    //       return aTaskNames.localeCompare(bTaskNames);
    //     },
    //     dataIndex: 'description',
    //     key: 'description',
    //     fixed: 'left',
    //   },
    //   // Implementing tasks object from GroupedTasks interface
    //   {
    //     title: 'Date',
    //     render: (text: string, record: GroupedTasks) => {
    //       const { month, tasks } = record;
    //       const taskDates = Object.keys(tasks);
    //       const taskDate = taskDates.length > 0 ? taskDates[0] : '';
    //       return taskDate;
    //     },
    //   },
    // ];
    
    const innerColumn: ColumnsType<Task> = [
      {
        title: 'Sl.no',
        sorter: (a: Task, b: Task) => (a.slNo && b.slNo ? a.slNo - b.slNo : 0),
        dataIndex: 'slNo',
        key: 'slNo',
        fixed: 'left',
      },
      {
        title: 'Task',
        sorter: (a: Task, b: Task) => {
          return a.task.localeCompare(b.task);
        },
        dataIndex: 'task',
        key: 'task',
        fixed: 'left',
      },
      {
        title: 'Start Time',
        sorter: (a: Task, b: Task) => {
          return a.startTime.localeCompare(b.startTime);
        },
        dataIndex: 'startTime',
        key: 'startTime',
        fixed: 'left',
      },
      {
        title: 'End Time',
        sorter: (a: Task, b: Task) => {
          return a.endTime.localeCompare(b.endTime);
        },
        dataIndex: 'endTime',
        key: 'endTime',
        fixed: 'left',
      },
      {
        title: 'Total Hours',
        sorter: (a: Task, b: Task) => {
          return a.totalHours.localeCompare(b.totalHours);
        },
        dataIndex: 'totalHours',
        key: 'totalHours',
        fixed: 'left',
      },
      {
        title: 'Description',
        sorter: (a: Task, b: Task) => {
          return a.description.localeCompare(b.description);
        },
        dataIndex: 'description',
        key: 'description',
        fixed: 'left',
      },
      // Other columns as needed
    ];
    
    const columns: ColumnsType<GroupedTasks> = [
      {
        title: 'Sl.no',
        sorter: (a, b) => (a.slNo && b.slNo ? a.slNo - b.slNo : 0),
        className: 'ant-table-column-title',
        dataIndex: 'slNo',
        key: 'slNo',
        fixed: 'left',
        render: (slNo) => slNo ? <span>{slNo}</span> : 0,
      },      
      {
        title: "Employee",
        className: ' ant-table-column-title',
        dataIndex: "tasks",
        render: (tasks: { [date: string]: { key: string; tasks: Task[] } }) => {
          const userId = tasks[Object.keys(tasks)[0]].tasks[0]?.userId || '';
          return (
            <Space className="flex gap-5">
              <Avatar icon={<UserOutlined />} size={45} />
              <div>
                <div>
                  <strong>Sasi Kumar</strong>
                </div>
                <div>{userId}</div>
              </div>
            </Space>
          );
        },
        sorter: (a: GroupedTasks, b: GroupedTasks) => {
          const userIdA = a.tasks[Object.keys(a.tasks)[0]].tasks[0]?.userId || '';
          const userIdB = b.tasks[Object.keys(b.tasks)[0]].tasks[0]?.userId || '';
          return userIdA.localeCompare(userIdB);
        },
      },          
      {
        title: 'Month',
        sorter: (a, b) => a.month.localeCompare(b.month),
        className: 'ant-table-column-title',
        dataIndex: 'month',
        key: 'month',
        fixed: 'left',
      },
      // {
      //   title: 'Requested On',
      //   sorter: (a, b) => dayjs(Object.keys(a.tasks)[0]).unix() - dayjs(Object.keys(b.tasks)[0]).unix(),
      //   className: 'ant-table-column-title',
      //   dataIndex: 'date',
      //   key: 'date',
      //   fixed: 'left',
      //   render: (_, record) => {
      //     const formattedDate = moment(Object.keys(record.tasks)[0]).format('YYYY-MM-DD');
      //     return formattedDate;
      //   },
      // },  
      {
        title: 'Requested On',
        className: 'ant-table-column-title',
        dataIndex: 'tasks',
        key: 'date',
        fixed: 'left',
        render: (tasks: { [date: string]: Task[] }) => {
          const dates = Object.keys(tasks);
          const earliestDate = dates.length > 0 ? dates.sort()[0] : null;
          const formattedDate = earliestDate ? moment(earliestDate).format('YYYY-MM-DD') : '';
          return formattedDate;
        },
      },        
      {
        title: 'Days Filled',
        className: 'ant-table-column-title',
        dataIndex: 'daysFilled',
        key: 'daysFilled',
        render: (daysFilled, record) => {
          const dateKeysFilled = Object.keys(record.tasks).length;
          return (
            <span>{`${dateKeysFilled} / ${record.totalDaysInMonth}`}</span>
          );
        },
        sorter: (a: GroupedTasks, b: GroupedTasks) => Object.keys(a.tasks).length - Object.keys(b.tasks).length,
      },    
      {
        title: ' ',
        dataIndex: 'actions',
        key: 'actions',
        render: (_, record, index) => (
          <div>
            {expandedRow === record.month ? (
              <UpOutlined
                style={{
                  cursor: 'pointer',
                  color: '#0B4266',
                  fontSize: '16px',
                }}
                onClick={(event) => handleToggleRowExpand(record, event)}
              />            
            ) : (
              <DownOutlined
                style={{
                  cursor: 'pointer',
                  color: '#0B4266',
                  fontSize: '16px',
                }}
                onClick={(event) => handleToggleRowExpand(record, event)}
              />
            )}
          </div>
        )
      }
    ];
  
    const expandable: ExpandableConfig<GroupedTasks> = {
      expandedRowRender: (record: GroupedTasks) => {
        const taskHours: { [key: string]: number } = {};
        for (const dateKey in record.tasks) {
          record.tasks[dateKey].tasks.forEach(task => {
            if (taskHours.hasOwnProperty(task.task)) {
              taskHours[task.task] += parseFloat(task.totalHours || '0');
            } else {
              taskHours[task.task] = parseFloat(task.totalHours || '0');
            }
          });
        }
        
        // After calculating the total hours for each task, convert them to fixed decimals
        for (const taskName in taskHours) {
          if (taskHours.hasOwnProperty(taskName)) {
            taskHours[taskName] = parseFloat(taskHours[taskName].toFixed(2));
          }
        }
        
        const totalHours = Math.floor(Object.values(taskHours).reduce((acc, curr) => acc + curr, 0));
        const regularHours = Math.min(totalHours, 9);
        const extraHours = totalHours - regularHours;
    
        if (expandedRow === record.month) {
          return (
            <div>
              <ul style={{ display: 'flex', justifyContent: 'space-around', listStyle: 'none' }}>
                {Object.entries(taskHours).map(([taskName, taskTotalHours], index) => (
                  <div key={index} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
                    <div style={{ paddingRight: '20px' }}>
                      <div style={{ color: 'grey', paddingBottom: '5px' }}>
                        {taskName}
                      </div>
                      <div style={{ fontWeight: "bold", fontSize: '20px', color: 'black' }}>
                        {taskTotalHours}H
                      </div>
                    </div>
                    <div>
                      <Progress
                        type="circle"
                        percent={Math.round((taskTotalHours / 9) * 100)} // Ensure it's an integer
                        width={60}
                      />
                    </div>
                  </div>
                ))}
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
                  <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                    Extra Hours
                  </div>
                  <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: "bold", fontSize: '20px' }}>
                    {extraHours}H
                  </div>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
                  <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                    Total Hours
                  </div>
                  <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: 'bold', fontSize: '20px' }}>
                    {totalHours}H
                  </div>
                </div>
    
    
              </ul>
            </div>
          );
        }
        return null;
      },
      expandRowByClick: true,
      expandIcon: () => null
    };
    
    
    const aggregatedData: GroupedTasks[] = Object.keys(groupedTasks).map((monthKey: string) => {
      console.log("monthKey---", monthKey);
      const monthData = groupedTasks[monthKey];
      const monthTasks: { [date: string]: { key: string; tasks: Task[] } } = {};
      let daysFilled = 0;
      for (const dateKey in monthData.tasks) {
        if (Object.keys(monthData.tasks[dateKey].tasks).length > 0) {
          monthTasks[dateKey] = monthData.tasks[dateKey];
          daysFilled++;
        }
      }
      const totalDaysInMonth = monthData.totalDaysInMonth;
      return {
        key: monthData.key,
        month: monthData.month,
        tasks: monthTasks,
        daysFilled: daysFilled,
        totalDaysInMonth: totalDaysInMonth
      };
    });
    

    const flattenedData = (groupedTasks: { [key: string]: GroupedTasks }, monthKey: string): GroupedTasks[]=> {
      const tasks: GroupedTasks[] = [];
      
      // Find the monthData corresponding to the given monthKey
      const monthData = groupedTasks[monthKey];
      if (monthData) {
        // Iterate over each date in the monthData tasks
        for (const dateKey in monthData.tasks) {
          tasks.push({
            key: monthData.key,
            month: monthData.month,
            daysFilled: monthData.daysFilled,
            totalDaysInMonth: monthData.totalDaysInMonth,
            tasks: { [dateKey]: monthData.tasks[dateKey] } // Wrap tasks in an object with the dateKey as the key
          });
        }
      }
      
      return tasks;
    }
    
    const handleRowClick = (record: GroupedTasks, event: React.MouseEvent<HTMLElement>) => {
      // Access userId from the first task object in the record
      const userId = record.tasks[Object.keys(record.tasks)[0]].tasks[0]?.userId;
      setSelectedUserId(userId); // Set the userId in state
      
      // Extract tasks data from the record
      const monthYear = record.month;
      const [monthName, year] = monthYear.split(' ');
      
      // Convert month name to month number
      const monthNumber = moment().month(monthName).format("MM");
      
      // Format month and year in "YYYY-MM" format
      const formattedMonth = `${year}-${monthNumber}`;
      console.log("formattedMonth", monthYear, formattedMonth);
      const tasksForClickedMonth: GroupedTasks[] = flattenedData(groupedTasks, formattedMonth);
    
      setModalContent(
        <div>
          <Table
            rowSelection={{
              type: 'checkbox',
              selectedRowKeys: selectedInnerRows,
              onChange: handleInnerRowSelection,
              getCheckboxProps: (record) => {
                  // Initialize key to undefined
                  let key: string | undefined;
                  // Iterate over the tasks object to find the first available key
                  for (const dateKey in record) {
                      const dateTasks = record.tasks[dateKey];
                      if (dateTasks && dateTasks.tasks && dateTasks.tasks.length > 0) {
                          // Use the key of the tasks object for row selection
                          key = dateTasks.key;
                          break; // Stop iterating after finding the first key
                      }
                  }
                  return {
                      key: key,
                      disabled: false, // You can adjust these additional props as needed
                  };
              },            
            }}                     
            style={{ backgroundColor: 'white', border: '1px solid grey', borderRadius: '5px' }}
            columns={column}
            rowClassName="rowstyle"
            dataSource={tasksForClickedMonth}
            pagination={false}
            expandable={{
              expandedRowRender: (record: GroupedTasks) => {
                // Check if record is defined and not null
                if (record) {
                  // Check if record.tasks is defined and not null, and is an object
                  if (record.tasks && typeof record.tasks === 'object') {
                    const taskDates = Object.keys(record.tasks);
                    const taskDate = taskDates.length > 0 ? taskDates[0] : '';
                    const tasksForFirstDate = record.tasks[taskDate].tasks;
                    console.log("tasksForFirstDate", tasksForFirstDate);
            
                    return (
                      <Table
                        columns={innerColumn as ColumnsType<Task>}
                        dataSource={tasksForFirstDate}
                        pagination={false}
                      />
                    );
                  } else {
                    // Handle the case where record.tasks is undefined or null, or not an object
                    return null; // or any fallback content
                  }
                } else {
                  // Handle the case where record is undefined or null
                  return null; // or any fallback content
                }
              },            
              expandRowByClick: true,
              expandIcon: () => null
            }}
          />
        </div>
      );
      setModalVisible(true);
      // Prevent event propagation
      event.stopPropagation();
    };
    
  return (
    <DashboardLayout>
      <div>
        <Table
           rowSelection={{
            type: 'checkbox',
            // selectedRowKeys: selectedRows,
            // onChange: handleRowSelection,
            // getCheckboxProps: (record: GroupedTasks) => ({
            //   // Use the `key` field as the identifier for row selection
            //   key: record.key,
            //   disabled: false, // You can adjust these additional props as needed
            //   // Add any other properties expected by CheckboxProps here
            // }),
          }}   
          onRow={(record: GroupedTasks) => ({
            onClick: (event: React.MouseEvent<HTMLElement>) =>
              handleRowClick(record, event),
          })}
          style={{ backgroundColor: 'white' }}
          columns={columns}
          dataSource={aggregatedData}
          pagination={false}
          expandable={expandable}
        />
      </div>
      <Modal
        title={
          modalContent ? (
            <div>
              <Space className="flex gap-5">
                <Avatar icon={<UserOutlined />} size={45} />
                <div>
                  <div>
                    <strong>Sasi Kumar</strong>
                  </div>
                  {/* Displaying the userId */}
                  <div>{selectedUserId}</div>
                </div>
              </Space>
            </div>
          ) : null
        }
        visible={modalVisible}
        onCancel={() => setModalVisible(false)}
        footer={null}
        width="80%"
      >
        {modalContent}
        <div style={{display:'flex', justifyContent:'flex-end', margin:"10px 20px"}}>
          <Button style={{width:'10%', backgroundColor:'green', color:'white'}} onClick={handleApprove}>Approve</Button>
          <Button style={{ width: '10%', backgroundColor: 'red', color: 'white' }} onClick={handleReject}>
            Reject
          </Button>
          <Modal
            title="Comments"
            className='modalTitle'
            visible={commentVisible}
            onCancel={handleCancel}
            footer={[
              // <Button key="cancel" onClick={handleCancel}>
              //   Cancel
              // </Button>,
              <Button style={{ width: '20%', backgroundColor: '#0B4266', color: 'white' }} key="submit" type="primary" onClick={handleSubmit}>
                Submit
              </Button>,
            ]}
          >
            <Input.TextArea placeholder='Write here...' rows={4} value={comments} onChange={handleInputChange} />
          </Modal>
        </div>
      </Modal>
    </DashboardLayout>
  );
}

export default ApprovalRequest

code 2:
import React,{useEffect, useState, useRef} from 'react'
import { ColumnsType } from 'antd/es/table'
import { EditOutlined, FolderViewOutlined} from '@ant-design/icons';
import { Progress } from 'antd';
import dayjs from 'dayjs';
import { v4 as uuidv4 } from 'uuid';
import '../Styles/ApprovalRequest.css';
import {
  Avatar,
  Space,
  Button,
  Table,
  Modal,
  Form,
  Input,
  Select,
  ConfigProvider,
  Tooltip,
  Tag,
  Popover,
  message,
  Checkbox,
  Pagination,
  Menu,
  Dropdown,
} from "antd";
import moment from "moment";
import { ExpandableConfig } from 'antd/lib/table/interface';
import 'moment/locale/en-in';
import {
  UserOutlined,
  DownOutlined,
  UpOutlined,
} from "@ant-design/icons";
import { useLocation } from 'react-router-dom';
import DashboardLayout from './Layout';
import { Task } from './AddTask';
import { groupBy } from 'lodash';
import { ConstructionOutlined } from '@mui/icons-material';
import { TableRowSelection } from 'antd/lib/table/interface';

// Define the type for RowSelectMethod
type RowSelectMethod = 'checkbox' | 'radio';

// interface GroupedTasks {
//   key: string;
//   slNo?: number;
//   month: string;
//   tasks: { 
//     [date: string]: {
//       key: string;
//       tasks: Task[]; 
//     } 
//   }; 
//   daysFilled: number;
//   totalDaysInMonth: number;
// }

export interface TaskObject {
  [date: string]: {
    key: string;
    tasks: Task[]; 
  };
}

interface GroupedTasks {
  key: string;
  slNo?: number;
  month: string;
  tasks: TaskObject;
  daysFilled: number;
  totalDaysInMonth: number;
}

const ApprovalRequest:React.FC= () => { 
  const [forceUpdate, setForceUpdate] = useState(false);

  //const [selectedRows, setSelectedRows] = useState<React.Key[]>([]);
  const [selectedRows, setSelectedRows] = useState<string[]>([]);
  const [selectedInnerRows, setSelectedInnerRows] = useState<string[]>([]);
  //const[daysInMonth, getDaysInMonth]=useState<string[]>([]);
  const [groupedTasks, setGroupedTasks] = useState<{ [key: string]: GroupedTasks }>({});
  // State declaration with two keys
  //const [groupedTasks, setGroupedTasks] = useState<{ [month: string]: { [date: string]: GroupedTasks } }>({});
  const [expandedRow, setExpandedRow] = useState<string | null>(null);
  const [expandedInnerRow, setExpandedInnerRow] = useState<string | null>(null);
  const [modalVisible, setModalVisible] = useState<boolean>(false);
  const [modalContent, setModalContent] = useState<JSX.Element | null>(null);
  const [selectedUserId, setSelectedUserId] = useState<string | undefined>(undefined);
  const [comments, setComments] = useState('');
  const [commentVisible, setCommentVisible] = useState(false);
  const [approvalRequests, setApprovalRequests] = useState<Task[]>([]);
  const [monthTasks, setMonthTasks] = useState<TaskObject[]>([]);
  useEffect(() => {
    // Retrieve approvalRequestsData from local storage
    const storedData = localStorage.getItem('approvalRequestsData');
    if (storedData) {
        const approvalRequestsData = JSON.parse(storedData);
        setApprovalRequests(approvalRequestsData); // Update the state with fetched data
    }
  }, []); // Fetch data only once on component mount

  useEffect(() => {
      if (approvalRequests.length > 0) { // Check if approvalRequests has data
          // Process approvalRequests data
          handleGroupedTasks(approvalRequests);
      }
  }, [approvalRequests]);

  useEffect(()=>{
    console.log("useeffect monthtasks", monthTasks);
  },[monthTasks])

  const handleReject = () => {
    setCommentVisible(true);
  };

  const handleCancel = () => {
    setCommentVisible(false);
  };

  const handleInputChange = (e:any) => {
    setComments(e.target.value);
  };

  const handleSubmit = () => {
    // Handle submission logic here
    console.log('Comments:', comments);
    setCommentVisible(false);
  };

  const handleApprove = () => {
    // Filter out the selected row from the groupedTasks state
    const updatedGroupedTasks = { ...groupedTasks };
    console.log("handleApprove", updatedGroupedTasks);
    // Iterate through selected rows
    selectedInnerRows.forEach(rowKey => {
        // Check if the rowKey exists in updatedGroupedTasks and if its tasks property is defined
        if (updatedGroupedTasks[rowKey]?.tasks) {
            const tasks = updatedGroupedTasks[rowKey].tasks;
            // Iterate through tasks for each date
            Object.values(tasks).forEach(dateTasks => {
                // Iterate through individual tasks
                dateTasks.tasks.forEach(task => {
                    // Add a special CSS class or inline style to change the background color to green
                    (task as Task & { backgroundColor?: string }).backgroundColor = 'green'; // Adjust this to your styling needs
                });
            });
        }
    });
    console.log("updatedGroupedTaks", updatedGroupedTasks);
    // Update the selectedInnerRows array to remove the approved row
    setSelectedInnerRows([]);

    // Close the modal
    setModalVisible(false);

    // Update the state with the modified groupedTasks
    setGroupedTasks(updatedGroupedTasks);
};

  
  function getDaysInMonth(month: number, year: number) {
    // month is 0-based in JavaScript
    return new Date(year, month + 1, 0).getDate();
  }

  const handleGroupedTasks = (requestData: Task[]) => {
    // Group tasks by month
    const grouped = groupBy(requestData, (task: Task) => dayjs(task.date).format("YYYY-MM"));
  
    // Retrieve existing data from local storage
    const existingDataJSON = localStorage.getItem('groupedTasks');
    const existingData: { [key: string]: GroupedTasks } = existingDataJSON ? JSON.parse(existingDataJSON) : {};
  
    // Process each month's tasks
    for (const monthKey in grouped) {
      const tasksArray = grouped[monthKey] as Task[];
  
      const firstTaskDate = dayjs(tasksArray[0].date, 'YYYY-MM-DD');
      const formattedMonth = firstTaskDate.format("MMMM YYYY");
      const totalDaysInMonth = getDaysInMonth(firstTaskDate.month(), firstTaskDate.year());
  
      let daysFilled = 0;
      const tasks: { [key: string]: { key: string; tasks: Task[] } } = {};
  
      tasksArray.forEach(task => {
        const dateKey = dayjs(task.date, 'YYYY-MM-DD').format('YYYY-MM-DD');
        if (existingData.hasOwnProperty(monthKey)) {
          if (!existingData[monthKey].tasks.hasOwnProperty(dateKey)) {
            existingData[monthKey].tasks[dateKey] = { key: uuidv4(), tasks: [task] };
            daysFilled++;
          } else {
            existingData[monthKey].tasks[dateKey].tasks = [task]; // Replace existing tasks with new task
          }
        } else {
          const dateUUID = uuidv4(); // Generate unique key for the date
          tasks[dateKey] = { key: dateUUID, tasks: [task] };
          daysFilled++;
        }
      });
  
      if (!existingData.hasOwnProperty(monthKey)) {
        const monthUUID = uuidv4(); // Generate unique key for the month
        existingData[monthKey] = {
          key: monthUUID,
          month: formattedMonth,
          daysFilled,
          totalDaysInMonth,
          tasks
        };
      } else {
        existingData[monthKey].daysFilled = daysFilled; // Update daysFilled
      }
    }
  
    // Set the updated data to local storage
    localStorage.setItem('groupedTasks', JSON.stringify(existingData));
  
    // Update the state with the combined data
    setGroupedTasks(existingData);
  };
  
  const handleRowSelection = (selectedRowKeys: React.Key[]) => {
    console.log("handleRowSelection selectedRowKeys", selectedRowKeys); // Output selectedRowKeys to console
    setSelectedRows(selectedRowKeys as string[]);
  };

//   const handleInnerRowSelection = (selectedInnerRowKeys: React.Key[]) => {
//     setSelectedInnerRows((prevSelectedInnerRows) => {
//         console.log("Previous selectedInnerRows", prevSelectedInnerRows);
//         console.log("New selectedInnerRowKeys", selectedInnerRowKeys);
//         return selectedInnerRowKeys as string[];
//     });
//     console.log("selectedInnerRows", selectedInnerRows);
// };

// const handleInnerRowSelection = (selectedRowKeys: React.Key[]) => {
//   // console.log("handleInnerRowSelection", key);
//   const selectedkey=selectedRowKeys.map((key)=>key.toString());
//   setSelectedInnerRows(selectedkey);
//   // setSelectedInnerRows(key as string[]);
//   // setForceUpdate(prev => !prev); // Toggle forceUpdate
// console.log(selectedInnerRows);
// };

// const handleInnerRowSelection = (selectedRowKeys: TaskObject[]) => {
//   if (!Array.isArray(selectedRowKeys)) {
//     // Handle unexpected data type
//     return;
//   }
//   const selectedKeys = selectedRowKeys.filter(key => typeof key === 'string').map(key => key.toString());
//   setSelectedInnerRows(selectedKeys);
// };


const handleInnerRowSelection = (     
  selectedRowKeys: React.Key[],
  selectedRows: TaskObject[],
  tasksForClickedMonth: TaskObject[]
) => {
  // Extracting keys from the tasksForClickedMonth array
  const taskKeys = tasksForClickedMonth.flatMap(task => Object.keys(task));
  
  console.log("taskkeys",taskKeys);
  setSelectedInnerRows(taskKeys as string[]); // Assuming selectedRowKeys are string keys
  console.log("handleInnerRowSelection tasksForClickedMonth", tasksForClickedMonth);
};

const rowSelection = {
  onChange: (selectedRowKeys: React.Key[], selectedRows: TaskObject[]) => {
    console.log('selectedRowKeys', selectedRowKeys, 'selectedRows: ', selectedRows);
    setSelectedInnerRows(selectedRowKeys as string[]);
    console.log(selectedInnerRows);
  },
  getCheckboxProps: (record: TaskObject) => ({
    disabled: false, // Column configuration not to be checked
    key: record.key,
  }),
};




useEffect(() => {
  console.log("selectedInnerRows", selectedInnerRows);
}, [selectedInnerRows]);



  const handleToggleRowExpand = (record: GroupedTasks, event: React.MouseEvent<HTMLElement>) => {
    // Update the expandedRow state using the functional form of setState
    setExpandedRow(prevExpandedRow => prevExpandedRow === record.month ? null : record.month);
    // Prevent event propagation
    event.stopPropagation();
  };

  const handleToggleInnerRowExpand = (record: TaskObject) => {
    const taskKeys = Object.keys(record?.tasks);
    if (taskKeys.length > 0) {
      // Get the first key from the tasks object
      const firstTaskKey = taskKeys[0];
      // Update the state with the first task key
      setExpandedInnerRow(prevExpandedInnerRow => {
        // Check if the current expanded row is the same as the first task key
        if (prevExpandedInnerRow === firstTaskKey) {
          // If it is, collapse the row by setting expandedInnerRow to null
          return null;
        } else {
          // Otherwise, expand the row by setting expandedInnerRow to the first task key
          return firstTaskKey;
        }
      });
    }
    console.log("handleToggleInnerRowExpand", expandedInnerRow);
  };
  
    const rowClassName = (record: GroupedTasks, index: number) => {
      return index % 2 === 0 ? 'even-row' : 'odd-row';
    };

    // const column: ColumnsType<GroupedTasks> = [
    //   {
    //     title: 'Select All',
    //     dataIndex: 'date',
    //     key: 'date',
    //     width: '20%',
    //     fixed: 'left',
    //     render: (_, record) => {
    //       // Get the specific month key
    //       const monthKey = Object.keys(record.tasks).find(key => moment(key).format('YYYY-MM') === moment(record.month, 'MMMM YYYY').format('YYYY-MM'));
    //       if (!monthKey) return null; // If monthKey is not found, return null
          
    //       // Get the formatted date for the month key
    //       const formattedDate = moment(monthKey).format('YYYY-MM-DD');
    //       return formattedDate;
    //     },
    //   },      
    //   {
    //     title: '',
    //     dataIndex: 'tasks',
    //     key: 'tasks',
    //     width: '60%',
    //     render: (_, record: GroupedTasks) => {
    //       // Initialize variables to store task hours and total hours
    //       let totalHours = 0;
    //       const taskHours: { [key: string]: number } = {};
        
    //       // Iterate over each date in the record
    //       Object.entries(record.tasks).forEach(([date, dateTasks]) => {
    //         // Iterate over tasks for each date
    //         dateTasks.tasks.forEach(task => {
    //           const totalHoursForTask = parseFloat(task.totalHours || '0');
    //           totalHours += totalHoursForTask; // Accumulate total hours
    //           taskHours[task.task] = (taskHours[task.task] || 0) + totalHoursForTask; // Add task hours
    //         });
    //       });
        
    //       // Calculate extra hours if total hours exceed 9
    //       const extraHours = totalHours > 9 ? totalHours - 9 : 0;
        
    //       return (
    //         <div>
    //           <ul style={{ display: 'flex', flexDirection: 'row', listStyle: 'none', padding: 0}}>
    //             {/* Render task hours for each task */}
    //             {Object.entries(taskHours).map(([taskName, taskTotalHours], index) => (
    //               <li key={index} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', margin: '5px' }}>
    //                 <div style={{ paddingRight: '20px' }}>
    //                   <div style={{ color: 'grey', paddingBottom: '5px' }}>
    //                     {taskName}
    //                   </div>
    //                   <div style={{ fontWeight: "bold", fontSize: '20px', color: 'black' }}>
    //                     {taskTotalHours}H
    //                   </div>
    //                 </div>
    //                 <div>
    //                   <Progress
    //                     type="circle"
    //                     percent={Math.round((taskTotalHours / 9) * 100)} // Ensure it's an integer
    //                     width={60}
    //                   />
    //                 </div>
    //               </li>
    //             ))}
    //             {/* Render extra hours and total hours */}
    //             <li style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white',  margin: '5px' }}>
    //               <div style={{ color: '#0B4266', paddingRight: '20px' }}>
    //                 Extra Hours
    //               </div>
    //               <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: "bold", fontSize: '20px' }}>
    //                 {extraHours}H
    //               </div>
    //             </li>
    //             <li style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', margin: '5px' }}>
    //               <div style={{ color: '#0B4266', paddingRight: '20px' }}>
    //                 Total Hours
    //               </div>
    //               <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: 'bold', fontSize: '20px' }}>
    //                 {totalHours}H
    //               </div>
    //             </li>
    //           </ul>
    //         </div>
    //       );
    //     },
    //   },      
    //   {
    //     title: '',
    //     dataIndex: 'actions',
    //     key: 'actions',
    //     fixed: 'right',
    //     width: '20%',
    //     render: (_, record: GroupedTasks) => (
    //       <div>
    //         {/* Check if the record has tasks */}
    //         {record.tasks && Object.keys(record.tasks).length > 0 ? (
    //           // Render the appropriate icon based on the expanded state
    //           expandedInnerRow === Object.keys(record.tasks)[0] ? (
    //             <UpOutlined
    //               style={{
    //                 cursor: 'pointer',
    //                 color: '#0B4266',
    //                 fontSize: '16px',
    //               }}
    //               onClick={() => handleToggleInnerRowExpand(record)}
    //             />
    //           ) : (
    //             <DownOutlined
    //               style={{
    //                 cursor: 'pointer',
    //                 color: '#0B4266',
    //                 fontSize: '16px',
    //               }}
    //               onClick={() => handleToggleInnerRowExpand(record)}
    //             />
    //           )
    //         ) : null}
    //       </div>
    //     ),
    //   }  
    // ];
    
    const getColumn = (formattedMonth: string) => {
      const column: ColumnsType<TaskObject> = [
        {
          title: 'Select All',
          dataIndex: 'date',
          key: 'date',
          width: '20%',
          fixed: 'left',
          render: (_, record: TaskObject) => {
            // Get the specific month key
            const monthKey = Object.keys(record).find(
              key =>
                moment(key).format('YYYY-MM') ===
                moment(formattedMonth, 'YYYY-MM').format('YYYY-MM')
            );
            if (!monthKey) return null; // If monthKey is not found, return null
      
            // Get the formatted date for the month key
            const formattedDate = moment(monthKey).format('YYYY-MM-DD');
            return formattedDate;
          },
        },     
        {
          title: '',
          dataIndex: 'tasks',
          key: 'tasks',
          width: '60%',
          render: (_, record: TaskObject) => {
            // Initialize variables to store task hours and total hours
            let totalHours = 0;
            const taskHours: { [key: string]: number } = {};
          
            // Iterate over each date in the record
            Object.entries(record).forEach(([date, dateTasks]) => {
              // Iterate over tasks for each date
              dateTasks.tasks.forEach(task => {
                const totalHoursForTask = parseFloat(task.totalHours || '0');
                totalHours += totalHoursForTask; // Accumulate total hours
                taskHours[task?.task] = (taskHours[task?.task] || 0) + totalHoursForTask; // Add task hours
              });
            });
          
            // Calculate extra hours if total hours exceed 9
            const extraHours = totalHours > 9 ? totalHours - 9 : 0;
          
            return (
              <div>
                <ul style={{ display: 'flex', flexDirection: 'row', listStyle: 'none', padding: 0}}>
                  {/* Render task hours for each task */}
                  {Object.entries(taskHours).map(([taskName, taskTotalHours], index) => (
                    <li key={index} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', margin: '5px' }}>
                      <div style={{ paddingRight: '20px' }}>
                        <div style={{ color: 'grey', paddingBottom: '5px' }}>
                          {taskName}
                        </div>
                        <div style={{ fontWeight: "bold", fontSize: '20px', color: 'black' }}>
                          {taskTotalHours}H
                        </div>
                      </div>
                      <div>
                        <Progress
                          type="circle"
                          percent={Math.round((taskTotalHours / 9) * 100)} // Ensure it's an integer
                          width={60}
                        />
                      </div>
                    </li>
                  ))}
                  {/* Render extra hours and total hours */}
                  <li style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white',  margin: '5px' }}>
                    <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                      Extra Hours
                    </div>
                    <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: "bold", fontSize: '20px' }}>
                      {extraHours}H
                    </div>
                  </li>
                  <li style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', margin: '5px' }}>
                    <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                      Total Hours
                    </div>
                    <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: 'bold', fontSize: '20px' }}>
                      {totalHours}H
                    </div>
                  </li>
                </ul>
              </div>
            );
          },
        },      
        {
          title: '',
          dataIndex: 'actions',
          key: 'actions',
          fixed: 'right',
          width: '20%',
          render: (_, record: TaskObject) => (
            <div>
              {/* Check if the record has tasks */}
              {record && Object.keys(record).length > 0 ? (
                // Render the appropriate icon based on the expanded state
                expandedInnerRow === Object.keys(record)[0] ? (
                  <UpOutlined
                    style={{
                      cursor: 'pointer',
                      color: '#0B4266',
                      fontSize: '16px',
                    }}
                    onClick={() => handleToggleInnerRowExpand(record)}
                  />
                ) : (
                  <DownOutlined
                    style={{
                      cursor: 'pointer',
                      color: '#0B4266',
                      fontSize: '16px',
                    }}
                    onClick={() => handleToggleInnerRowExpand(record)}
                  />
                )
              ) : null}
            </div>
          ),
        }  
      ];
      return column;
    };
    
    

    
    const innerColumn: ColumnsType<Task> = [
      {
        title: 'Sl.no',
        className: 'ant-table-column-title',
        dataIndex: 'slNo',
        key: 'slNo',
        fixed: 'left',
        render: (_, __, index) => <span>{index + 1}</span>,
      },  
      {
        title: 'Task',
        sorter: (a: Task, b: Task) => {
          return a.task.localeCompare(b.task);
        },
        dataIndex: 'task',
        key: 'task',
        fixed: 'left',
      },
      {
        title: 'Start Time',
        sorter: (a: Task, b: Task) => {
          return a.startTime.localeCompare(b.startTime);
        },
        dataIndex: 'startTime',
        key: 'startTime',
        fixed: 'left',
      },
      {
        title: 'End Time',
        sorter: (a: Task, b: Task) => {
          return a.endTime.localeCompare(b.endTime);
        },
        dataIndex: 'endTime',
        key: 'endTime',
        fixed: 'left',
      },
      {
        title: 'Total Hours',
        sorter: (a: Task, b: Task) => {
          return a.totalHours.localeCompare(b.totalHours);
        },
        dataIndex: 'totalHours',
        key: 'totalHours',
        fixed: 'left',
      },
      {
        title: 'Description',
        sorter: (a: Task, b: Task) => {
          return a.description.localeCompare(b.description);
        },
        dataIndex: 'description',
        key: 'description',
        fixed: 'left',
      },
    ];
    
    const columns: ColumnsType<GroupedTasks> = [
      {
        title: 'Sl.no',
        className: 'ant-table-column-title',
        dataIndex: 'slNo',
        key: 'slNo',
        fixed: 'left',
        render: (_, __, index) => <span>{index + 1}</span>,
      },    
      {
        title: "Employee",
        className: ' ant-table-column-title',
        dataIndex: "tasks",
        render: (tasks: { [date: string]: { key: string; tasks: Task[] } }) => {
          const userId = tasks[Object.keys(tasks)[0]].tasks[0]?.userId || '';
          return (
            <Space className="flex gap-5">
              <Avatar icon={<UserOutlined />} size={45} />
              <div>
                <div>
                  <strong>Sasi Kumar</strong>
                </div>
                <div>{userId}</div>
              </div>
            </Space>
          );
        },
        sorter: (a: GroupedTasks, b: GroupedTasks) => {
          const userIdA = a.tasks[Object.keys(a.tasks)[0]].tasks[0]?.userId || '';
          const userIdB = b.tasks[Object.keys(b.tasks)[0]].tasks[0]?.userId || '';
          return userIdA.localeCompare(userIdB);
        },
      },          
      {
        title: 'Month',
        sorter: (a, b) => a.month.localeCompare(b.month),
        className: 'ant-table-column-title',
        dataIndex: 'month',
        key: 'month',
        fixed: 'left',
      },
      {
        title: 'Requested On',
        className: 'ant-table-column-title',
        dataIndex: 'tasks',
        key: 'date',
        fixed: 'left',
        render: (tasks: { [date: string]: Task[] }) => {
          const dates = Object.keys(tasks);
          const earliestDate = dates.length > 0 ? dates.sort()[0] : null;
          const formattedDate = earliestDate ? moment(earliestDate).format('YYYY-MM-DD') : '';
          return formattedDate;
        },
      },        
      {
        title: 'Days Filled',
        className: 'ant-table-column-title',
        dataIndex: 'daysFilled',
        key: 'daysFilled',
        render: (daysFilled, record) => {
          const dateKeysFilled = Object.keys(record.tasks).length;
          return (
            <span>{`${dateKeysFilled} / ${record.totalDaysInMonth}`}</span>
          );
        },
        sorter: (a: GroupedTasks, b: GroupedTasks) => Object.keys(a.tasks).length - Object.keys(b.tasks).length,
      },    
      {
        title: ' ',
        dataIndex: 'actions',
        key: 'actions',
        render: (_, record, index) => (
          <div>
            {expandedRow === record.month ? (
              <UpOutlined
                style={{
                  cursor: 'pointer',
                  color: '#0B4266',
                  fontSize: '16px',
                }}
                onClick={(event) => handleToggleRowExpand(record, event)}
              />            
            ) : (
              <DownOutlined
                style={{
                  cursor: 'pointer',
                  color: '#0B4266',
                  fontSize: '16px',
                }}
                onClick={(event) => handleToggleRowExpand(record, event)}
              />
            )}
          </div>
        )
      }
    ];
  
    const expandable: ExpandableConfig<GroupedTasks> = {
      expandedRowRender: (record: GroupedTasks) => {
        const taskHours: { [key: string]: number } = {};
        for (const dateKey in record.tasks) {
          record.tasks[dateKey].tasks.forEach(task => {
            if (taskHours.hasOwnProperty(task.task)) {
              taskHours[task.task] += parseFloat(task.totalHours || '0');
            } else {
              taskHours[task.task] = parseFloat(task.totalHours || '0');
            }
          });
        }
        
        // After calculating the total hours for each task, convert them to fixed decimals
        for (const taskName in taskHours) {
          if (taskHours.hasOwnProperty(taskName)) {
            taskHours[taskName] = parseFloat(taskHours[taskName].toFixed(2));
          }
        }
        
        const totalHours = Math.floor(Object.values(taskHours).reduce((acc, curr) => acc + curr, 0));
        const regularHours = Math.min(totalHours, 9);
        const extraHours = totalHours - regularHours;
    
        if (expandedRow === record.month) {
          return (
            <div>
              <ul style={{ display: 'flex', justifyContent: 'space-around', listStyle: 'none' }}>
                {Object.entries(taskHours).map(([taskName, taskTotalHours], index) => (
                  <div key={index} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
                    <div style={{ paddingRight: '20px' }}>
                      <div style={{ color: 'grey', paddingBottom: '5px' }}>
                        {taskName}
                      </div>
                      <div style={{ fontWeight: "bold", fontSize: '20px', color: 'black' }}>
                        {taskTotalHours}H
                      </div>
                    </div>
                    <div>
                      <Progress
                        type="circle"
                        percent={Math.round((taskTotalHours / 9) * 100)} // Ensure it's an integer
                        width={60}
                      />
                    </div>
                  </div>
                ))}
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
                  <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                    Extra Hours
                  </div>
                  <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: "bold", fontSize: '20px' }}>
                    {extraHours}H
                  </div>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
                  <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                    Total Hours
                  </div>
                  <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: 'bold', fontSize: '20px' }}>
                    {totalHours}H
                  </div>
                </div>
    
    
              </ul>
            </div>
          );
        }
        return null;
      },
      expandRowByClick: true,
      expandIcon: () => null
    };
    
    const aggregatedData: GroupedTasks[] = Object.keys(groupedTasks).map((monthKey: string) => {
      const monthData = groupedTasks[monthKey];
      const monthTasks: { [date: string]: { key: string; tasks: Task[] } } = {};
      let daysFilled = 0;
      for (const dateKey in monthData.tasks) {
        if (Object.keys(monthData.tasks[dateKey].tasks).length > 0) {
          monthTasks[dateKey] = monthData.tasks[dateKey];
          daysFilled++;
        }
      }
      const totalDaysInMonth = monthData.totalDaysInMonth;
      return {
        key: monthData.key,
        month: monthData.month,
        tasks: monthTasks,
        daysFilled: daysFilled,
        totalDaysInMonth: totalDaysInMonth
      };
    });
    
    // const flattenedData = (groupedTasks: { [key: string]: GroupedTasks }, monthKey: string): TaskObject[] => {
    //   const tasks: TaskObject[] = [];
    //   console.log("flattenedData", monthKey);
    //   // Find the monthData corresponding to the given monthKey
    //   const monthData = groupedTasks[monthKey];
    //   if (monthData) {
    //     // Iterate over each date in the monthData tasks
    //     for (const dateKey in monthData.tasks) {
    //       tasks.push({
    //         [dateKey]: monthData.tasks[dateKey]
    //       });
    //     }
    //   }
      
    //   return tasks;
    // }
    

    // const getDateKeyFromMonthKey =(monthKey: any)=>{
    //   let taskKeys: string[] = [];
    //                   // Iterate over the selected row keys
    //                   monthKey.forEach(key => {
    //                       // Find the corresponding record using the key
    //                       tasksForClickedMonth.find(record => {
    //                           const taskDateKeys = Object.keys(record.tasks); // Renamed to avoid conflict
    //                           console.log("onChange -taskkeysinrecord", taskDateKeys);
                              
    //                           taskDateKeys.forEach(dateKey => {
    //                               const taskKey = record.tasks[dateKey].key.toString();
    //                               console.log("taskKey", taskKey);
    //                               taskKeys.push(taskKey);
    //                           });
    //                       });
    //                   });
          
    //                   // Update the selectedInnerRows state with the task keys
    //                 return taskKeys;
    // }
  
    const flattenedData = (groupedTasks: TaskObject) => {
      const tasks: TaskObject[] = [];
      const keys = Object.keys(groupedTasks);
      console.log("keys", keys);
      // Iterate over each key
      keys.forEach(key => {
          // Find the monthData corresponding to the current key
          const groupedData = groupedTasks[key];
          console.log("monthdata", groupedData);
          if (groupedData) {
              // Convert monthData into TaskObject
              const taskObject: TaskObject = {
                  [key]: {
                      key: groupedData.key,
                      tasks: groupedData.tasks
                  }
              };
              tasks.push(taskObject);
          }
      });
  
      return tasks;
  };
  
    const handleRowClick = (
      record: TaskObject,
      formattedMonth: string,
      event: React.MouseEvent<HTMLElement>
    ) => {
      console.log('handleRowClick record', record);
      const tasksForClickedMonth: TaskObject[] = flattenedData(
        record
      );
    
      // Set the month tasks in the state
      setMonthTasks(tasksForClickedMonth);
      console.log("tasksForClickedMonth",tasksForClickedMonth);
      // Set the modal content and make the modal visible
      setModalContent(
        <div>
          <Table
          rowSelection={{
            type: 'checkbox',
            selectedRowKeys: selectedInnerRows,
            ...rowSelection,
            onChange(selectedRowKeys, selectedRows, info) {
                console.log(selectedRowKeys,selectedRows,info)
            },
            // selectedRowKeys: selectedInnerRows,
            // onChange: (selectedRowKeys, selectedRows) => handleInnerRowSelection(selectedRowKeys, selectedRows, tasksForClickedMonth),
          }}          
                    // rowSelection={{
            //   type: 'checkbox',
            //   selectedRowKeys: selectedInnerRows,
            //   // onChange: (selectedRowKeys: React.Key[]) => {
            //   //   // let taskKeys: string[] = [];
            //   //   // // Iterate over the selected row keys
            //   //   // selectedRowKeys.forEach(key => {
            //   //   //   // Find the corresponding record using the key
            //   //   //   tasksForClickedMonth.forEach(record => {
            //   //   //     const taskDateKeys = Object.keys(record.tasks); // Renamed to avoid conflict
            //   //   //     taskDateKeys.forEach(dateKey => {
            //   //   //       const taskKey = record.tasks[dateKey].key.toString();
            //   //   //       taskKeys.push(taskKey);
            //   //   //     });
            //   //   //   });
            //   //   // });
            //   //   // // Update the selectedInnerRows state with the task keys
            //   //   // setSelectedInnerRows(taskKeys);
            //   //   setSelectedInnerRows(selectedRowKeys as string[]);
            //   // },
            //   onChange: handleInnerRowSelection,
            //   getCheckboxProps: (record) => {
            //     // Initialize key to undefined
            //     let key: string = '';
            //     // Iterate over the tasks object to find the first available key
            //     for (const dateKey in record) {
            //       console.log("dateKey",dateKey);
            //       const dateTasks = record[dateKey];
            //       if (
            //         dateTasks &&
            //         dateTasks?.tasks &&
            //         dateTasks?.tasks.length > 0
            //       ) {
            //         // Check if the task belongs to the selected month
            //         const taskDate = moment(dateKey, 'YYYY-MM-DD');
            //         if (taskDate.format('YYYY-MM') === formattedMonth) {
            //           // Use the key of the tasks object for row selection
            //           key = dateKey;
            //           break; // Stop iterating after finding the first key
            //         }
            //       }
            //     }
            //     return {
            //       key: key,
            //       disabled: false, // You can adjust these additional props as needed
            //     };
            //   },
            // }}
            style={{
              backgroundColor: 'white',
              border: '1px solid grey',
              borderRadius: '5px',
            }}
            columns={getColumn(formattedMonth)} 
            rowClassName="rowstyle"
            dataSource={tasksForClickedMonth} // Pass the tasks for the clicked month here
            pagination={false}
            expandable={{
              expandedRowRender: (record: TaskObject) => {
                const handleInnerRowExpand = (dateKey: string) => {
                  const tasksForDate = record[dateKey]?.tasks || [];
                  return (
                    <Table
                      columns={innerColumn as ColumnsType<Task>}
                      dataSource={tasksForDate}
                      pagination={false}
                    />
                  );
                };
              
                return (
                  <>
                    {Object.keys(record).map(dateKey => (
                      <div key={dateKey}>
                        <div>Date: {dateKey}</div>
                        {handleInnerRowExpand(dateKey)}
                      </div>
                    ))}
                  </>
                );
              },
              
    
              expandRowByClick: true,
              expandIcon: () => null,
            }}
          />
        </div>
      );
      // Set the modal content and make the modal visible
      setModalVisible(true);
    
      // Prevent event propagation
      event.stopPropagation();
    };
     
  return (
    <DashboardLayout>
      <div>
        <Table
           rowSelection={{
            type: 'checkbox',
            selectedRowKeys: selectedRows,
            onChange: handleRowSelection,
            getCheckboxProps: (record: GroupedTasks) => ({
              // Use the `key` field as the identifier for row selection
              key: record.key,
              disabled: false, // You can adjust these additional props as needed
            }),
          }}   
          onRow={(record: GroupedTasks) => ({
            onClick: (event: React.MouseEvent<HTMLElement>) => {
              const userId = record.tasks[Object.keys(record.tasks)[0]].tasks[0]?.userId;
              setSelectedUserId(userId); // Set the userId in state
    
              // Extract necessary data from the GroupedTasks record
              const monthYear = record.month;
              const [monthName, year] = monthYear.split(' ');
              const monthNumber = moment().month(monthName).format('MM');
              const formattedMonth = `${year}-${monthNumber}`;
          
              // Convert GroupedTasks record into TaskObject
              const tasksObject: TaskObject = record.tasks;
              console.log("taskObject", tasksObject);
              // Pass TaskObject and formattedMonth to handleRowClick
              handleRowClick(tasksObject, formattedMonth, event);
            },
          })}
          
          style={{ backgroundColor: 'white' }}
          columns={columns}
          dataSource={aggregatedData}
          pagination={false}
          expandable={expandable}
        />
      </div>
      <Modal
        title={
          modalContent ? (
            <div>
              <Space className="flex gap-5">
                <Avatar icon={<UserOutlined />} size={45} />
                <div>
                  <div>
                    <strong>Sasi Kumar</strong>
                  </div>
                  {/* Displaying the userId */}
                  <div>{selectedUserId}</div>
                </div>
              </Space>
            </div>
          ) : null
        }
        visible={modalVisible}
        onCancel={() => setModalVisible(false)}
        footer={null}
        width="80%"
      >
        {modalContent}
        <div style={{display:'flex', justifyContent:'flex-end', margin:"10px 20px"}}>
          <Button style={{width:'10%', backgroundColor:'green', color:'white'}} onClick={handleApprove}>Approve</Button>
          <Button style={{ width: '10%', backgroundColor: 'red', color: 'white' }} onClick={handleReject}>
            Reject
          </Button>
          <Modal
            title="Comments"
            className='modalTitle'
            visible={commentVisible}
            onCancel={handleCancel}
            footer={[
              // <Button key="cancel" onClick={handleCancel}>
              //   Cancel
              // </Button>,
              <Button style={{ width: '20%', backgroundColor: '#0B4266', color: 'white' }} key="submit" type="primary" onClick={handleSubmit}>
                Submit
              </Button>,
            ]}
          >
            <Input.TextArea placeholder='Write here...' rows={4} value={comments} onChange={handleInputChange} />
          </Modal>
        </div>
      </Modal>
    </DashboardLayout>
  );
  
}

export default ApprovalRequest                  

code 3
import React,{useEffect, useState, useRef} from 'react'
import { useNavigate } from 'react-router-dom';
import { ColumnsType } from 'antd/es/table'
import { EditOutlined, FolderViewOutlined} from '@ant-design/icons';
import { Progress } from 'antd';
import dayjs from 'dayjs';
import { v4 as uuidv4 } from 'uuid';
import '../Styles/ApprovalRequest.css';
import {
  Avatar,
  Space,
  Button,
  Table,
  Modal,
  Form,
  Input,
  Select,
  ConfigProvider,
  Tooltip,
  Tag,
  Popover,
  message,
  Checkbox,
  Pagination,
  Menu,
  Dropdown,
} from "antd";
import moment from "moment";
import { ExpandableConfig } from 'antd/lib/table/interface';
import 'moment/locale/en-in';
import {
  UserOutlined,
  DownOutlined,
  UpOutlined,
} from "@ant-design/icons";
import DashboardLayout from './Layout';
import { Task } from './AddTask';
import { groupBy } from 'lodash';
import { ConstructionOutlined } from '@mui/icons-material';
import { TableRowSelection } from 'antd/lib/table/interface';

// Define the type for RowSelectMethod
type RowSelectMethod = 'checkbox' | 'radio';

// interface GroupedTasks {
//   key: string;
//   slNo?: number;
//   month: string;
//   tasks: { 
//     [date: string]: {
//       key: string;
//       tasks: Task[]; 
//     } 
//   }; 
//   daysFilled: number;
//   totalDaysInMonth: number;
// }

export interface TaskObject {
  [date: string]: {
    key: string;
    tasks: Task[]; 
  };
}

interface GroupedTasks {
  key: string;
  slNo?: number;
  month: string;
  tasks: TaskObject;
  daysFilled: number;
  totalDaysInMonth: number;
}

const ApprovalRequest:React.FC= () => { 
  const navigate = useNavigate();
  const [forceUpdate, setForceUpdate] = useState(false);

  //const [selectedRows, setSelectedRows] = useState<React.Key[]>([]);
  const [selectedRows, setSelectedRows] = useState<string[]>([]);
  const [selectedInnerRows, setSelectedInnerRows] = useState<string[]>([]);
  //const[daysInMonth, getDaysInMonth]=useState<string[]>([]);
  const [groupedTasks, setGroupedTasks] = useState<{ [key: string]: GroupedTasks }>({});
  // State declaration with two keys
  //const [groupedTasks, setGroupedTasks] = useState<{ [month: string]: { [date: string]: GroupedTasks } }>({});
  const [expandedRow, setExpandedRow] = useState<string | null>(null);
  const [expandedInnerRow, setExpandedInnerRow] = useState<string | null>(null);
  const [modalVisible, setModalVisible] = useState<boolean>(false);
  const [modalContent, setModalContent] = useState<JSX.Element | null>(null);
  const [selectedUserId, setSelectedUserId] = useState<string | undefined>(undefined);
  const [comments, setComments] = useState('');
  const [commentVisible, setCommentVisible] = useState(false);
  const [approvalRequests, setApprovalRequests] = useState<Task[]>([]);
  const [monthTasks, setMonthTasks] = useState<TaskObject[]>([]);
  useEffect(() => {
    // Retrieve approvalRequestsData from local storage
    const storedData = localStorage.getItem('approvalRequestsData');
    if (storedData) {
        const approvalRequestsData = JSON.parse(storedData);
        setApprovalRequests(approvalRequestsData); // Update the state with fetched data
    }
  }, []); // Fetch data only once on component mount

  useEffect(() => {
      if (approvalRequests.length > 0) { // Check if approvalRequests has data
          // Process approvalRequests data
          handleGroupedTasks(approvalRequests);
      }
  }, [approvalRequests]);

  useEffect(() => {
    // Log monthTasks
    console.log("useEffect monthTasks", monthTasks);
    
    // Store monthTasks in localStorage
    localStorage.setItem('monthTasks', JSON.stringify(monthTasks));
  }, [monthTasks]); 

  const handleReject = () => {
    setCommentVisible(true);
  };

  const handleCancel = () => {
    setCommentVisible(false);
  };

  const handleInputChange = (e:any) => {
    setComments(e.target.value);
  };

  const handleSubmit = () => {
    // Handle submission logic here
    console.log('Comments:', comments);
    setCommentVisible(false);
  };

  const handleApprove = () => {
    // Filter out the selected row from the groupedTasks state
    const updatedGroupedTasks = { ...groupedTasks };
    console.log("handleApprove", updatedGroupedTasks);
    // Iterate through selected rows
    selectedInnerRows.forEach(rowKey => {
        // Check if the rowKey exists in updatedGroupedTasks and if its tasks property is defined
        if (updatedGroupedTasks[rowKey]?.tasks) {
            const tasks = updatedGroupedTasks[rowKey].tasks;
            // Iterate through tasks for each date
            Object.values(tasks).forEach(dateTasks => {
                // Iterate through individual tasks
                dateTasks.tasks.forEach(task => {
                    // Add a special CSS class or inline style to change the background color to green
                    (task as Task & { backgroundColor?: string }).backgroundColor = 'green'; // Adjust this to your styling needs
                });
            });
        }
    });
    console.log("updatedGroupedTaks", updatedGroupedTasks);
    // Update the selectedInnerRows array to remove the approved row
    setSelectedInnerRows([]);

    // Close the modal
    setModalVisible(false);

    // Update the state with the modified groupedTasks
    setGroupedTasks(updatedGroupedTasks);
};

  
  function getDaysInMonth(month: number, year: number) {
    // month is 0-based in JavaScript
    return new Date(year, month + 1, 0).getDate();
  }

  const handleGroupedTasks = (requestData: Task[]) => {
    // Group tasks by month
    const grouped = groupBy(requestData, (task: Task) => dayjs(task.date).format("YYYY-MM"));
    const groupedData = groupBy(requestData, (task: Task)=>dayjs(task.date).format('YYYY-MM-DD'));
    console.log("handleGroupedTasks-grouped", grouped);
    // Retrieve existing data from local storage
    const existingDataJSON = localStorage.getItem('groupedTasks');
    const existingData: { [key: string]: GroupedTasks } = existingDataJSON ? JSON.parse(existingDataJSON) : {};
    // Process each month's tasks
    for (const monthKey in grouped) {
      const tasksArray = grouped[monthKey] as Task[];
  
      const firstTaskDate = dayjs(tasksArray[0].date, 'YYYY-MM-DD');
      const formattedMonth = firstTaskDate.format("MMMM YYYY");
      const totalDaysInMonth = getDaysInMonth(firstTaskDate.month(), firstTaskDate.year());
  
      let daysFilled = 0;
      const tasks: { [key: string]: { key: string; tasks: Task[] } } = {};
      tasksArray.forEach(task => {
        const dateKey = dayjs(task.date, 'YYYY-MM-DD').format('YYYY-MM-DD');
        if (existingData.hasOwnProperty(monthKey)) {
          if (!existingData[monthKey].tasks.hasOwnProperty(dateKey)) {
            existingData[monthKey].tasks[dateKey] = { key: uuidv4(), tasks: [task] };
            daysFilled++;
          } else {
            existingData[monthKey].tasks[dateKey].tasks = [task]; // Replace existing tasks with new task
          }
        } else {
          const dateUUID = uuidv4(); // Generate unique key for the date
          tasks[dateKey] = { key: dateUUID, tasks: [task] };
          daysFilled++;
        }
      });
  
      if (!existingData.hasOwnProperty(monthKey)) {
        const monthUUID = uuidv4(); // Generate unique key for the month
        existingData[monthKey] = {
          key: monthUUID,
          month: formattedMonth,
          daysFilled,
          totalDaysInMonth,
          tasks
        };
      } else {
        existingData[monthKey].daysFilled = daysFilled; // Update daysFilled
      }
    }
  
    // Set the updated data to local storage
    localStorage.setItem('groupedTasks', JSON.stringify(existingData));
  
    // Update the state with the combined data
    setGroupedTasks(existingData);
  };
  
  const handleRowSelection = (selectedRowKeys: React.Key[]) => {
    console.log("handleRowSelection selectedRowKeys", selectedRowKeys); // Output selectedRowKeys to console
    setSelectedRows(selectedRowKeys as string[]);
  };

const handleInnerRowSelection = (     
  selectedRowKeys: React.Key[],
  selectedRows: TaskObject[],
  tasksForClickedMonth: TaskObject[]
) => {
  // Extracting keys from the tasksForClickedMonth array
  const taskKeys = tasksForClickedMonth.flatMap(task => Object.keys(task));
  
  console.log("taskkeys",taskKeys);
  setSelectedInnerRows(taskKeys as string[]); // Assuming selectedRowKeys are string keys
  console.log("handleInnerRowSelection tasksForClickedMonth", tasksForClickedMonth);
};

const rowSelection = {
  onChange: (selectedRowKeys: React.Key[], selectedRows: TaskObject[]) => {
    console.log('selectedRowKeys', selectedRowKeys, 'selectedRows: ', selectedRows);
    setSelectedInnerRows(selectedRowKeys as string[]);
    console.log(selectedInnerRows);
  },
  getCheckboxProps: (record: TaskObject) => ({
    disabled: false, // Column configuration not to be checked
    key: record.key,
  }),
};

useEffect(() => {
  console.log("selectedInnerRows", selectedInnerRows);
}, [selectedInnerRows]);

  const handleToggleRowExpand = (record: GroupedTasks, event: React.MouseEvent<HTMLElement>) => {
    // Update the expandedRow state using the functional form of setState
    setExpandedRow(prevExpandedRow => prevExpandedRow === record.month ? null : record.month);
    // Prevent event propagation
    event.stopPropagation();
  };

  const handleToggleInnerRowExpand = (record: TaskObject) => {
    const taskKeys = Object.keys(record?.tasks);
    if (taskKeys.length > 0) {
      // Get the first key from the tasks object
      const firstTaskKey = taskKeys[0];
      // Update the state with the first task key
      setExpandedInnerRow(prevExpandedInnerRow => {
        // Check if the current expanded row is the same as the first task key
        if (prevExpandedInnerRow === firstTaskKey) {
          // If it is, collapse the row by setting expandedInnerRow to null
          return null;
        } else {
          // Otherwise, expand the row by setting expandedInnerRow to the first task key
          return firstTaskKey;
        }
      });
    }
    console.log("handleToggleInnerRowExpand", expandedInnerRow);
  };
  
    const rowClassName = (record: GroupedTasks, index: number) => {
      return index % 2 === 0 ? 'even-row' : 'odd-row';
    };

      const getColumn = (formattedMonth: string) => {
        const column: ColumnsType<TaskObject> = [
          {
            title: 'Select All',
            dataIndex: 'date',
            key: 'date',
            width: '20%',
            fixed: 'left',
            render: (_, record: TaskObject) => {
              // Get the specific month key
              const monthKey = Object.keys(record).find(
                key =>
                  moment(key).format('YYYY-MM') ===
                  moment(formattedMonth, 'YYYY-MM').format('YYYY-MM')
              );
              if (!monthKey) return null; // If monthKey is not found, return null
        
              // Get the formatted date for the month key
              const formattedDate = moment(monthKey).format('YYYY-MM-DD');
              return formattedDate;
            },
          },     
          {
            title: '',
            dataIndex: 'tasks',
            key: 'tasks',
            width: '60%',
            render: (_, record: TaskObject) => {
              // Initialize variables to store task hours and total hours
              let totalHours = 0;
              const taskHours: { [key: string]: number } = {};
            
              // Iterate over each date in the record
              Object.entries(record).forEach(([date, dateTasks]) => {
                // Iterate over tasks for each date
                dateTasks.tasks.forEach(task => {
                  const totalHoursForTask = parseFloat(task.totalHours || '0');
                  totalHours += totalHoursForTask; // Accumulate total hours
                  taskHours[task?.task] = (taskHours[task?.task] || 0) + totalHoursForTask; // Add task hours
                });
              });
            
              // Calculate extra hours if total hours exceed 9
              const extraHours = totalHours > 9 ? totalHours - 9 : 0;
            
              return (
                <div>
                  <ul style={{ display: 'flex', flexDirection: 'row', listStyle: 'none', padding: 0}}>
                    {/* Render task hours for each task */}
                    {Object.entries(taskHours).map(([taskName, taskTotalHours], index) => (
                      <li key={index} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', margin: '5px' }}>
                        <div style={{ paddingRight: '20px' }}>
                          <div style={{ color: 'grey', paddingBottom: '5px' }}>
                            {taskName}
                          </div>
                          <div style={{ fontWeight: "bold", fontSize: '20px', color: 'black' }}>
                            {taskTotalHours}H
                          </div>
                        </div>
                        <div>
                          <Progress
                            type="circle"
                            percent={Math.round((taskTotalHours / 9) * 100)} // Ensure it's an integer
                            width={60}
                          />
                        </div>
                      </li>
                    ))}
                    {/* Render extra hours and total hours */}
                    <li style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white',  margin: '5px' }}>
                      <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                        Extra Hours
                      </div>
                      <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: "bold", fontSize: '20px' }}>
                        {extraHours}H
                      </div>
                    </li>
                    <li style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', margin: '5px' }}>
                      <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                        Total Hours
                      </div>
                      <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: 'bold', fontSize: '20px' }}>
                        {totalHours}H
                      </div>
                    </li>
                  </ul>
                </div>
              );
            },
          },      
          {
            title: '',
            dataIndex: 'actions',
            key: 'actions',
            fixed: 'right',
            width: '20%',
            render: (_, record: TaskObject) => (
              <div>
                {/* Check if the record has tasks */}
                {record && Object.keys(record).length > 0 ? (
                  // Render the appropriate icon based on the expanded state
                  expandedInnerRow === Object.keys(record)[0] ? (
                    <UpOutlined
                      style={{
                        cursor: 'pointer',
                        color: '#0B4266',
                        fontSize: '16px',
                      }}
                      onClick={() => handleToggleInnerRowExpand(record)}
                    />
                  ) : (
                    <DownOutlined
                      style={{
                        cursor: 'pointer',
                        color: '#0B4266',
                        fontSize: '16px',
                      }}
                      onClick={() => handleToggleInnerRowExpand(record)}
                    />
                  )
                ) : null}
              </div>
            ),
          }  
        ];
        return column;
      };
    
    const innerColumn: ColumnsType<Task> = [
      {
        title: 'Sl.no',
        className: 'ant-table-column-title',
        dataIndex: 'slNo',
        key: 'slNo',
        fixed: 'left',
        render: (_, __, index) => <span>{index + 1}</span>,
      },  
      {
        title: 'Task',
        sorter: (a: Task, b: Task) => {
          return a.task.localeCompare(b.task);
        },
        dataIndex: 'task',
        key: 'task',
        fixed: 'left',
      },
      {
        title: 'Start Time',
        sorter: (a: Task, b: Task) => {
          return a.startTime.localeCompare(b.startTime);
        },
        dataIndex: 'startTime',
        key: 'startTime',
        fixed: 'left',
      },
      {
        title: 'End Time',
        sorter: (a: Task, b: Task) => {
          return a.endTime.localeCompare(b.endTime);
        },
        dataIndex: 'endTime',
        key: 'endTime',
        fixed: 'left',
      },
      {
        title: 'Total Hours',
        sorter: (a: Task, b: Task) => {
          return a.totalHours.localeCompare(b.totalHours);
        },
        dataIndex: 'totalHours',
        key: 'totalHours',
        fixed: 'left',
      },
      {
        title: 'Description',
        sorter: (a: Task, b: Task) => {
          return a.description.localeCompare(b.description);
        },
        dataIndex: 'description',
        key: 'description',
        fixed: 'left',
      },
    ];
    
    const columns: ColumnsType<GroupedTasks> = [
      {
        title: 'Sl.no',
        className: 'ant-table-column-title',
        dataIndex: 'slNo',
        key: 'slNo',
        fixed: 'left',
        render: (_, __, index) => <span>{index + 1}</span>,
      },    
      {
        title: "Employee",
        className: ' ant-table-column-title',
        dataIndex: "tasks",
        render: (tasks: { [date: string]: { key: string; tasks: Task[] } }) => {
          const userId = tasks[Object.keys(tasks)[0]].tasks[0]?.userId || '';
          return (
            <Space className="flex gap-5">
              <Avatar icon={<UserOutlined />} size={45} />
              <div>
                <div>
                  <strong>Sasi Kumar</strong>
                </div>
                <div>{userId}</div>
              </div>
            </Space>
          );
        },
        sorter: (a: GroupedTasks, b: GroupedTasks) => {
          const userIdA = a.tasks[Object.keys(a.tasks)[0]].tasks[0]?.userId || '';
          const userIdB = b.tasks[Object.keys(b.tasks)[0]].tasks[0]?.userId || '';
          return userIdA.localeCompare(userIdB);
        },
      },          
      {
        title: 'Month',
        sorter: (a, b) => a.month.localeCompare(b.month),
        className: 'ant-table-column-title',
        dataIndex: 'month',
        key: 'month',
        fixed: 'left',
      },
      {
        title: 'Requested On',
        className: 'ant-table-column-title',
        dataIndex: 'tasks',
        key: 'date',
        fixed: 'left',
        render: (tasks: { [date: string]: Task[] }) => {
          const dates = Object.keys(tasks);
          const earliestDate = dates.length > 0 ? dates.sort()[0] : null;
          const formattedDate = earliestDate ? moment(earliestDate).format('YYYY-MM-DD') : '';
          return formattedDate;
        },
      },        
      {
        title: 'Days Filled',
        className: 'ant-table-column-title',
        dataIndex: 'daysFilled',
        key: 'daysFilled',
        render: (daysFilled, record) => {
          const dateKeysFilled = Object.keys(record.tasks).length;
          return (
            <span>{`${dateKeysFilled} / ${record.totalDaysInMonth}`}</span>
          );
        },
        sorter: (a: GroupedTasks, b: GroupedTasks) => Object.keys(a.tasks).length - Object.keys(b.tasks).length,
      },    
      {
        title: ' ',
        dataIndex: 'actions',
        key: 'actions',
        render: (_, record, index) => (
          <div>
            {expandedRow === record.month ? (
              <UpOutlined
                style={{
                  cursor: 'pointer',
                  color: '#0B4266',
                  fontSize: '16px',
                }}
                onClick={(event) => handleToggleRowExpand(record, event)}
              />            
            ) : (
              <DownOutlined
                style={{
                  cursor: 'pointer',
                  color: '#0B4266',
                  fontSize: '16px',
                }}
                onClick={(event) => handleToggleRowExpand(record, event)}
              />
            )}
          </div>
        )
      }
    ];
  
    const expandable: ExpandableConfig<GroupedTasks> = {
      expandedRowRender: (record: GroupedTasks) => {
        const taskHours: { [key: string]: number } = {};
        for (const dateKey in record.tasks) {
          record.tasks[dateKey].tasks.forEach(task => {
            if (taskHours.hasOwnProperty(task.task)) {
              taskHours[task.task] += parseFloat(task.totalHours || '0');
            } else {
              taskHours[task.task] = parseFloat(task.totalHours || '0');
            }
          });
        }
        
        // After calculating the total hours for each task, convert them to fixed decimals
        for (const taskName in taskHours) {
          if (taskHours.hasOwnProperty(taskName)) {
            taskHours[taskName] = parseFloat(taskHours[taskName].toFixed(2));
          }
        }
        
        const totalHours = Math.floor(Object.values(taskHours).reduce((acc, curr) => acc + curr, 0));
        const regularHours = Math.min(totalHours, 9);
        const extraHours = totalHours - regularHours;
    
        if (expandedRow === record.month) {
          return (
            <div>
              <ul style={{ display: 'flex', justifyContent: 'space-around', listStyle: 'none' }}>
                {Object.entries(taskHours).map(([taskName, taskTotalHours], index) => (
                  <div key={index} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
                    <div style={{ paddingRight: '20px' }}>
                      <div style={{ color: 'grey', paddingBottom: '5px' }}>
                        {taskName}
                      </div>
                      <div style={{ fontWeight: "bold", fontSize: '20px', color: 'black' }}>
                        {taskTotalHours}H
                      </div>
                    </div>
                    <div>
                      <Progress
                        type="circle"
                        percent={Math.round((taskTotalHours / 9) * 100)} // Ensure it's an integer
                        width={60}
                      />
                    </div>
                  </div>
                ))}
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
                  <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                    Extra Hours
                  </div>
                  <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: "bold", fontSize: '20px' }}>
                    {extraHours}H
                  </div>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
                  <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                    Total Hours
                  </div>
                  <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: 'bold', fontSize: '20px' }}>
                    {totalHours}H
                  </div>
                </div>
              </ul>
            </div>
          );
        }
        return null;
      },
      expandRowByClick: true,
      //expandIcon: () => null
    };
    
    
    const aggregatedData: GroupedTasks[] = Object.keys(groupedTasks).map((monthKey: string) => {
      const monthData = groupedTasks[monthKey];
      const monthTasks: { [date: string]: { key: string; tasks: Task[] } } = {};
      let daysFilled = 0;
      for (const dateKey in monthData.tasks) {
        if (Object.keys(monthData.tasks[dateKey].tasks).length > 0) {
          monthTasks[dateKey] = monthData.tasks[dateKey];
          daysFilled++;
        }
      }
      const totalDaysInMonth = monthData.totalDaysInMonth;
      console.log("aggregatedData", monthData);
      return {
        key: monthData.key,
        month: monthData.month,
        tasks: monthTasks,
        daysFilled: daysFilled,
        totalDaysInMonth: totalDaysInMonth
      };
    });
  
    const flattenedData = (groupedTasks: TaskObject) => {
      const tasks: TaskObject[] = [];
      const keys = Object.keys(groupedTasks);
      console.log("keys", keys);
      // Iterate over each key
      keys.forEach(key => {
          // Find the monthData corresponding to the current key
          const groupedData = groupedTasks[key];
          console.log("monthdata", groupedData);
          if (groupedData) {
              // Convert monthData into TaskObject
              const taskObject: TaskObject = {
                  [key]: {
                      key: groupedData.key,
                      tasks: groupedData.tasks
                  }
              };
              tasks.push(taskObject);
          }
      });
  
      return tasks;
  };
  
    const handleRowClick = (
      record: TaskObject,
      formattedMonth: string,
      event: React.MouseEvent<HTMLElement>
    ) => {
      console.log('handleRowClick record', record);
      const tasksForClickedMonth: TaskObject[] = flattenedData(
        record
      );
    
      // Set the month tasks in the state
      setMonthTasks(tasksForClickedMonth);
      console.log("tasksForClickedMonth",tasksForClickedMonth);
      // Set the modal content and make the modal visible
      setModalContent(
        <div>
          <Table
          rowSelection={{
            type: 'checkbox',
            selectedRowKeys: selectedInnerRows,
            ...rowSelection,
            onChange(selectedRowKeys, selectedRows, info) {
                console.log(selectedRowKeys,selectedRows,info)
            },          
          }}          
            style={{
              backgroundColor: 'white',
              border: '1px solid grey',
              borderRadius: '5px',
            }}
            columns={getColumn(formattedMonth)} 
            rowClassName="rowstyle"
            dataSource={tasksForClickedMonth} // Pass the tasks for the clicked month here
            pagination={false}
            expandable={{
              expandedRowRender: (record: TaskObject) => {
                const handleInnerRowExpand = (dateKey: string) => {
                  const tasksForDate = record[dateKey]?.tasks || [];
                  return (
                    <Table
                      columns={innerColumn as ColumnsType<Task>}
                      dataSource={tasksForDate}
                      pagination={false}
                    />
                  );
                };
              
                return (
                  <>
                    {Object.keys(record).map(dateKey => (
                      <div key={dateKey}>
                        <div>Date: {dateKey}</div>
                        {handleInnerRowExpand(dateKey)}
                      </div>
                    ))}
                  </>
                );
              },
              
    
              expandRowByClick: true,
              expandIcon: () => null,
            }}
          />
        </div>
      );
      // Set the modal content and make the modal visible
      setModalVisible(true);
    
      // Prevent event propagation
      event.stopPropagation();
    };
     
  return (
    <DashboardLayout>
      <div>
        <Table
           rowSelection={{
            type: 'checkbox',
            selectedRowKeys: selectedRows,
            onChange: handleRowSelection,
            getCheckboxProps: (record: GroupedTasks) => ({
              // Use the `key` field as the identifier for row selection
              key: record.key,
              disabled: false, // You can adjust these additional props as needed
            }),
          }}   
          onRow={(record: GroupedTasks) => ({
            onClick: (event: React.MouseEvent<HTMLElement>) => {
              const userId = record.tasks[Object.keys(record.tasks)[0]].tasks[0]?.userId;
              setSelectedUserId(userId); // Set the userId in state
              // Extract necessary data from the GroupedTasks record
              const monthYear = record.month;
              const [monthName, year] = monthYear.split(' ');
              const monthNumber = moment().month(monthName).format('MM');
              const formattedMonth = `${year}-${monthNumber}`;
              // Convert GroupedTasks record into TaskObject
              const tasksObject: TaskObject = record.tasks;
              console.log("onRow-tasksObject", tasksObject);
              console.log("taskObject", tasksObject);
              const tasksForClickedMonth: TaskObject[] = flattenedData(
                tasksObject
              );
              console.log("onRow-tasksForClickedMonth", tasksForClickedMonth);
              setMonthTasks(tasksForClickedMonth);
              // Pass TaskObject and formattedMonth to handleRowClick
              //handleRowClick(tasksObject, formattedMonth, event);
              navigate(`/monthtasks?formattedMonth=${formattedMonth}&userId=${userId}`, {state: {
                formattedMonth: formattedMonth,
                userId: userId,
                tasksForClickedMonth: tasksObject,
            }});
            },
          })}
          
          style={{ backgroundColor: 'white' }}
          columns={columns}
          dataSource={aggregatedData}
          pagination={false}
          //expandable={expandable}
          expandable={{
            expandedRowRender: expandable.expandedRowRender,
            expandRowByClick: false,
            // expandIcon: ({ expanded, onExpand, record }) => (
            //   expanded ? 
            //     <UpOutlined onClick={(event) => onExpand(record, event)} /> :
            //     <DownOutlined onClick={(event) => onExpand(record, event)} />
            // ),
          }}  
        />
      </div>
      <Modal
        title={
          modalContent ? (
            <div>
              <Space className="flex gap-5">
                <Avatar icon={<UserOutlined />} size={45} />
                <div>
                  <div>
                    <strong>Sasi Kumar</strong>
                  </div>
                  {/* Displaying the userId */}
                  <div>{selectedUserId}</div>
                </div>
              </Space>
            </div>
          ) : null
        }
        visible={modalVisible}
        onCancel={() => setModalVisible(false)}
        footer={null}
        width="80%"
      >
        {modalContent}
        <div style={{display:'flex', justifyContent:'flex-end', margin:"10px 20px"}}>
          <Button style={{width:'10%', backgroundColor:'green', color:'white'}} onClick={handleApprove}>Approve</Button>
          <Button style={{ width: '10%', backgroundColor: 'red', color: 'white' }} onClick={handleReject}>
            Reject
          </Button>
          <Modal
            title="Comments"
            className='modalTitle'
            visible={commentVisible}
            onCancel={handleCancel}
            footer={[
              // <Button key="cancel" onClick={handleCancel}>
              //   Cancel
              // </Button>,
              <Button style={{ width: '20%', backgroundColor: '#0B4266', color: 'white' }} key="submit" type="primary" onClick={handleSubmit}>
                Submit
              </Button>,
            ]}
          >
            <Input.TextArea placeholder='Write here...' rows={4} value={comments} onChange={handleInputChange} />
          </Modal>
        </div>
      </Modal>
    </DashboardLayout>
  );
  
}

export default ApprovalRequest

monthTasks.tsx

import React,{useState, useEffect} from 'react'
import moment from 'moment'
import {
    UserOutlined,
    DownOutlined,
    UpOutlined,
} from "@ant-design/icons";
import { useParams, useLocation } from 'react-router-dom';
import { Progress } from 'antd';
import DashboardLayout from './Layout'
import { ColumnsType } from 'antd/es/table'
import { Table } from 'antd'
import { TaskObject } from './ApprovalRequest'
import { Task } from './AddTask'
const MonthTasks = () => {
    const location = useLocation();
    const { formattedMonth, userId, tasksForClickedMonth } = location.state;
    // const {formattedMonth='', userId=''}=useParams();
    const [monthTasks, setMonthTasks] = useState<{ [key: string]: TaskObject }>({});
    const [monthDate, setMonthDate]= useState<string[]>([]);
    const [selectedRows, setSelectedRows] = useState<string[]>([]);
    console.log("received data", formattedMonth,userId, tasksForClickedMonth)
    useEffect(() => {
        setMonthTasks(tasksForClickedMonth);
        setMonthDate(Object.keys(tasksForClickedMonth)); 
    }, [tasksForClickedMonth]);
    const handleRowSelection = (selectedRowKeys: React.Key[]) => {
        setSelectedRows(selectedRowKeys as string[]);
        console.log("handleRowSelection", selectedRowKeys);
    };

    const monthTaskDatas: TaskObject[] = Object.values(monthTasks).map(dateData => {
        console.log("monthTaskData-monthtasks", monthTasks)
        console.log("dateData", dateData);
        if (!dateData) return {}; // Check if dateData is undefined or null
        // const taskObject: TaskObject = {};
        // Object.entries(dateData).forEach(([date, data]) => {
        //     taskObject[date] = {
        //         key: data?.key,
        //         tasks: data?.tasks
        //     };
        // });
        // console.log("taskObject",taskObject);
        // return taskObject;
        return dateData;
    });

   const monthTaskData: TaskObject[] = Object.keys(monthTasks).map(dateKey => {
    const dateData = monthTasks[dateKey];
    console.log("monthTaskData-monthtasks", monthTasks);
    console.log("dateData", dateData);
    if (!dateData) return {}; // Check if dateData is undefined or null
    const taskObject: TaskObject = {
        [dateKey]: {
            key: dateData?.key?.key,
            tasks: dateData.tasks.tasks
        }
    };
    console.log("taskObject", taskObject);
    return taskObject;
});

    
    
    

//     const monthTaskData: { dateKey: string; tasks: Task[] }[] = Object.values(monthTasks)
//     .map((dateData: any) => ({
//         dateKey: dateData?.key || '',
//         tasks: dateData?.tasks || []
//     }))
//     .filter(({ dateKey, tasks }) => dateKey !== '' && tasks.length > 0);

//     const dataSource: TaskObject[] = monthTaskData.map(({ dateKey, tasks }) => ({
//     [dateKey]: {
//         key: dateKey,
//         tasks: tasks,
//     },
// }));


    
    
    const flattenedData = (groupedTasks: TaskObject[] | undefined) => {
        console.log("groupedTasks",groupedTasks);
        if (!groupedTasks) {
            return [];
        }

        const tasks: TaskObject[] = [];
        groupedTasks.forEach(taskObject => {
            Object.keys(taskObject).forEach(key => {
                const value = taskObject[key];
                tasks.push({
                    [key]: {
                        key: value?.key,
                        tasks: value?.tasks
                    }
                });
            });
        });

        return tasks;
    };
    const getColumn = (formattedMonth: string) => {
        const column: ColumnsType<TaskObject> = [
            {
                title: 'Select All',
                dataIndex: 'date',
                key: 'date',
                width: '20%',
                fixed: 'left',
                render: (_, record: TaskObject) => {
                    // Get the specific month key
                    const monthKey = Object.keys(record).find(
                        key =>
                            moment(key).format('YYYY-MM') ===
                            moment(formattedMonth, 'YYYY-MM').format('YYYY-MM')
                    );
                    if (!monthKey) return null; // If monthKey is not found, return null
    
                    // Get the formatted date for the month key
                    const formattedDate = moment(monthKey).format('YYYY-MM-DD');
                    return formattedDate;
                },
            },
            {
                title: '',
                dataIndex: 'tasks',
                key: 'tasks',
                width: '60%',
                render: (_, record: TaskObject) => {
                    // Initialize variables to store task hours and total hours
                    let totalHours = 0;
    
                    // Iterate over tasks for each date
                    record.tasks.tasks?.forEach(task => {
                        totalHours += parseFloat(task.totalHours || '0');
                    });
    
                    // Calculate extra hours if total hours exceed 9
                    const extraHours = totalHours > 9 ? totalHours - 9 : 0;
    
                    return (
                        <div>
                            {/* Render task hours for each task */}
                            {record.tasks.tasks?.map((task, index) => (
                                <li key={index} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', margin: '5px' }}>
                                    <div style={{ paddingRight: '20px' }}>
                                        <div style={{ color: 'grey', paddingBottom: '5px' }}>
                                            {task.task}
                                        </div>
                                        <div style={{ fontWeight: "bold", fontSize: '20px', color: 'black' }}>
                                            {parseFloat(task.totalHours || '0')}H
                                        </div>
                                    </div>
                                    <div>
                                        <Progress
                                            type="circle"
                                            percent={Math.round((parseFloat(task.totalHours || '0') / 9) * 100)} // Ensure it's an integer
                                            width={60}
                                        />
                                    </div>
                                </li>
                            ))}
                            {/* Render extra hours and total hours */}
                            <li style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', margin: '5px' }}>
                                <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                                    Extra Hours
                                </div>
                                <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: "bold", fontSize: '20px' }}>
                                    {extraHours}H
                                </div>
                            </li>
                            <li style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', margin: '5px' }}>
                                <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                                    Total Hours
                                </div>
                                <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: 'bold', fontSize: '20px' }}>
                                    {totalHours}H
                                </div>
                            </li>
                        </div>
                    );
                },
            },
        ];
    
        return column;
    };
    

    const innerColumn: ColumnsType<Task> = [
        {
          title: 'Sl.no',
          className: 'ant-table-column-title',
          dataIndex: 'slNo',
          key: 'slNo',
          fixed: 'left',
          render: (_, __, index) => <span>{index + 1}</span>,
        },  
        {
          title: 'Task',
          sorter: (a: Task, b: Task) => {
            return a.task.localeCompare(b.task);
          },
          dataIndex: 'task',
          key: 'task',
          fixed: 'left',
        },
        {
          title: 'Start Time',
          sorter: (a: Task, b: Task) => {
            return a.startTime.localeCompare(b.startTime);
          },
          dataIndex: 'startTime',
          key: 'startTime',
          fixed: 'left',
        },
        {
          title: 'End Time',
          sorter: (a: Task, b: Task) => {
            return a.endTime.localeCompare(b.endTime);
          },
          dataIndex: 'endTime',
          key: 'endTime',
          fixed: 'left',
        },
        {
          title: 'Total Hours',
          sorter: (a: Task, b: Task) => {
            return a.totalHours.localeCompare(b.totalHours);
          },
          dataIndex: 'totalHours',
          key: 'totalHours',
          fixed: 'left',
        },
        {
          title: 'Description',
          sorter: (a: Task, b: Task) => {
            return a.description.localeCompare(b.description);
          },
          dataIndex: 'description',
          key: 'description',
          fixed: 'left',
        },
    ];
    return (
        <DashboardLayout>
            <Table
            rowSelection={{
                type: 'checkbox',
                selectedRowKeys:selectedRows,
                onChange:handleRowSelection

            }}          
                style={{
                backgroundColor: 'white',
                border: '1px solid grey',
                borderRadius: '5px',
                }}
                columns={getColumn(formattedMonth)} 
                rowClassName="rowstyle"
                //dataSource={monthTasks ? flattenedData(monthTasks) : []}
                dataSource={monthTaskData}
                pagination={false}
                expandable={{
                expandedRowRender: (record: TaskObject) => {
                    const handleInnerRowExpand = (dateKey: string) => {
                    const tasksForDate = record[dateKey]?.tasks || [];
                    return (
                        <Table
                        columns={innerColumn as ColumnsType<Task>}
                        dataSource={tasksForDate}
                        pagination={false}
                        />
                    );
                    };
                
                    return (
                    <>
                        {Object.keys(record).map(dateKey => (
                        <div key={dateKey}>
                            <div>Date: {dateKey}</div>
                            {handleInnerRowExpand(dateKey)}
                        </div>
                        ))}
                    </>
                    );
                },
                
        
                expandRowByClick: true,
                expandIcon: () => null,
                }}
            />
        </DashboardLayout>
    )
}

export default MonthTasks

16/2/2024

AddTasks.tsx

import React, { useState, useEffect, useCallback } from 'react';
import { Input, TimePicker, Select, notification, DatePicker} from 'antd';
import { SearchOutlined } from '@mui/icons-material';
import dayjs from 'dayjs';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { useMsal } from '@azure/msal-react';
import '../Styles/CreateUser.css';
import DashboardLayout from './Layout';
import '../Styles/AddTask.css';
import {Table} from 'antd';
import { ColumnsType } from "antd/es/table";
import ApprovalRequest from './ApprovalRequest';
import { EditOutlined, DeleteOutlined,CloseCircleOutlined,LeftOutlined, RightOutlined } from '@ant-design/icons';
import Dashboard from './Dashboard';
export interface Task {
  key?:string;
  idx: number; // Add this line
  date: string;
  userId: string;
  task: string;
  startTime: string;
  endTime: string;
  totalHours: string;
  description: string;
  reportingTo: string;
  slNo?: number;
}

type AddTaskProps = {
  setPieChartData: React.Dispatch<React.SetStateAction<{ [key: string]: number }>>;
  setApprovalRequestsData: React.Dispatch<React.SetStateAction<Task[]>>;
  approvalRequestsData: Task[];
};

const AddTask: React.FC<AddTaskProps> = ({ setPieChartData, setApprovalRequestsData }) => {
  const navigate = useNavigate();
  const [deletedTask, setDeletedTask] = useState(false);
  const [formWidth, setFormWidth] = useState(800);
  const [currentDate, setCurrentDate] = useState(dayjs());
  const [currentWeek, setCurrentWeek] = useState(dayjs().startOf('week'));
  const [currentMonth, setCurrentMonth] = useState(dayjs().startOf('month'));
  const [isFormEnabled, setIsFormEnabled] = useState(false);
  const [addTask, setAddTask] = useState<Task>({
    idx: 1, // Set initial idx
    date: currentDate.format('YYYY-MM-DD'),
    userId: '123',
    task: '',
    startTime: '',
    endTime: '',
    totalHours: '',
    description: '',
    reportingTo: '',
  });
  const [deletedTaskIdx, setDeletedTaskIdx] = useState<number | null>(null);
  const [taskList, setTaskList] = useState<Task[]>([]);
  const [filteredTasks, setFilteredTasks] = useState<Task[]>([]);
  const reportingOptions = ['ManagerA', 'ManagerB', 'ManagerC'];
  const taskOptions = ['Task','Project','Learning','Training','Meeting'];
  const [filterOption, setFilterOption] = useState('Date');
  const [isEdited, setIsEdited]= useState<boolean>(false);
  // State to manage the search input
  const [searchInput, setSearchInput] = useState('');
  const [isFormSubmitted, setIsFormSubmitted] = useState(false);
 const updateSlNo = (tasks: Task[], deleteTask: boolean): Task[] => {
  return tasks.map((task, index) => ({
    ...task,
    slNo: index + 1,
    idx: deleteTask ? index + 1 : task.idx
  }));
};

  useEffect(() => {
    const updateFormWidth = () => {
      const formElement = document.getElementById('myForm');
      if (formElement) {
        const newWidth = formElement.offsetWidth;
        setFormWidth(newWidth);
      }
    };

    window.addEventListener('resize', updateFormWidth);
    updateFormWidth();

    return () => {
      window.removeEventListener('resize', updateFormWidth);
    };
  }, []);

  const borderStyle = {
    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)', // Add box shadow
    margin: '10px 20px',
   // padding: '10px 20px',
    width: formWidth + 'px',
  };
  
  const handleInputChange = (field: keyof Task, value: string) => {
    if (field === 'date') {
      const selectedDate = dayjs(value);
      if (selectedDate.isAfter(dayjs(), 'day')) {
        // Display a notification
        notification.warning({
          message: 'Warning',
          description: 'Cannot select a future date.',
        });
        // Set the selected date to today
        setCurrentDate(dayjs());
      } else {
        // Update the state with the selected date
        setCurrentDate(selectedDate);
      }
    }
  
    // Keep userId constant
    if (field === 'userId') {
      setAddTask((prevTask) => ({ ...prevTask, [field]: value }));
    } else {
      // Update startTime or endTime with the new value
      const updatedTime = value || dayjs().format('hh:mm A');
      setAddTask((prevTask) => ({ ...prevTask, [field]: updatedTime }));
      // Calculate the duration and update totalHours
      const updatedStartTime = field === 'startTime' ? updatedTime : addTask.startTime || dayjs().format('hh:mm A');
      const updatedEndTime = field === 'endTime' ? updatedTime : addTask.endTime || dayjs().format('hh:mm A');
      const duration = dayjs(updatedEndTime, 'hh:mm A').diff(dayjs(updatedStartTime, 'hh:mm A'), 'hour', true);
      setAddTask((prevTask) => ({
        ...prevTask,
        startTime: field === 'startTime' ? updatedTime : addTask.startTime,
        endTime: field === 'endTime' ? updatedTime : addTask.endTime,
        totalHours: duration.toFixed(2),
      }));
    }
  };
  
  useEffect(() => {
    const storedTaskListString = localStorage.getItem('taskList');
    const storedTaskList = storedTaskListString ? JSON.parse(storedTaskListString) : [];

    // Assuming deletedTask is a state variable
    const updatedTaskList = updateSlNo(storedTaskList, deletedTask);

    setTaskList(updatedTaskList);
    setFilteredTasks(updatedTaskList);
  }, [deletedTask]); // Include deletedTask in the dependency array

  useEffect(() => {
    // Filter tasks based on the addTask.date when it changes
    if (addTask.date) {
      const filtered = taskList.filter(task => task.date === addTask.date);
      setFilteredTasks(updateSlNo(filtered, deletedTask)); // Update slNo when loading tasks
    } else {
      // If no date is selected, display all tasks
      setFilteredTasks(updateSlNo(taskList, deletedTask)); // Update slNo when loading tasks
    }
  }, [addTask.date, taskList]);

  useEffect(() => {
    // Update addTask with the current date
    if (!isEdited) {
      // Update addTask with the current date only when not in edit mode
      setAddTask((prevAddTask) => ({
        ...prevAddTask,
        date: dayjs(currentDate).format('YYYY-MM-DD'),
    }));
  }
    //setFilteredTasks(taskList);
    // Filter tasks based on the filterOption and currentDate when they change
    let filtered: Task[] = [];

    if (searchInput) {
      // If there is a search input, filter tasks based on date or month
      const searchDate = dayjs(searchInput);
      filtered = taskList.filter((task) => {
        if (filterOption === 'Date') {
          return dayjs(task.date).isSame(searchDate, 'day');
        } else if (filterOption === 'Week') {
          const startOfWeek = currentWeek.startOf('week');
          const endOfWeek = currentWeek.endOf('week');
          return (
            (dayjs(task.date).isSame(startOfWeek) || dayjs(task.date).isAfter(startOfWeek)) &&
            (dayjs(task.date).isSame(endOfWeek) || dayjs(task.date).isBefore(endOfWeek))
          );
        } else if (filterOption === 'Month') {
          // Format the searchInput in the same way as the task date
          const formattedSearchMonth = searchDate.format('MMMM');
          return dayjs(task.date).format('MMMM') === formattedSearchMonth;
        }
        return false;
      });
    }  else {
      // If no search input, apply the regular filtering based on filterOption and currentDate
      if (filterOption === 'Date') {
        filtered = taskList.filter((task) => task.date === dayjs(currentDate).format('YYYY-MM-DD'));
        console.log("useEffect-date", filtered)
      } else if (filterOption === 'Week') {
        const startOfWeek = currentWeek.startOf('week');
        const endOfWeek = currentWeek.endOf('week');
        filtered = taskList.filter(
          (task) =>
            (dayjs(task.date).isSame(startOfWeek) || dayjs(task.date).isAfter(startOfWeek)) &&
            (dayjs(task.date).isSame(endOfWeek) || dayjs(task.date).isBefore(endOfWeek))
        );
        console.log("useeffect-week", filtered);
      } else if (filterOption === 'Month') {
        const startOfMonth = currentMonth.startOf('month');
        const endOfMonth = currentMonth.endOf('month');
        filtered = taskList.filter(
          (task) =>
            (dayjs(task.date).isSame(startOfMonth) || dayjs(task.date).isAfter(startOfMonth)) &&
            (dayjs(task.date).isSame(endOfMonth) || dayjs(task.date).isBefore(endOfMonth))
        );
        console.log("useeffect", filtered);
      }
    }

    setFilteredTasks(updateSlNo(filtered, deletedTask));
  //  console.log("useeffect filtered-task", filteredTasks);
  }, [isEdited, filterOption, currentDate, currentMonth, currentWeek, taskList, searchInput]);

  const handleFilterChange = (value: any) => {
    setFilterOption(value);
  };

  const handleLeftArrowClick = () => {
    if (filterOption === 'Date') {
      console.log("handleLeftArrowClick -prev", currentDate);
      const previousDate = currentDate.subtract(1, 'day');
      console.log("handleLeftArrowClick previousDate",previousDate)
      setCurrentDate(previousDate);

    } else if (filterOption === 'Week') {
      const previousWeekStart = currentWeek.subtract(1, 'week').startOf('week');
      const previousWeekEnd = currentWeek.subtract(1, 'week').endOf('week');
      setCurrentWeek(previousWeekStart);
      console.log("previousWeek",previousWeekStart)
    } else if (filterOption === 'Month') {
      const previousMonthStart = currentMonth.subtract(1, 'month').startOf('month');
      const previousMonthEnd = currentMonth.subtract(1, 'month').endOf('month');
      setCurrentMonth(previousMonthStart);
    }
  };

  const handleRightArrowClick = () => {
    if (filterOption === 'Date') {
      const nextDate = currentDate.add(1, 'day');
      if(nextDate.isAfter(dayjs(), 'day')){
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future weeks.',
        });
        return;
      }
      setCurrentDate(nextDate);
    } else if (filterOption === 'Week') {
      const nextWeekStart = currentWeek.add(1, 'week').startOf('week');
      const nextWeekEnd = currentWeek.add(1, 'week').endOf('week');
      if (nextWeekStart.isAfter(dayjs(), 'day')) {
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future weeks.',
        });
        return;
      }
      setCurrentWeek(nextWeekStart);
      
    } else if (filterOption === 'Month') {
      const nextMonthStart = currentMonth.add(1, 'month').startOf('month');
      if (nextMonthStart.isAfter(dayjs(), 'day')) {
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future months.',
        });
        return;
      }
      setCurrentMonth(nextMonthStart);
    }
    
  };

  const handleToggleForm = () => {
    setIsFormEnabled((prevIsFormEnabled) => !prevIsFormEnabled);
  
    // If you want to reset the form when disabling it, you can reset the form state here
    if (!isFormEnabled) {
      setAddTask({
        date: dayjs(currentDate).format('YYYY-MM-DD'),
        userId: '123',
        task: '',
        startTime: '',
        endTime: '',
        totalHours:'',
        description: '',
        reportingTo: '',
        idx: addTask.idx,
      });
    }
  };

  const handleFormSubmit = () => {
    console.log("---fd1", dayjs(addTask.date).format('YYYY-MM-DD'), dayjs(addTask.startTime).format('hh:mm A'), dayjs(addTask.endTime).format('hh:mm A'));
    // Check for overlapping tasks in the specified time range
    const overlappingTask = taskList.find((task) => {
      const newTaskStartTime = dayjs(addTask.startTime, 'hh:mm A');
      const newTaskEndTime = dayjs(addTask.endTime, 'hh:mm A');
      const taskStartTime = dayjs(task.startTime, 'hh:mm A');
      const taskEndTime = dayjs(task.endTime, 'hh:mm A');
    
      // Check if the new task overlaps with any existing task
      return (
        !isEdited && task.date === addTask.date &&
        (
          ((newTaskStartTime.isSame(taskStartTime) || newTaskStartTime.isAfter(taskStartTime))&& newTaskStartTime.isBefore(taskEndTime)) ||
          ((newTaskEndTime.isSame(taskStartTime) || newTaskEndTime.isAfter(taskStartTime))&& newTaskEndTime.isBefore(taskEndTime)) ||
          (newTaskStartTime.isBefore(taskStartTime) && (newTaskEndTime.isSame(taskEndTime)|| newTaskEndTime.isAfter(taskEndTime)))
        )
      );
    });
      
    if (overlappingTask) {
      notification.warning({
        message: 'Restricted',
        description: 'Task already exists in the specified time range.',
      });
      return;
    }

    if (isEdited) {
      // If editing, update the existing task
      const updatedTaskList = taskList.map((task) =>
        task.idx === addTask.idx ? { ...addTask } : task
      );
      setTaskList(updatedTaskList);
      setFilteredTasks(updateSlNo(updatedTaskList, deletedTask));
      localStorage.setItem('taskList', JSON.stringify(updatedTaskList));
      setIsEdited(false);
    } else {
      // Update the taskList
      const updatedTaskList = [...taskList, { ...addTask, idx: taskList.length + 1 }];
      setTaskList(updatedTaskList);
      setFilteredTasks(updateSlNo(updatedTaskList, deletedTask));
      localStorage.setItem('taskList', JSON.stringify(updatedTaskList));
    }
  
    // Clear the form with the default date and reset idx
    setAddTask({
      idx: taskList.length + 2, // Set a new idx
      date: dayjs(currentDate).format('YYYY-MM-DD'),
      userId: '123',
      task: '',
      startTime: '',
      endTime: '',
      totalHours: '',
      description: '',
      reportingTo: '',
    });
    setIsEdited(false);
    setIsFormSubmitted(true);
  };

  const handleClearSubmit = () => {
    // Clear the form with the default date and set idx
    setAddTask({
      date: dayjs(addTask.date).format('YYYY-MM-DD'),
      userId: '123',
      task: '',
      startTime: '',
      endTime: '',
      totalHours:'',
      description: '',
      reportingTo: '',
      idx: addTask.idx 
    });
  }
  
  const handleEditTask = (idx: number) => {
    // Implement the logic to edit the task based on date, startTime, and endTime
    // You can use the setAddTask function to update the form fields with the selected task's details
    setIsEdited(true);
    const taskToEdit = taskList.find((task) => task.idx === idx);
    if (taskToEdit) {
      setAddTask({
        date: taskToEdit.date,
        userId: taskToEdit.userId,
        task: taskToEdit.task,
        startTime: taskToEdit.startTime,
        endTime: taskToEdit.endTime,
        totalHours: taskToEdit.totalHours,
        description: taskToEdit.description,
        reportingTo: taskToEdit.reportingTo,
        idx: taskToEdit.idx, 
      });

      // Now, you can perform additional actions or display a modal for editing
      setCurrentDate(dayjs(taskToEdit.date));
    }
  };
  
  const handleDeleteTask = useCallback((idx: number) => {
    // Toggle the deletedTask flag
    setDeletedTask(true);
    // Save idx in state
    setDeletedTaskIdx(idx);
  }, []);

  useEffect(() => {
    if (deletedTask) {
      // Implement the logic to delete the task based on idx
      const updatedTaskList = taskList.filter((task) => task.idx !== deletedTaskIdx);

      // Reindex the idx starting from 1 and use deletedTask flag
      const reindexedTaskList = updateSlNo(updatedTaskList, deletedTask);

      setTaskList(reindexedTaskList);
      setFilteredTasks(reindexedTaskList);

      // Update localStorage
      localStorage.setItem('taskList', JSON.stringify(reindexedTaskList));

      // Reset the deletedTask flag after updating
      setDeletedTask(false);
    }
  }, [deletedTask, deletedTaskIdx]);

  // const handleOverallSubmit = () => {
  //   // Assuming you have an API endpoint for approval requests
  //   //const apiUrl = 'http://localhost:3000/approvalrequests';

  //   // Prepare the data to be sent
  //   const requestData = filteredTasks.map(task => ({
  //     date: task.date,
  //     userId: task.userId,
  //     task: task.task,
  //     startTime: task.startTime,
  //     endTime: task.endTime,
  //     totalHours: task.totalHours,
  //     description: task.description,
  //     reportingTo: task.reportingTo,
  //     idx: task.idx,
  //   }));
  //   // Navigate to the approvalrequests component with the data
  //   navigate('/approvalrequests', { state: { requestData } });
  //   // Make the HTTP POST request to the /approvalrequests endpoint
  //   // fetch(apiUrl, {
  //   //   method: 'POST',
  //   //   headers: {
  //   //     'Content-Type': 'application/json',
  //   //   },
  //   //   body: JSON.stringify(requestData),
  //   // })
  //   //   .then(response => {
  //   //     if (!response.ok) {
  //   //       console.log("network response was not okay");
  //   //       throw new Error('Network response was not ok');
          
  //   //     }
  //   //     return response.json();
  //   //   })
  //   //   .then(data => {
  //   //     // Handle the success response from the server
  //   //     console.log('Submission successful:', data);
  //   //     // You may want to show a success message or redirect the user
  //   //     // Show success notification
  //   //     notification.success({
  //   //       message: 'Submission Successful',
  //   //       description: 'Task details submitted successfully!',
  //   //     });
  //   //   })
  //   //   .catch(error => {
  //   //     // Handle errors during the fetch
  //   //     console.error('Error during submission:', error);
  //   //     // Show error notification
  //   //     notification.error({
  //   //       message: 'Submission Failed',
  //   //       description: 'There was an error submitting the task details.',
  //   //     });
  //   //     // You may want to show an error message to the user
  //   //   });
  // };

  const handleOverallSubmit = () => {
    // Prepare the data to be sent
    const requestData: Task[] = filteredTasks.map(task => ({
        date: task.date,
        userId: task.userId,
        task: task.task,
        startTime: task.startTime,
        endTime: task.endTime,
        totalHours: task.totalHours,
        description: task.description,
        reportingTo: task.reportingTo,
        idx: task.idx,
    }));

    // Set the success notification
    notification.success({
        message: 'Submission Successful',
        description: 'Task details submitted successfully!',
    });
    navigate('/approvalrequests')
    // Set the approvalRequestsData state
    setApprovalRequestsData(requestData);

    // Store the approvalRequestsData in local storage
    localStorage.setItem('approvalRequestsData', JSON.stringify(requestData));
};

  const columns: ColumnsType<Task> = [
    {
      title: 'Sl.no',
      sorter: (a: Task, b: Task) => (a.slNo && b.slNo ? a.slNo - b.slNo : 0),
      dataIndex: 'slNo',
      key: 'slNo',
      fixed: 'left',
    },
    {
      title: 'Task',
      sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
      dataIndex: 'task',
      key: 'task',
      fixed: 'left',
    },
    {
      title: 'Date',
      sorter: (a: Task, b: Task) => a.date.localeCompare(b.date),
      dataIndex: 'date',
      key: 'date',
      fixed: 'left',
    },
    {
      title: 'Start Time',
      sorter: (a: Task, b: Task) => a.startTime.localeCompare(b.startTime),
      dataIndex: 'startTime',
      key: 'startTime',
      fixed: 'left',
    },
    {
      title: 'End Time',
      sorter: (a: Task, b: Task) => a.endTime.localeCompare(b.endTime),
      dataIndex: 'endTime',
      key: 'endTime',
      fixed: 'left',
    },
    {
      title: 'Total Hours',
      sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
      dataIndex: 'totalHours',
      key: 'totalHours',
      fixed: 'left',
    },
    {
      title: 'Description',
      sorter: (a: Task, b: Task) => a.description.localeCompare(b.description),
      dataIndex: 'description',
      key: 'description',
      fixed: 'left',
    },
    {
      title: 'Reporting To',
      sorter: (a: Task, b: Task) => a.reportingTo.localeCompare(b.reportingTo),
      dataIndex: 'reportingTo',
      key: 'reportingTo',
      fixed: 'left',
    },
    
    {
      title: 'Actions',
      dataIndex: 'actions',
      key: 'actions',
      render: (_, record, index) => (
        <div>
          <EditOutlined
            onClick={() => handleEditTask(record.idx)}
            style={{
              marginRight: '8px',
              cursor: 'pointer',
              color: 'blue',
              fontSize: '20px',
            }}
          />
          <DeleteOutlined
            onClick={() => handleDeleteTask(record.idx)}
             style={{
              cursor: 'pointer',
              color:  'red',
              fontSize: '20px',
            }}
          />
        </div>
    )}
  ]

  return (
    <DashboardLayout>
      <div className='createuser-main'>
        <div className='header'>
          <div>
            <h1>Add Task</h1>
          </div>
          { filterOption === 'Month' ? (
            <div style={{display:'flex', justifyContent:'flex-end'}}>
              <div className='date'>From: {dayjs(currentMonth).format('YYYY-MM-DD')}</div>
              <div className='date' style={{ marginLeft: '40px' }}>To: {dayjs(currentMonth).endOf('month').format('YYYY-MM-DD')}</div>
            </div>
            ) : filterOption === 'Week' ? (
              <div style={{display:'flex', justifyContent:'flex-end'}}>
                <div className='date'>From: {dayjs(currentWeek).format('YYYY-MM-DD')}</div>
                <div className='date' style={{ marginLeft: '40px' }}>To: {dayjs(currentWeek).endOf('week').format('YYYY-MM-DD')}</div>
              </div>
            )  : (
              <div className='date'>Date: {currentDate.format('YYYY-MM-DD')}</div>
            )
          }
        </div>
        {(filterOption === 'Date' || ((filterOption === 'Week' || filterOption === 'Month') && isEdited)) || isFormEnabled  ? ( <form id="myForm" style={borderStyle}>
            <div>
            {isFormEnabled && (
              <CloseCircleOutlined
                style={{ margin: '10px 20px', display: 'flex', justifyContent: 'flex-end', color: 'red' }}
                onClick={handleToggleForm} // Call the handleToggleForm function on click
              />
            )}
              <div className='section-addtask'>
              <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label htmlFor='addTaskID'>Date</label>
                  </div>
                  {/* <input
                    type="date"
                    style={{ width: '100%' }}
                    className='timepicker'
                  /> */}
                  <Input
                    type='date'
                    placeholder='Enter your Employee ID'
                    value={currentDate.format('YYYY-MM-DD')} 
                    onChange={(e) => handleInputChange('date', e.target.value)}
                  />
                </div>
                {/* <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label htmlFor='addTaskID'>User ID</label>
                  </div>
                  <Input
                    placeholder='Enter your Employee ID'
                    value={addTask.userId}
                    onChange={(e) => handleInputChange('userId', e.target.value)}  
                  />
                </div> */}
                 <div className='create-layout-addtask'>
                  <div>
                    <label htmlFor='task'>Task</label>
                  </div>
                  <div>
                    <select
                      id='task'
                      value={addTask.task}
                      onChange={(e) => handleInputChange('task', e.target.value)}
                    >
                      {taskOptions.map((option) => (
                          <option key={option} value={option}>
                            {option}
                          </option>
                        ))}
                    </select>
                  </div>
                </div>
              </div>
              <div className='section-addtask'>
                <div className='create-layout-addtask-left'>
                  <div>
                    <label htmlFor='startTime'>Start Time</label>
                  </div>
                  <TimePicker
                    value={
                      addTask.startTime
                        ? dayjs(addTask.startTime, 'hh:mm A') // Convert to dayjs here
                        : null
                    }
                    onChange={(time, timeString) =>
                      handleInputChange('startTime', timeString)
                    }
                    className='timepicker'
                    format='hh:mm A' // Set the format to include AM/PM
                  />
                </div>
                <div className='create-layout-addtask'>
                  <div>
                    <label htmlFor='endTime'>End Time</label>
                  </div>
                  <TimePicker
                    value={
                      addTask.endTime
                        ? dayjs(addTask.endTime, 'HH:mm A') // Convert to dayjs here
                        : null
                    }
                    onChange={(time, timeString) =>
                      handleInputChange('endTime', timeString)
                    }
                    className='timepicker'
                    format='hh:mm A' 
                    rootClassName='timer'
                  />
                </div>
              </div>
              <div className='section-addtask'>
                
              <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label htmlFor='totalHours'>Total Hours</label>
                  </div>
                  <Input
                    placeholder='Enter your Total Hours'
                    value={addTask.totalHours}
                    onChange={(e) => handleInputChange('totalHours', e.target.value)}
                    
                  />
                </div>
                <div className='create-layout-addtask-reportingTo  '>
                  <div className='create-layout-reportingTo'>
                    <label htmlFor='reportingTo'>Reporting To</label>
                  </div>
                  <select
                    id='reportingTo-addtask'
                    value={addTask.reportingTo}
                    onChange={(e) => handleInputChange('reportingTo', e.target.value)}
                  >
                    <option value=''>Select Reporting To</option>
                    {reportingOptions.map((option) => (
                      <option key={option} value={option}>
                        {option}
                      </option>
                    ))}
                  </select>
                </div> 
              </div>  
              <div>
                <div className='create-layout-description'>
                  <div>
                    <label>Description</label>
                  </div>
                  <textarea
                    value={addTask.description}
                    onChange={(e) => handleInputChange('description', e.target.value)}
                    className='description-input'
                  />
                </div>
              </div>
            </div>
              
            
            <div className='button'>
              <button type='button' id='cancel-addtask' onClick={handleClearSubmit}>
                Clear
              </button>
              {isEdited ? (
              <button type='button' id='submit-addtask' onClick={handleFormSubmit}>
                Save
              </button>
            ):(
              <button type='button' id='submit-addtask' onClick={handleFormSubmit}>
                Add Task
              </button>
            )}
            </div>

        </form>):null}
        <>
        <div>
          <div style={{ display:'flex', justifyContent:'space-between', margin:'10px 20px' }}>
            <Input
            className="search-addtask"
            placeholder="Search by Date"
            allowClear
            suffix={<SearchOutlined style={{ color: "#04172480" }} />}
            onChange={(e) => {
            //  console.log("Search input value:", e.target.value);
              setSearchInput(e.target.value);
            }}
          />
         {!(filterOption === 'Date' && !isFormEnabled) && (
            <button
              id='cancel'
              onClick={handleToggleForm}
              disabled={isFormEnabled} // Disable the button when the form is enabled
            >
              Add Task
            </button>
          )}
          <div style={{display:'flex', justifyContent:'flex-end'}}>
          <button type='button' id='submit-less' onClick={handleLeftArrowClick}>
            <LeftOutlined />
          </button>

        {/* <Select
           
            style={{
              marginTop: '10px',
              display: 'flex',
              padding: '0.5em 2em',
              border: 'transparent',
              boxShadow: '2px 2px 4px rgba(0,0,0,0.4)',
              justifyContent: 'center',
              alignItems: 'center',
              gap: '10px',
              borderRadius: '4px',
              color:'white',
              background: '#0B4266',
              cursor: 'pointer',
              appearance: 'none',
              WebkitAppearance: 'none',
              MozAppearance: 'none',
            }}
            defaultValue="Date"
            onChange={handleFilterChange}
        >
          <Select.Option value="Date">Date</Select.Option>
          <Select.Option value="Week">Week</Select.Option>
          <Select.Option value="Month">Month</Select.Option>
        </Select> */}
          <select 
            id='submit' 
            style={{ appearance: 'none', WebkitAppearance: 'none', MozAppearance: 'none' }} 
            onChange={(e) => handleFilterChange(e.target.value)} value={filterOption}
          >
            <option style={{textAlign:'center'}} value='Date'>Date</option>
            <option style={{textAlign:'center'}} value='Week'>Week</option>
            <option style={{textAlign:'center'}} value='Month'>Month</option>
          </select>
          <button type='button' id='submit-less' onClick={handleRightArrowClick}>
            <RightOutlined />
          </button>
          </div>
        </div>
      </div>
        <Table
            columns={columns}
            dataSource={filteredTasks}
            pagination={false}
          />
            <button type='button' id='submit-overall' onClick={handleOverallSubmit}>
              Submit
            </button>
        </>
      </div>
    </DashboardLayout>
  );
};
export default AddTask;

AppRoutes.tsx

// AppRoutes.tsx
// import React from "react";
// import { Route, Routes, Navigate } from 'react-router-dom';
// import Error404 from "../Components/Error/Error-404";
// import Dashboard from "../Components/Dashboard/Dashboard";
// import Asset from "../Components/Dashboard/Asset";
// import BranchAdmin from "../Components/Dashboard/BranchAdmin";
// import CreateBranchAdmin from "../Components/Dashboard/CreateBranchAdmin";
// import CreateAsset from "../Components/Dashboard/CreateAsset";
// import OnboardForm from "../Components/OnboardForm";

// const AppRoutes: React.FC = () => {
//   return (
//     <Routes>
//       <Route path="/" element={<Navigate to='/dashboard' />} />
//       <Route path="/dashboard" element={<Dashboard />} />
//       <Route path="/onboardform" element={<OnboardForm />} />
//       <Route path="/asset" element={<Asset />} />
//       <Route path="/branch-admin" element={<BranchAdmin />} />
//       <Route path="/create-branch-admin" element={<CreateBranchAdmin />} />
//       <Route path="/create-asset" element={<CreateAsset />} />
//       <Route path="*" element={<Error404 />} />
//     </Routes>
//   );
// };

// export default AppRoutes;

import PrivateRoutes from './PrivateRoutes';
import React, { useState, useEffect } from "react";
import { Route, Routes, Navigate } from 'react-router-dom';
import Error404 from "../Components/Error/Error-404";
import Dashboard from "../Components/Dashboard/Dashboard";
import CreateBranchAdmin from "../Components/Dashboard/CreateBranchAdmin";
import OnboardForm from "../Components/Dashboard/OnboardForm";
import ControlCalendar from '../Components/Dashboard/Calendar';
import CreateUser from '../Components/Dashboard/CreateUser';
import EmployeeList from '../Components/Dashboard/Employee-list';
import UserDetails from '../Components/Dashboard/UserDetails';
import AddTask from '../Components/Dashboard/AddTask';
import UserProfile from '../Components/Dashboard/UserProfile';
import ApprovalRequest from '../Components/Dashboard/ApprovalRequest';
import { Task } from '../Components/Dashboard/AddTask';
import MonthTasks from '../Components/Dashboard/MonthTasks';

const AppRoutes: React.FC = () => {
  const userEmail = localStorage.getItem('email');
  const [pieChartData, setPieChartData] = useState<{ [key: string]: number }>({});
  const [approvalRequestsData, setApprovalRequestsData] = useState<Task[]>([]);

  useEffect(() => {
    // Retrieve approvalRequestsData from local storage
    const storedData = localStorage.getItem('approvalRequestsData');
    if (storedData) {
      setApprovalRequestsData(JSON.parse(storedData));
    }
  }, []); // Fetch data only once on component mount

  return (
    <Routes>
      <Route path="/" element={<Navigate to='/dashboard' />} />
      <Route element={<PrivateRoutes />}>
        <Route path="/dashboard" element={<Dashboard data={pieChartData}/>} />
        <Route path="/create-branch-admin" element={<CreateBranchAdmin />} />
        <Route path='/calendar' element={<ControlCalendar />} />
        <Route path="/onboardform" element={<OnboardForm />} />
        {/* ... (other routes) */}
        <Route path="/createuser" element={userEmail === 'sasikumarmurugan02@gmail.com' ? <CreateUser /> : <Navigate to="/dashboard" />} />
        <Route path='/userdetails' element={userEmail === 'sasikumarmurugan02@gmail.com' ? <UserDetails /> : <Navigate to="/dashboard" />} />
        <Route path='/employeeview' element={<EmployeeList />} />
        <Route
          path="/addtask"
          element={
            userEmail === 'sasikumarmurugan02@gmail.com' ? (
              <AddTask setPieChartData={setPieChartData} setApprovalRequestsData={setApprovalRequestsData} approvalRequestsData={approvalRequestsData}/>
            ) : (
                <Navigate to="/dashboard" />
              )
          }
        />
        <Route path="/userprofile/:userId" element={userEmail === 'sasikumarmurugan02@gmail.com' ? <UserProfile /> : <Navigate to="/dashboard" />} />
        <Route path="/createuser/:userId" element={userEmail === 'sasikumarmurugan02@gmail.com' ? <CreateUser /> : <Navigate to="/dashboard" />} />
        <Route path='/approvalrequests' element={(userEmail === 'sasikumarmurugan02@gmail.com') ? <ApprovalRequest/> : <Navigate to="/dashboard" />} />
        <Route path='/monthTasks' element={(userEmail === 'sasikumarmurugan02@gmail.com') ? <MonthTasks/> : <Navigate to="/dashboard" />} />
      </Route>
    </Routes>
  );
};
export default AppRoutes;

ApprovalRequest.tsx

import React,{useEffect, useState, useRef} from 'react'
import { useNavigate } from 'react-router-dom';
import { ColumnsType } from 'antd/es/table'
import { EditOutlined, FolderViewOutlined} from '@ant-design/icons';
import { Progress } from 'antd';
import dayjs from 'dayjs';
import { v4 as uuidv4 } from 'uuid';
import '../Styles/ApprovalRequest.css';
import {
  Avatar,
  Space,
  Button,
  Table,
  Modal,
  Form,
  Input,
  Select,
  ConfigProvider,
  Tooltip,
  Tag,
  Popover,
  message,
  Checkbox,
  Pagination,
  Menu,
  Dropdown,
} from "antd";
import moment from "moment";
import { ExpandableConfig } from 'antd/lib/table/interface';
import 'moment/locale/en-in';
import {
  UserOutlined,
  DownOutlined,
  UpOutlined,
} from "@ant-design/icons";
import DashboardLayout from './Layout';
import { Task } from './AddTask';
import { groupBy } from 'lodash';
import { ConstructionOutlined } from '@mui/icons-material';
import { TableRowSelection } from 'antd/lib/table/interface';

// Define the type for RowSelectMethod
type RowSelectMethod = 'checkbox' | 'radio';

// interface GroupedTasks {
//   key: string;
//   slNo?: number;
//   month: string;
//   tasks: { 
//     [date: string]: {
//       key: string;
//       tasks: Task[]; 
//     } 
//   }; 
//   daysFilled: number;
//   totalDaysInMonth: number;
// }

export interface TaskObject {
  [date: string]: {
    key: string;
    tasks: Task[];
  };
}

interface GroupedTasks {
  key: string;
  slNo?: number;
  month: string;
  tasks: TaskObject;
  daysFilled: number;
  totalDaysInMonth: number;
}

const ApprovalRequest:React.FC= () => { 
  const navigate = useNavigate();
  const [forceUpdate, setForceUpdate] = useState(false);

  //const [selectedRows, setSelectedRows] = useState<React.Key[]>([]);
  const [selectedRows, setSelectedRows] = useState<string[]>([]);
  const [selectedInnerRows, setSelectedInnerRows] = useState<string[]>([]);
  //const[daysInMonth, getDaysInMonth]=useState<string[]>([]);
  const [groupedTasks, setGroupedTasks] = useState<{ [key: string]: GroupedTasks }>({});
  // State declaration with two keys
  //const [groupedTasks, setGroupedTasks] = useState<{ [month: string]: { [date: string]: GroupedTasks } }>({});
  const [expandedRow, setExpandedRow] = useState<string | null>(null);
  const [expandedInnerRow, setExpandedInnerRow] = useState<string | null>(null);
  const [modalVisible, setModalVisible] = useState<boolean>(false);
  const [modalContent, setModalContent] = useState<JSX.Element | null>(null);
  const [selectedUserId, setSelectedUserId] = useState<string | undefined>(undefined);
  const [comments, setComments] = useState('');
  const [commentVisible, setCommentVisible] = useState(false);
  const [approvalRequests, setApprovalRequests] = useState<Task[]>([]);
  const [monthTasks, setMonthTasks] = useState<TaskObject[]>([]);
  useEffect(() => {
    // Retrieve approvalRequestsData from local storage
    const storedData = localStorage.getItem('approvalRequestsData');
    if (storedData) {
        const approvalRequestsData = JSON.parse(storedData);
        setApprovalRequests(approvalRequestsData); // Update the state with fetched data
    }
  }, []); // Fetch data only once on component mount

  useEffect(() => {
      if (approvalRequests.length > 0) { // Check if approvalRequests has data
          // Process approvalRequests data
          handleGroupedTasks(approvalRequests);
      }
  }, [approvalRequests]);

  useEffect(() => {
    // Log monthTasks
    console.log("useEffect monthTasks", monthTasks);
    
    // Store monthTasks in localStorage
    localStorage.setItem('monthTasks', JSON.stringify(monthTasks));
  }, [monthTasks]); 

  const handleReject = () => {
    setCommentVisible(true);
  };

  const handleCancel = () => {
    setCommentVisible(false);
  };

  const handleInputChange = (e:any) => {
    setComments(e.target.value);
  };

  const handleSubmit = () => {
    // Handle submission logic here
    console.log('Comments:', comments);
    setCommentVisible(false);
  };

  const handleApprove = () => {
    // Filter out the selected row from the groupedTasks state
    const updatedGroupedTasks = { ...groupedTasks };
    console.log("handleApprove", updatedGroupedTasks);
    // Iterate through selected rows
    selectedInnerRows.forEach(rowKey => {
        // Check if the rowKey exists in updatedGroupedTasks and if its tasks property is defined
        if (updatedGroupedTasks[rowKey]?.tasks) {
            const tasks = updatedGroupedTasks[rowKey].tasks;
            // Iterate through tasks for each date
            Object.values(tasks).forEach(dateTasks => {
                // Iterate through individual tasks
                dateTasks.tasks.forEach(task => {
                    // Add a special CSS class or inline style to change the background color to green
                    (task as Task & { backgroundColor?: string }).backgroundColor = 'green'; // Adjust this to your styling needs
                });
            });
        }
    });
    console.log("updatedGroupedTaks", updatedGroupedTasks);
    // Update the selectedInnerRows array to remove the approved row
    setSelectedInnerRows([]);

    // Close the modal
    setModalVisible(false);

    // Update the state with the modified groupedTasks
    setGroupedTasks(updatedGroupedTasks);
};

  
  function getDaysInMonth(month: number, year: number) {
    // month is 0-based in JavaScript
    return new Date(year, month + 1, 0).getDate();
  }

  const handleGroupedTasks = (requestData: Task[]) => {
    // Group tasks by month
    const grouped = groupBy(requestData, (task: Task) => dayjs(task.date).format("YYYY-MM"));
    const groupedData = groupBy(requestData, (task: Task)=>dayjs(task.date).format('YYYY-MM-DD'));
    console.log("handleGroupedTasks-grouped", grouped);
    // Retrieve existing data from local storage
    const existingDataJSON = localStorage.getItem('groupedTasks');
    const existingData: { [key: string]: GroupedTasks } = existingDataJSON ? JSON.parse(existingDataJSON) : {};
    // Process each month's tasks
    for (const monthKey in grouped) {
      const tasksArray = grouped[monthKey] as Task[];
  
      const firstTaskDate = dayjs(tasksArray[0].date, 'YYYY-MM-DD');
      const formattedMonth = firstTaskDate.format("MMMM YYYY");
      const totalDaysInMonth = getDaysInMonth(firstTaskDate.month(), firstTaskDate.year());
  
      let daysFilled = 0;
      const tasks: { [key: string]: { key: string; tasks: Task[] } } = {};
      tasksArray.forEach(task => {
        const dateKey = dayjs(task.date, 'YYYY-MM-DD').format('YYYY-MM-DD');
        if (existingData.hasOwnProperty(monthKey)) {
          if (!existingData[monthKey].tasks.hasOwnProperty(dateKey)) {
            existingData[monthKey].tasks[dateKey] = { key: uuidv4(), tasks: [task] };
            daysFilled++;
          } else {
            existingData[monthKey].tasks[dateKey].tasks = [task]; // Replace existing tasks with new task
          }
        } else {
          const dateUUID = uuidv4(); // Generate unique key for the date
          tasks[dateKey] = { key: dateUUID, tasks: [task] };
          daysFilled++;
        }
      });
  
      if (!existingData.hasOwnProperty(monthKey)) {
        const monthUUID = uuidv4(); // Generate unique key for the month
        existingData[monthKey] = {
          key: monthUUID,
          month: formattedMonth,
          daysFilled,
          totalDaysInMonth,
          tasks
        };
      } else {
        existingData[monthKey].daysFilled = daysFilled; // Update daysFilled
      }
    }
  
    // Set the updated data to local storage
    localStorage.setItem('groupedTasks', JSON.stringify(existingData));
  
    // Update the state with the combined data
    setGroupedTasks(existingData);
  };
  
  const handleRowSelection = (selectedRowKeys: React.Key[]) => {
    console.log("handleRowSelection selectedRowKeys", selectedRowKeys); // Output selectedRowKeys to console
    setSelectedRows(selectedRowKeys as string[]);
  };

const handleInnerRowSelection = (     
  selectedRowKeys: React.Key[],
  selectedRows: TaskObject[],
  tasksForClickedMonth: TaskObject[]
) => {
  // Extracting keys from the tasksForClickedMonth array
  const taskKeys = tasksForClickedMonth.flatMap(task => Object.keys(task));
  
  console.log("taskkeys",taskKeys);
  setSelectedInnerRows(taskKeys as string[]); // Assuming selectedRowKeys are string keys
  console.log("handleInnerRowSelection tasksForClickedMonth", tasksForClickedMonth);
};

const rowSelection = {
  onChange: (selectedRowKeys: React.Key[], selectedRows: TaskObject[]) => {
    console.log('selectedRowKeys', selectedRowKeys, 'selectedRows: ', selectedRows);
    setSelectedInnerRows(selectedRowKeys as string[]);
    console.log(selectedInnerRows);
  },
  getCheckboxProps: (record: TaskObject) => ({
    disabled: false, // Column configuration not to be checked
    key: record.key,
  }),
};

useEffect(() => {
  console.log("selectedInnerRows", selectedInnerRows);
}, [selectedInnerRows]);

  const handleToggleRowExpand = (record: GroupedTasks, event: React.MouseEvent<HTMLElement>) => {
    // Update the expandedRow state using the functional form of setState
    setExpandedRow(prevExpandedRow => prevExpandedRow === record.month ? null : record.month);
    // Prevent event propagation
    event.stopPropagation();
  };

  const handleToggleInnerRowExpand = (record: TaskObject) => {
    const taskKeys = Object.keys(record?.tasks);
    if (taskKeys.length > 0) {
      // Get the first key from the tasks object
      const firstTaskKey = taskKeys[0];
      // Update the state with the first task key
      setExpandedInnerRow(prevExpandedInnerRow => {
        // Check if the current expanded row is the same as the first task key
        if (prevExpandedInnerRow === firstTaskKey) {
          // If it is, collapse the row by setting expandedInnerRow to null
          return null;
        } else {
          // Otherwise, expand the row by setting expandedInnerRow to the first task key
          return firstTaskKey;
        }
      });
    }
    console.log("handleToggleInnerRowExpand", expandedInnerRow);
  };
  
    const rowClassName = (record: GroupedTasks, index: number) => {
      return index % 2 === 0 ? 'even-row' : 'odd-row';
    };

      const getColumn = (formattedMonth: string) => {
        const column: ColumnsType<TaskObject> = [
          {
            title: 'Select All',
            dataIndex: 'date',
            key: 'date',
            width: '20%',
            fixed: 'left',
            render: (_, record: TaskObject) => {
              // Get the specific month key
              const monthKey = Object.keys(record).find(
                key =>
                  moment(key).format('YYYY-MM') ===
                  moment(formattedMonth, 'YYYY-MM').format('YYYY-MM')
              );
              if (!monthKey) return null; // If monthKey is not found, return null
        
              // Get the formatted date for the month key
              const formattedDate = moment(monthKey).format('YYYY-MM-DD');
              return formattedDate;
            },
          },     
          {
            title: '',
            dataIndex: 'tasks',
            key: 'tasks',
            width: '60%',
            render: (_, record: TaskObject) => {
              // Initialize variables to store task hours and total hours
              let totalHours = 0;
              const taskHours: { [key: string]: number } = {};
            
              // Iterate over each date in the record
              Object.entries(record).forEach(([date, dateTasks]) => {
                // Iterate over tasks for each date
                dateTasks.tasks.forEach(task => {
                  const totalHoursForTask = parseFloat(task.totalHours || '0');
                  totalHours += totalHoursForTask; // Accumulate total hours
                  taskHours[task?.task] = (taskHours[task?.task] || 0) + totalHoursForTask; // Add task hours
                });
              });
            
              // Calculate extra hours if total hours exceed 9
              const extraHours = totalHours > 9 ? totalHours - 9 : 0;
            
              return (
                <div>
                  <ul style={{ display: 'flex', flexDirection: 'row', listStyle: 'none', padding: 0}}>
                    {/* Render task hours for each task */}
                    {Object.entries(taskHours).map(([taskName, taskTotalHours], index) => (
                      <li key={index} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', margin: '5px' }}>
                        <div style={{ paddingRight: '20px' }}>
                          <div style={{ color: 'grey', paddingBottom: '5px' }}>
                            {taskName}
                          </div>
                          <div style={{ fontWeight: "bold", fontSize: '20px', color: 'black' }}>
                            {taskTotalHours}H
                          </div>
                        </div>
                        <div>
                          <Progress
                            type="circle"
                            percent={Math.round((taskTotalHours / 9) * 100)} // Ensure it's an integer
                            width={60}
                          />
                        </div>
                      </li>
                    ))}
                    {/* Render extra hours and total hours */}
                    <li style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white',  margin: '5px' }}>
                      <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                        Extra Hours
                      </div>
                      <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: "bold", fontSize: '20px' }}>
                        {extraHours}H
                      </div>
                    </li>
                    <li style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', margin: '5px' }}>
                      <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                        Total Hours
                      </div>
                      <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: 'bold', fontSize: '20px' }}>
                        {totalHours}H
                      </div>
                    </li>
                  </ul>
                </div>
              );
            },
          },      
          {
            title: '',
            dataIndex: 'actions',
            key: 'actions',
            fixed: 'right',
            width: '20%',
            render: (_, record: TaskObject) => (
              <div>
                {/* Check if the record has tasks */}
                {record && Object.keys(record).length > 0 ? (
                  // Render the appropriate icon based on the expanded state
                  expandedInnerRow === Object.keys(record)[0] ? (
                    <UpOutlined
                      style={{
                        cursor: 'pointer',
                        color: '#0B4266',
                        fontSize: '16px',
                      }}
                      onClick={() => handleToggleInnerRowExpand(record)}
                    />
                  ) : (
                    <DownOutlined
                      style={{
                        cursor: 'pointer',
                        color: '#0B4266',
                        fontSize: '16px',
                      }}
                      onClick={() => handleToggleInnerRowExpand(record)}
                    />
                  )
                ) : null}
              </div>
            ),
          }  
        ];
        return column;
      };
    
    const innerColumn: ColumnsType<Task> = [
      {
        title: 'Sl.no',
        className: 'ant-table-column-title',
        dataIndex: 'slNo',
        key: 'slNo',
        fixed: 'left',
        render: (_, __, index) => <span>{index + 1}</span>,
      },  
      {
        title: 'Task',
        sorter: (a: Task, b: Task) => {
          return a.task.localeCompare(b.task);
        },
        dataIndex: 'task',
        key: 'task',
        fixed: 'left',
      },
      {
        title: 'Start Time',
        sorter: (a: Task, b: Task) => {
          return a.startTime.localeCompare(b.startTime);
        },
        dataIndex: 'startTime',
        key: 'startTime',
        fixed: 'left',
      },
      {
        title: 'End Time',
        sorter: (a: Task, b: Task) => {
          return a.endTime.localeCompare(b.endTime);
        },
        dataIndex: 'endTime',
        key: 'endTime',
        fixed: 'left',
      },
      {
        title: 'Total Hours',
        sorter: (a: Task, b: Task) => {
          return a.totalHours.localeCompare(b.totalHours);
        },
        dataIndex: 'totalHours',
        key: 'totalHours',
        fixed: 'left',
      },
      {
        title: 'Description',
        sorter: (a: Task, b: Task) => {
          return a.description.localeCompare(b.description);
        },
        dataIndex: 'description',
        key: 'description',
        fixed: 'left',
      },
    ];
    
    const columns: ColumnsType<GroupedTasks> = [
      {
        title: 'Sl.no',
        className: 'ant-table-column-title',
        dataIndex: 'slNo',
        key: 'slNo',
        fixed: 'left',
        render: (_, __, index) => <span>{index + 1}</span>,
      },    
      {
        title: "Employee",
        className: ' ant-table-column-title',
        dataIndex: "tasks",
        render: (tasks: { [date: string]: { key: string; tasks: Task[] } }) => {
          const userId = tasks[Object.keys(tasks)[0]].tasks[0]?.userId || '';
          return (
            <Space className="flex gap-5">
              <Avatar icon={<UserOutlined />} size={45} />
              <div>
                <div>
                  <strong>Sasi Kumar</strong>
                </div>
                <div>{userId}</div>
              </div>
            </Space>
          );
        },
        sorter: (a: GroupedTasks, b: GroupedTasks) => {
          const userIdA = a.tasks[Object.keys(a.tasks)[0]].tasks[0]?.userId || '';
          const userIdB = b.tasks[Object.keys(b.tasks)[0]].tasks[0]?.userId || '';
          return userIdA.localeCompare(userIdB);
        },
      },          
      {
        title: 'Month',
        sorter: (a, b) => a.month.localeCompare(b.month),
        className: 'ant-table-column-title',
        dataIndex: 'month',
        key: 'month',
        fixed: 'left',
      },
      {
        title: 'Requested On',
        className: 'ant-table-column-title',
        dataIndex: 'tasks',
        key: 'date',
        fixed: 'left',
        render: (tasks: { [date: string]: Task[] }) => {
          const dates = Object.keys(tasks);
          const earliestDate = dates.length > 0 ? dates.sort()[0] : null;
          const formattedDate = earliestDate ? moment(earliestDate).format('YYYY-MM-DD') : '';
          return formattedDate;
        },
      },        
      {
        title: 'Days Filled',
        className: 'ant-table-column-title',
        dataIndex: 'daysFilled',
        key: 'daysFilled',
        render: (daysFilled, record) => {
          const dateKeysFilled = Object.keys(record.tasks).length;
          return (
            <span>{`${dateKeysFilled} / ${record.totalDaysInMonth}`}</span>
          );
        },
        sorter: (a: GroupedTasks, b: GroupedTasks) => Object.keys(a.tasks).length - Object.keys(b.tasks).length,
      },    
      {
        title: ' ',
        dataIndex: 'actions',
        key: 'actions',
        render: (_, record, index) => (
          <div>
            {expandedRow === record.month ? (
              <UpOutlined
                style={{
                  cursor: 'pointer',
                  color: '#0B4266',
                  fontSize: '16px',
                }}
                onClick={(event) => handleToggleRowExpand(record, event)}
              />            
            ) : (
              <DownOutlined
                style={{
                  cursor: 'pointer',
                  color: '#0B4266',
                  fontSize: '16px',
                }}
                onClick={(event) => handleToggleRowExpand(record, event)}
              />
            )}
          </div>
        )
      }
    ];
  
    const expandable: ExpandableConfig<GroupedTasks> = {
      expandedRowRender: (record: GroupedTasks) => {
        const taskHours: { [key: string]: number } = {};
        for (const dateKey in record.tasks) {
          record.tasks[dateKey].tasks.forEach(task => {
            if (taskHours.hasOwnProperty(task.task)) {
              taskHours[task.task] += parseFloat(task.totalHours || '0');
            } else {
              taskHours[task.task] = parseFloat(task.totalHours || '0');
            }
          });
        }
        
        // After calculating the total hours for each task, convert them to fixed decimals
        for (const taskName in taskHours) {
          if (taskHours.hasOwnProperty(taskName)) {
            taskHours[taskName] = parseFloat(taskHours[taskName].toFixed(2));
          }
        }
        
        const totalHours = Math.floor(Object.values(taskHours).reduce((acc, curr) => acc + curr, 0));
        const regularHours = Math.min(totalHours, 9);
        const extraHours = totalHours - regularHours;
    
        if (expandedRow === record.month) {
          return (
            <div>
              <ul style={{ display: 'flex', justifyContent: 'space-around', listStyle: 'none' }}>
                {Object.entries(taskHours).map(([taskName, taskTotalHours], index) => (
                  <div key={index} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
                    <div style={{ paddingRight: '20px' }}>
                      <div style={{ color: 'grey', paddingBottom: '5px' }}>
                        {taskName}
                      </div>
                      <div style={{ fontWeight: "bold", fontSize: '20px', color: 'black' }}>
                        {taskTotalHours}H
                      </div>
                    </div>
                    <div>
                      <Progress
                        type="circle"
                        percent={Math.round((taskTotalHours / 9) * 100)} // Ensure it's an integer
                        width={60}
                      />
                    </div>
                  </div>
                ))}
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
                  <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                    Extra Hours
                  </div>
                  <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: "bold", fontSize: '20px' }}>
                    {extraHours}H
                  </div>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
                  <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                    Total Hours
                  </div>
                  <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: 'bold', fontSize: '20px' }}>
                    {totalHours}H
                  </div>
                </div>
              </ul>
            </div>
          );
        }
        return null;
      },
      expandRowByClick: true,
      //expandIcon: () => null
    };
    
    
    const aggregatedData: GroupedTasks[] = Object.keys(groupedTasks).map((monthKey: string) => {
      const monthData = groupedTasks[monthKey];
      const monthTasks: { [date: string]: { key: string; tasks: Task[] } } = {};
      let daysFilled = 0;
      for (const dateKey in monthData.tasks) {
        if (Object.keys(monthData.tasks[dateKey].tasks).length > 0) {
          monthTasks[dateKey] = monthData.tasks[dateKey];
          daysFilled++;
        }
      }
      const totalDaysInMonth = monthData.totalDaysInMonth;
      console.log("aggregatedData", monthData);
      return {
        key: monthData.key,
        month: monthData.month,
        tasks: monthTasks,
        daysFilled: daysFilled,
        totalDaysInMonth: totalDaysInMonth
      };
    });
  
    const flattenedData = (groupedTasks: TaskObject) => {
      const tasks: TaskObject[] = [];
      const keys = Object.keys(groupedTasks);
      console.log("keys", keys);
      // Iterate over each key
      keys.forEach(key => {
          // Find the monthData corresponding to the current key
          const groupedData = groupedTasks[key];
          console.log("monthdata", groupedData);
          if (groupedData) {
              // Convert monthData into TaskObject
              const taskObject: TaskObject = {
                  [key]: {
                      key: groupedData.key,
                      tasks: groupedData.tasks
                  }
              };
              tasks.push(taskObject);
          }
      });
  
      return tasks;
  };
  
    const handleRowClick = (
      record: TaskObject,
      formattedMonth: string,
      event: React.MouseEvent<HTMLElement>
    ) => {
      console.log('handleRowClick record', record);
      const tasksForClickedMonth: TaskObject[] = flattenedData(
        record
      );
    
      // Set the month tasks in the state
      setMonthTasks(tasksForClickedMonth);
      console.log("tasksForClickedMonth",tasksForClickedMonth);
      // Set the modal content and make the modal visible
      setModalContent(
        <div>
          <Table
          rowSelection={{
            type: 'checkbox',
            selectedRowKeys: selectedInnerRows,
            ...rowSelection,
            onChange(selectedRowKeys, selectedRows, info) {
                console.log(selectedRowKeys,selectedRows,info)
            },          
          }}          
            style={{
              backgroundColor: 'white',
              border: '1px solid grey',
              borderRadius: '5px',
            }}
            columns={getColumn(formattedMonth)} 
            rowClassName="rowstyle"
            dataSource={tasksForClickedMonth} // Pass the tasks for the clicked month here
            pagination={false}
            expandable={{
              expandedRowRender: (record: TaskObject) => {
                const handleInnerRowExpand = (dateKey: string) => {
                  const tasksForDate = record[dateKey]?.tasks || [];
                  return (
                    <Table
                      columns={innerColumn as ColumnsType<Task>}
                      dataSource={tasksForDate}
                      pagination={false}
                    />
                  );
                };
              
                return (
                  <>
                    {Object.keys(record).map(dateKey => (
                      <div key={dateKey}>
                        <div>Date: {dateKey}</div>
                        {handleInnerRowExpand(dateKey)}
                      </div>
                    ))}
                  </>
                );
              },
              
    
              expandRowByClick: true,
              expandIcon: () => null,
            }}
          />
        </div>
      );
      // Set the modal content and make the modal visible
      setModalVisible(true);
    
      // Prevent event propagation
      event.stopPropagation();
    };
     
  return (
    <DashboardLayout>
      <div>
        <Table
           rowSelection={{
            type: 'checkbox',
            selectedRowKeys: selectedRows,
            onChange: handleRowSelection,
            getCheckboxProps: (record: GroupedTasks) => ({
              // Use the `key` field as the identifier for row selection
              key: record.key,
              disabled: false, // You can adjust these additional props as needed
            }),
          }}   
          onRow={(record: GroupedTasks) => ({
            onClick: (event: React.MouseEvent<HTMLElement>) => {
              const userId = record.tasks[Object.keys(record.tasks)[0]].tasks[0]?.userId;
              setSelectedUserId(userId); // Set the userId in state
              // Extract necessary data from the GroupedTasks record
              const monthYear = record.month;
              const [monthName, year] = monthYear.split(' ');
              const monthNumber = moment().month(monthName).format('MM');
              const formattedMonth = `${year}-${monthNumber}`;
              // Convert GroupedTasks record into TaskObject
              const tasksObject: TaskObject = record.tasks;
              console.log("onRow-tasksObject", tasksObject);
              console.log("taskObject", tasksObject);
              const tasksForClickedMonth: TaskObject[] = flattenedData(
                tasksObject
              );
              console.log("onRow-tasksForClickedMonth", tasksForClickedMonth);
              setMonthTasks(tasksForClickedMonth);
              // Pass TaskObject and formattedMonth to handleRowClick
              //handleRowClick(tasksObject, formattedMonth, event);
              navigate(`/monthtasks?formattedMonth=${formattedMonth}&userId=${userId}`, {state: {
                formattedMonth: formattedMonth,
                userId: userId,
                tasksObject: tasksObject,
                tasksForClickedMonth: tasksForClickedMonth,
            }});
            },
          })}
          
          style={{ backgroundColor: 'white' }}
          columns={columns}
          dataSource={aggregatedData}
          pagination={false}
          //expandable={expandable}
          expandable={{
            expandedRowRender: expandable.expandedRowRender,
            expandRowByClick: false,
            // expandIcon: ({ expanded, onExpand, record }) => (
            //   expanded ? 
            //     <UpOutlined onClick={(event) => onExpand(record, event)} /> :
            //     <DownOutlined onClick={(event) => onExpand(record, event)} />
            // ),
          }}  
        />
      </div>
      <Modal
        title={
          modalContent ? (
            <div>
              <Space className="flex gap-5">
                <Avatar icon={<UserOutlined />} size={45} />
                <div>
                  <div>
                    <strong>Sasi Kumar</strong>
                  </div>
                  {/* Displaying the userId */}
                  <div>{selectedUserId}</div>
                </div>
              </Space>
            </div>
          ) : null
        }
        visible={modalVisible}
        onCancel={() => setModalVisible(false)}
        footer={null}
        width="80%"
      >
        {modalContent}
        <div style={{display:'flex', justifyContent:'flex-end', margin:"10px 20px"}}>
          <Button style={{width:'10%', backgroundColor:'green', color:'white'}} onClick={handleApprove}>Approve</Button>
          <Button style={{ width: '10%', backgroundColor: 'red', color: 'white' }} onClick={handleReject}>
            Reject
          </Button>
          <Modal
            title="Comments"
            className='modalTitle'
            visible={commentVisible}
            onCancel={handleCancel}
            footer={[
              // <Button key="cancel" onClick={handleCancel}>
              //   Cancel
              // </Button>,
              <Button style={{ width: '20%', backgroundColor: '#0B4266', color: 'white' }} key="submit" type="primary" onClick={handleSubmit}>
                Submit
              </Button>,
            ]}
          >
            <Input.TextArea placeholder='Write here...' rows={4} value={comments} onChange={handleInputChange} />
          </Modal>
        </div>
      </Modal>
    </DashboardLayout>
  );
  
}

export default ApprovalRequest





new 
AddTask.tsx

import React, { useState, useEffect, useCallback } from 'react';
import { Input, TimePicker, Select, notification, DatePicker} from 'antd';
import { SearchOutlined } from '@mui/icons-material';
import dayjs from 'dayjs';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { useMsal } from '@azure/msal-react';
import '../Styles/CreateUser.css';
import DashboardLayout from './Layout';
import { v4 as uuidv4 } from 'uuid';
import '../Styles/AddTask.css';
import {Table} from 'antd';
import { ColumnsType } from "antd/es/table";
import ApprovalRequest from './ApprovalRequest';
import { EditOutlined, DeleteOutlined,CloseCircleOutlined,LeftOutlined, RightOutlined } from '@ant-design/icons';
import Dashboard from './Dashboard';

// Define an interface for the state
export interface ApprovalRequestsState {
  key: string;
  date: string;
  tasks: Task[];
}

// Make ApprovalRequestsState an array
export type ApprovalRequestsStateArray = ApprovalRequestsState[];

export interface Task {
  key?:string;
  idx: number; // Add this line
  date: string;
  userId: string;
  task: string;
  startTime: string;
  endTime: string;
  totalHours: string;
  description: string;
  reportingTo: string;
  slNo?: number;
}

type AddTaskProps = {
  setPieChartData: React.Dispatch<React.SetStateAction<{ [key: string]: number }>>;
  setApprovalRequestsData: React.Dispatch<React.SetStateAction<ApprovalRequestsStateArray>>;
  approvalRequestsData:ApprovalRequestsStateArray;
};

const AddTask: React.FC<AddTaskProps> = ({ setPieChartData, setApprovalRequestsData }) => {
  const navigate = useNavigate();
  const [deletedTask, setDeletedTask] = useState(false);
  const [formWidth, setFormWidth] = useState(800);
  const [currentDate, setCurrentDate] = useState(dayjs());
  const [currentWeek, setCurrentWeek] = useState(dayjs().startOf('week'));
  const [currentMonth, setCurrentMonth] = useState(dayjs().startOf('month'));
  const [isFormEnabled, setIsFormEnabled] = useState(false);
  const [addTask, setAddTask] = useState<Task>({
    idx: 1, // Set initial idx
    date: currentDate.format('YYYY-MM-DD'),
    userId: '123',
    task: '',
    startTime: '',
    endTime: '',
    totalHours: '',
    description: '',
    reportingTo: '',
  });
  const [deletedTaskIdx, setDeletedTaskIdx] = useState<number | null>(null);
  const [taskList, setTaskList] = useState<Task[]>([]);
  const [filteredTasks, setFilteredTasks] = useState<Task[]>([]);
  const reportingOptions = ['ManagerA', 'ManagerB', 'ManagerC'];
  const taskOptions = ['Task','Project','Learning','Training','Meeting'];
  const [filterOption, setFilterOption] = useState('Date');
  const [isEdited, setIsEdited]= useState<boolean>(false);
  // State to manage the search input
  const [searchInput, setSearchInput] = useState('');
  const [isFormSubmitted, setIsFormSubmitted] = useState(false);
 const updateSlNo = (tasks: Task[], deleteTask: boolean): Task[] => {
  return tasks.map((task, index) => ({
    ...task,
    slNo: index + 1,
    idx: deleteTask ? index + 1 : task.idx
  }));
};

  useEffect(() => {
    const updateFormWidth = () => {
      const formElement = document.getElementById('myForm');
      if (formElement) {
        const newWidth = formElement.offsetWidth;
        setFormWidth(newWidth);
      }
    };

    window.addEventListener('resize', updateFormWidth);
    updateFormWidth();

    return () => {
      window.removeEventListener('resize', updateFormWidth);
    };
  }, []);

  const borderStyle = {
    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)', // Add box shadow
    margin: '10px 20px',
   // padding: '10px 20px',
    width: formWidth + 'px',
  };
  
  const handleInputChange = (field: keyof Task, value: string) => {
    if (field === 'date') {
      const selectedDate = dayjs(value);
      if (selectedDate.isAfter(dayjs(), 'day')) {
        // Display a notification
        notification.warning({
          message: 'Warning',
          description: 'Cannot select a future date.',
        });
        // Set the selected date to today
        setCurrentDate(dayjs());
      } else {
        // Update the state with the selected date
        setCurrentDate(selectedDate);
      }
    }
  
    // Keep userId constant
    if (field === 'userId') {
      setAddTask((prevTask) => ({ ...prevTask, [field]: value }));
    } else {
      // Update startTime or endTime with the new value
      const updatedTime = value || dayjs().format('hh:mm A');
      setAddTask((prevTask) => ({ ...prevTask, [field]: updatedTime }));
      // Calculate the duration and update totalHours
      const updatedStartTime = field === 'startTime' ? updatedTime : addTask.startTime || dayjs().format('hh:mm A');
      const updatedEndTime = field === 'endTime' ? updatedTime : addTask.endTime || dayjs().format('hh:mm A');
      const duration = dayjs(updatedEndTime, 'hh:mm A').diff(dayjs(updatedStartTime, 'hh:mm A'), 'hour', true);
      setAddTask((prevTask) => ({
        ...prevTask,
        startTime: field === 'startTime' ? updatedTime : addTask.startTime,
        endTime: field === 'endTime' ? updatedTime : addTask.endTime,
        totalHours: duration.toFixed(2),
      }));
    }
  };
  
  useEffect(() => {
    const storedTaskListString = localStorage.getItem('taskList');
    const storedTaskList = storedTaskListString ? JSON.parse(storedTaskListString) : [];

    // Assuming deletedTask is a state variable
    const updatedTaskList = updateSlNo(storedTaskList, deletedTask);

    setTaskList(updatedTaskList);
    setFilteredTasks(updatedTaskList);
  }, [deletedTask]); // Include deletedTask in the dependency array

  useEffect(() => {
    // Filter tasks based on the addTask.date when it changes
    if (addTask.date) {
      const filtered = taskList.filter(task => task.date === addTask.date);
      setFilteredTasks(updateSlNo(filtered, deletedTask)); // Update slNo when loading tasks
    } else {
      // If no date is selected, display all tasks
      setFilteredTasks(updateSlNo(taskList, deletedTask)); // Update slNo when loading tasks
    }
  }, [addTask.date, taskList]);

  useEffect(() => {
    // Update addTask with the current date
    if (!isEdited) {
      // Update addTask with the current date only when not in edit mode
      setAddTask((prevAddTask) => ({
        ...prevAddTask,
        date: dayjs(currentDate).format('YYYY-MM-DD'),
    }));
  }
    //setFilteredTasks(taskList);
    // Filter tasks based on the filterOption and currentDate when they change
    let filtered: Task[] = [];

    if (searchInput) {
      // If there is a search input, filter tasks based on date or month
      const searchDate = dayjs(searchInput);
      filtered = taskList.filter((task) => {
        if (filterOption === 'Date') {
          return dayjs(task.date).isSame(searchDate, 'day');
        } else if (filterOption === 'Week') {
          const startOfWeek = currentWeek.startOf('week');
          const endOfWeek = currentWeek.endOf('week');
          return (
            (dayjs(task.date).isSame(startOfWeek) || dayjs(task.date).isAfter(startOfWeek)) &&
            (dayjs(task.date).isSame(endOfWeek) || dayjs(task.date).isBefore(endOfWeek))
          );
        } else if (filterOption === 'Month') {
          // Format the searchInput in the same way as the task date
          const formattedSearchMonth = searchDate.format('MMMM');
          return dayjs(task.date).format('MMMM') === formattedSearchMonth;
        }
        return false;
      });
    }  else {
      // If no search input, apply the regular filtering based on filterOption and currentDate
      if (filterOption === 'Date') {
        filtered = taskList.filter((task) => task.date === dayjs(currentDate).format('YYYY-MM-DD'));
        console.log("useEffect-date", filtered)
      } else if (filterOption === 'Week') {
        const startOfWeek = currentWeek.startOf('week');
        const endOfWeek = currentWeek.endOf('week');
        filtered = taskList.filter(
          (task) =>
            (dayjs(task.date).isSame(startOfWeek) || dayjs(task.date).isAfter(startOfWeek)) &&
            (dayjs(task.date).isSame(endOfWeek) || dayjs(task.date).isBefore(endOfWeek))
        );
        console.log("useeffect-week", filtered);
      } else if (filterOption === 'Month') {
        const startOfMonth = currentMonth.startOf('month');
        const endOfMonth = currentMonth.endOf('month');
        filtered = taskList.filter(
          (task) =>
            (dayjs(task.date).isSame(startOfMonth) || dayjs(task.date).isAfter(startOfMonth)) &&
            (dayjs(task.date).isSame(endOfMonth) || dayjs(task.date).isBefore(endOfMonth))
        );
        console.log("useeffect", filtered);
      }
    }

    setFilteredTasks(updateSlNo(filtered, deletedTask));
  //  console.log("useeffect filtered-task", filteredTasks);
  }, [isEdited, filterOption, currentDate, currentMonth, currentWeek, taskList, searchInput]);

  const handleFilterChange = (value: any) => {
    setFilterOption(value);
  };

  const handleLeftArrowClick = () => {
    if (filterOption === 'Date') {
      console.log("handleLeftArrowClick -prev", currentDate);
      const previousDate = currentDate.subtract(1, 'day');
      console.log("handleLeftArrowClick previousDate",previousDate)
      setCurrentDate(previousDate);

    } else if (filterOption === 'Week') {
      const previousWeekStart = currentWeek.subtract(1, 'week').startOf('week');
      const previousWeekEnd = currentWeek.subtract(1, 'week').endOf('week');
      setCurrentWeek(previousWeekStart);
      console.log("previousWeek",previousWeekStart)
    } else if (filterOption === 'Month') {
      const previousMonthStart = currentMonth.subtract(1, 'month').startOf('month');
      const previousMonthEnd = currentMonth.subtract(1, 'month').endOf('month');
      setCurrentMonth(previousMonthStart);
    }
  };

  const handleRightArrowClick = () => {
    if (filterOption === 'Date') {
      const nextDate = currentDate.add(1, 'day');
      if(nextDate.isAfter(dayjs(), 'day')){
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future weeks.',
        });
        return;
      }
      setCurrentDate(nextDate);
    } else if (filterOption === 'Week') {
      const nextWeekStart = currentWeek.add(1, 'week').startOf('week');
      const nextWeekEnd = currentWeek.add(1, 'week').endOf('week');
      if (nextWeekStart.isAfter(dayjs(), 'day')) {
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future weeks.',
        });
        return;
      }
      setCurrentWeek(nextWeekStart);
      
    } else if (filterOption === 'Month') {
      const nextMonthStart = currentMonth.add(1, 'month').startOf('month');
      if (nextMonthStart.isAfter(dayjs(), 'day')) {
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future months.',
        });
        return;
      }
      setCurrentMonth(nextMonthStart);
    }
    
  };

  const handleToggleForm = () => {
    setIsFormEnabled((prevIsFormEnabled) => !prevIsFormEnabled);
  
    // If you want to reset the form when disabling it, you can reset the form state here
    if (!isFormEnabled) {
      setAddTask({
        date: dayjs(currentDate).format('YYYY-MM-DD'),
        userId: '123',
        task: '',
        startTime: '',
        endTime: '',
        totalHours:'',
        description: '',
        reportingTo: '',
        idx: addTask.idx,
      });
    }
  };

  const handleFormSubmit = () => {
    console.log("---fd1", dayjs(addTask.date).format('YYYY-MM-DD'), dayjs(addTask.startTime).format('hh:mm A'), dayjs(addTask.endTime).format('hh:mm A'));
    // Check for overlapping tasks in the specified time range
    const overlappingTask = taskList.find((task) => {
      const newTaskStartTime = dayjs(addTask.startTime, 'hh:mm A');
      const newTaskEndTime = dayjs(addTask.endTime, 'hh:mm A');
      const taskStartTime = dayjs(task.startTime, 'hh:mm A');
      const taskEndTime = dayjs(task.endTime, 'hh:mm A');
    
      // Check if the new task overlaps with any existing task
      return (
        !isEdited && task.date === addTask.date &&
        (
          ((newTaskStartTime.isSame(taskStartTime) || newTaskStartTime.isAfter(taskStartTime))&& newTaskStartTime.isBefore(taskEndTime)) ||
          ((newTaskEndTime.isSame(taskStartTime) || newTaskEndTime.isAfter(taskStartTime))&& newTaskEndTime.isBefore(taskEndTime)) ||
          (newTaskStartTime.isBefore(taskStartTime) && (newTaskEndTime.isSame(taskEndTime)|| newTaskEndTime.isAfter(taskEndTime)))
        )
      );
    });
      
    if (overlappingTask) {
      notification.warning({
        message: 'Restricted',
        description: 'Task already exists in the specified time range.',
      });
      return;
    }

    if (isEdited) {
      // If editing, update the existing task
      const updatedTaskList = taskList.map((task) =>
        task.idx === addTask.idx ? { ...addTask } : task
      );
      setTaskList(updatedTaskList);
      setFilteredTasks(updateSlNo(updatedTaskList, deletedTask));
      localStorage.setItem('taskList', JSON.stringify(updatedTaskList));
      setIsEdited(false);
    } else {
      // Update the taskList
      const updatedTaskList = [...taskList, { ...addTask, idx: taskList.length + 1 }];
      setTaskList(updatedTaskList);
      setFilteredTasks(updateSlNo(updatedTaskList, deletedTask));
      localStorage.setItem('taskList', JSON.stringify(updatedTaskList));
    }
  
    // Clear the form with the default date and reset idx
    setAddTask({
      idx: taskList.length + 2, // Set a new idx
      date: dayjs(currentDate).format('YYYY-MM-DD'),
      userId: '123',
      task: '',
      startTime: '',
      endTime: '',
      totalHours: '',
      description: '',
      reportingTo: '',
    });
    setIsEdited(false);
    setIsFormSubmitted(true);
  };

  const handleClearSubmit = () => {
    // Clear the form with the default date and set idx
    setAddTask({
      date: dayjs(addTask.date).format('YYYY-MM-DD'),
      userId: '123',
      task: '',
      startTime: '',
      endTime: '',
      totalHours:'',
      description: '',
      reportingTo: '',
      idx: addTask.idx 
    });
  }
  
  const handleEditTask = (idx: number) => {
    // Implement the logic to edit the task based on date, startTime, and endTime
    // You can use the setAddTask function to update the form fields with the selected task's details
    setIsEdited(true);
    const taskToEdit = taskList.find((task) => task.idx === idx);
    if (taskToEdit) {
      setAddTask({
        date: taskToEdit.date,
        userId: taskToEdit.userId,
        task: taskToEdit.task,
        startTime: taskToEdit.startTime,
        endTime: taskToEdit.endTime,
        totalHours: taskToEdit.totalHours,
        description: taskToEdit.description,
        reportingTo: taskToEdit.reportingTo,
        idx: taskToEdit.idx, 
      });

      // Now, you can perform additional actions or display a modal for editing
      setCurrentDate(dayjs(taskToEdit.date));
    }
  };
  
  const handleDeleteTask = useCallback((idx: number) => {
    // Toggle the deletedTask flag
    setDeletedTask(true);
    // Save idx in state
    setDeletedTaskIdx(idx);
  }, []);

  useEffect(() => {
    if (deletedTask) {
      // Implement the logic to delete the task based on idx
      const updatedTaskList = taskList.filter((task) => task.idx !== deletedTaskIdx);

      // Reindex the idx starting from 1 and use deletedTask flag
      const reindexedTaskList = updateSlNo(updatedTaskList, deletedTask);

      setTaskList(reindexedTaskList);
      setFilteredTasks(reindexedTaskList);

      // Update localStorage
      localStorage.setItem('taskList', JSON.stringify(reindexedTaskList));

      // Reset the deletedTask flag after updating
      setDeletedTask(false);
    }
  }, [deletedTask, deletedTaskIdx]);

  // const handleOverallSubmit = () => {
  //   // Assuming you have an API endpoint for approval requests
  //   //const apiUrl = 'http://localhost:3000/approvalrequests';

  //   // Prepare the data to be sent
  //   const requestData = filteredTasks.map(task => ({
  //     date: task.date,
  //     userId: task.userId,
  //     task: task.task,
  //     startTime: task.startTime,
  //     endTime: task.endTime,
  //     totalHours: task.totalHours,
  //     description: task.description,
  //     reportingTo: task.reportingTo,
  //     idx: task.idx,
  //   }));
  //   // Navigate to the approvalrequests component with the data
  //   navigate('/approvalrequests', { state: { requestData } });
  //   // Make the HTTP POST request to the /approvalrequests endpoint
  //   // fetch(apiUrl, {
  //   //   method: 'POST',
  //   //   headers: {
  //   //     'Content-Type': 'application/json',
  //   //   },
  //   //   body: JSON.stringify(requestData),
  //   // })
  //   //   .then(response => {
  //   //     if (!response.ok) {
  //   //       console.log("network response was not okay");
  //   //       throw new Error('Network response was not ok');
          
  //   //     }
  //   //     return response.json();
  //   //   })
  //   //   .then(data => {
  //   //     // Handle the success response from the server
  //   //     console.log('Submission successful:', data);
  //   //     // You may want to show a success message or redirect the user
  //   //     // Show success notification
  //   //     notification.success({
  //   //       message: 'Submission Successful',
  //   //       description: 'Task details submitted successfully!',
  //   //     });
  //   //   })
  //   //   .catch(error => {
  //   //     // Handle errors during the fetch
  //   //     console.error('Error during submission:', error);
  //   //     // Show error notification
  //   //     notification.error({
  //   //       message: 'Submission Failed',
  //   //       description: 'There was an error submitting the task details.',
  //   //     });
  //   //     // You may want to show an error message to the user
  //   //   });
  // };

  const handleOverallSubmit = () => {
    // Generate a UUID for the key
    const key = uuidv4();

    // Prepare the data to be sent
    const requestData: ApprovalRequestsStateArray = filteredTasks.map(task => ({
        key: key,
        date: task.date,
        tasks: [{
            key: task.key ?? '', // Use task.key if it exists, otherwise use an empty string
            idx: task.idx,
            date: task.date,
            userId: task.userId,
            task: task.task,
            startTime: task.startTime,
            endTime: task.endTime,
            totalHours: task.totalHours,
            description: task.description,
            reportingTo: task.reportingTo,
        }]
    }));

    // Set the success notification
    notification.success({
        message: 'Submission Successful',
        description: 'Task details submitted successfully!',
    });

    // Navigate to the approval requests page
    navigate('/approvalrequests');

    // Set the approvalRequestsData state
    setApprovalRequestsData(requestData);

    // Store the approvalRequestsData in local storage
    localStorage.setItem('approvalRequestsData', JSON.stringify(requestData));
};




  const columns: ColumnsType<Task> = [
    {
      title: 'Sl.no',
      sorter: (a: Task, b: Task) => (a.slNo && b.slNo ? a.slNo - b.slNo : 0),
      dataIndex: 'slNo',
      key: 'slNo',
      fixed: 'left',
    },
    {
      title: 'Task',
      sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
      dataIndex: 'task',
      key: 'task',
      fixed: 'left',
    },
    {
      title: 'Date',
      sorter: (a: Task, b: Task) => a.date.localeCompare(b.date),
      dataIndex: 'date',
      key: 'date',
      fixed: 'left',
    },
    {
      title: 'Start Time',
      sorter: (a: Task, b: Task) => a.startTime.localeCompare(b.startTime),
      dataIndex: 'startTime',
      key: 'startTime',
      fixed: 'left',
    },
    {
      title: 'End Time',
      sorter: (a: Task, b: Task) => a.endTime.localeCompare(b.endTime),
      dataIndex: 'endTime',
      key: 'endTime',
      fixed: 'left',
    },
    {
      title: 'Total Hours',
      sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
      dataIndex: 'totalHours',
      key: 'totalHours',
      fixed: 'left',
    },
    {
      title: 'Description',
      sorter: (a: Task, b: Task) => a.description.localeCompare(b.description),
      dataIndex: 'description',
      key: 'description',
      fixed: 'left',
    },
    {
      title: 'Reporting To',
      sorter: (a: Task, b: Task) => a.reportingTo.localeCompare(b.reportingTo),
      dataIndex: 'reportingTo',
      key: 'reportingTo',
      fixed: 'left',
    },
    
    {
      title: 'Actions',
      dataIndex: 'actions',
      key: 'actions',
      render: (_, record, index) => (
        <div>
          <EditOutlined
            onClick={() => handleEditTask(record.idx)}
            style={{
              marginRight: '8px',
              cursor: 'pointer',
              color: 'blue',
              fontSize: '20px',
            }}
          />
          <DeleteOutlined
            onClick={() => handleDeleteTask(record.idx)}
             style={{
              cursor: 'pointer',
              color:  'red',
              fontSize: '20px',
            }}
          />
        </div>
    )}
  ]

  return (
    <DashboardLayout>
      <div className='createuser-main'>
        <div className='header'>
          <div>
            <h1>Add Task</h1>
          </div>
          { filterOption === 'Month' ? (
            <div style={{display:'flex', justifyContent:'flex-end'}}>
              <div className='date'>From: {dayjs(currentMonth).format('YYYY-MM-DD')}</div>
              <div className='date' style={{ marginLeft: '40px' }}>To: {dayjs(currentMonth).endOf('month').format('YYYY-MM-DD')}</div>
            </div>
            ) : filterOption === 'Week' ? (
              <div style={{display:'flex', justifyContent:'flex-end'}}>
                <div className='date'>From: {dayjs(currentWeek).format('YYYY-MM-DD')}</div>
                <div className='date' style={{ marginLeft: '40px' }}>To: {dayjs(currentWeek).endOf('week').format('YYYY-MM-DD')}</div>
              </div>
            )  : (
              <div className='date'>Date: {currentDate.format('YYYY-MM-DD')}</div>
            )
          }
        </div>
        {(filterOption === 'Date' || ((filterOption === 'Week' || filterOption === 'Month') && isEdited)) || isFormEnabled  ? ( <form id="myForm" style={borderStyle}>
            <div>
            {isFormEnabled && (
              <CloseCircleOutlined
                style={{ margin: '10px 20px', display: 'flex', justifyContent: 'flex-end', color: 'red' }}
                onClick={handleToggleForm} // Call the handleToggleForm function on click
              />
            )}
              <div className='section-addtask'>
              <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label htmlFor='addTaskID'>Date</label>
                  </div>
                  {/* <input
                    type="date"
                    style={{ width: '100%' }}
                    className='timepicker'
                  /> */}
                  <Input
                    type='date'
                    placeholder='Enter your Employee ID'
                    value={currentDate.format('YYYY-MM-DD')} 
                    onChange={(e) => handleInputChange('date', e.target.value)}
                  />
                </div>
                {/* <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label htmlFor='addTaskID'>User ID</label>
                  </div>
                  <Input
                    placeholder='Enter your Employee ID'
                    value={addTask.userId}
                    onChange={(e) => handleInputChange('userId', e.target.value)}  
                  />
                </div> */}
                 <div className='create-layout-addtask'>
                  <div>
                    <label htmlFor='task'>Task</label>
                  </div>
                  <div>
                    <select
                      id='task'
                      value={addTask.task}
                      onChange={(e) => handleInputChange('task', e.target.value)}
                    >
                      {taskOptions.map((option) => (
                          <option key={option} value={option}>
                            {option}
                          </option>
                        ))}
                    </select>
                  </div>
                </div>
              </div>
              <div className='section-addtask'>
                <div className='create-layout-addtask-left'>
                  <div>
                    <label htmlFor='startTime'>Start Time</label>
                  </div>
                  <TimePicker
                    value={
                      addTask.startTime
                        ? dayjs(addTask.startTime, 'hh:mm A') // Convert to dayjs here
                        : null
                    }
                    onChange={(time, timeString) =>
                      handleInputChange('startTime', timeString)
                    }
                    className='timepicker'
                    format='hh:mm A' // Set the format to include AM/PM
                  />
                </div>
                <div className='create-layout-addtask'>
                  <div>
                    <label htmlFor='endTime'>End Time</label>
                  </div>
                  <TimePicker
                    value={
                      addTask.endTime
                        ? dayjs(addTask.endTime, 'HH:mm A') // Convert to dayjs here
                        : null
                    }
                    onChange={(time, timeString) =>
                      handleInputChange('endTime', timeString)
                    }
                    className='timepicker'
                    format='hh:mm A' 
                    rootClassName='timer'
                  />
                </div>
              </div>
              <div className='section-addtask'>
                
              <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label htmlFor='totalHours'>Total Hours</label>
                  </div>
                  <Input
                    placeholder='Enter your Total Hours'
                    value={addTask.totalHours}
                    onChange={(e) => handleInputChange('totalHours', e.target.value)}
                    
                  />
                </div>
                <div className='create-layout-addtask-reportingTo  '>
                  <div className='create-layout-reportingTo'>
                    <label htmlFor='reportingTo'>Reporting To</label>
                  </div>
                  <select
                    id='reportingTo-addtask'
                    value={addTask.reportingTo}
                    onChange={(e) => handleInputChange('reportingTo', e.target.value)}
                  >
                    <option value=''>Select Reporting To</option>
                    {reportingOptions.map((option) => (
                      <option key={option} value={option}>
                        {option}
                      </option>
                    ))}
                  </select>
                </div> 
              </div>  
              <div>
                <div className='create-layout-description'>
                  <div>
                    <label>Description</label>
                  </div>
                  <textarea
                    value={addTask.description}
                    onChange={(e) => handleInputChange('description', e.target.value)}
                    className='description-input'
                  />
                </div>
              </div>
            </div>
              
            
            <div className='button'>
              <button type='button' id='cancel-addtask' onClick={handleClearSubmit}>
                Clear
              </button>
              {isEdited ? (
              <button type='button' id='submit-addtask' onClick={handleFormSubmit}>
                Save
              </button>
            ):(
              <button type='button' id='submit-addtask' onClick={handleFormSubmit}>
                Add Task
              </button>
            )}
            </div>

        </form>):null}
        <>
        <div>
          <div style={{ display:'flex', justifyContent:'space-between', margin:'10px 20px' }}>
            <Input
            className="search-addtask"
            placeholder="Search by Date"
            allowClear
            suffix={<SearchOutlined style={{ color: "#04172480" }} />}
            onChange={(e) => {
            //  console.log("Search input value:", e.target.value);
              setSearchInput(e.target.value);
            }}
          />
         {!(filterOption === 'Date' && !isFormEnabled) && (
            <button
              id='cancel'
              onClick={handleToggleForm}
              disabled={isFormEnabled} // Disable the button when the form is enabled
            >
              Add Task
            </button>
          )}
          <div style={{display:'flex', justifyContent:'flex-end'}}>
          <button type='button' id='submit-less' onClick={handleLeftArrowClick}>
            <LeftOutlined />
          </button>

        {/* <Select
           
            style={{
              marginTop: '10px',
              display: 'flex',
              padding: '0.5em 2em',
              border: 'transparent',
              boxShadow: '2px 2px 4px rgba(0,0,0,0.4)',
              justifyContent: 'center',
              alignItems: 'center',
              gap: '10px',
              borderRadius: '4px',
              color:'white',
              background: '#0B4266',
              cursor: 'pointer',
              appearance: 'none',
              WebkitAppearance: 'none',
              MozAppearance: 'none',
            }}
            defaultValue="Date"
            onChange={handleFilterChange}
        >
          <Select.Option value="Date">Date</Select.Option>
          <Select.Option value="Week">Week</Select.Option>
          <Select.Option value="Month">Month</Select.Option>
        </Select> */}
          <select 
            id='submit' 
            style={{ appearance: 'none', WebkitAppearance: 'none', MozAppearance: 'none' }} 
            onChange={(e) => handleFilterChange(e.target.value)} value={filterOption}
          >
            <option style={{textAlign:'center'}} value='Date'>Date</option>
            <option style={{textAlign:'center'}} value='Week'>Week</option>
            <option style={{textAlign:'center'}} value='Month'>Month</option>
          </select>
          <button type='button' id='submit-less' onClick={handleRightArrowClick}>
            <RightOutlined />
          </button>
          </div>
        </div>
      </div>
        <Table
            columns={columns}
            dataSource={filteredTasks}
            pagination={false}
          />
            <button type='button' id='submit-overall' onClick={handleOverallSubmit}>
              Submit
            </button>
        </>
      </div>
    </DashboardLayout>
  );
};
export default AddTask;

AppRoutes.tsx

import PrivateRoutes from './PrivateRoutes';
import React, { useState, useEffect } from "react";
import { Route, Routes, Navigate } from 'react-router-dom';
import Error404 from "../Components/Error/Error-404";
import Dashboard from "../Components/Dashboard/Dashboard";
import CreateBranchAdmin from "../Components/Dashboard/CreateBranchAdmin";
import OnboardForm from "../Components/Dashboard/OnboardForm";
import ControlCalendar from '../Components/Dashboard/Calendar';
import CreateUser from '../Components/Dashboard/CreateUser';
import EmployeeList from '../Components/Dashboard/Employee-list';
import UserDetails from '../Components/Dashboard/UserDetails';
import AddTask from '../Components/Dashboard/AddTask';
import UserProfile from '../Components/Dashboard/UserProfile';
import ApprovalRequest from '../Components/Dashboard/ApprovalRequest';
import { Task } from '../Components/Dashboard/AddTask';
import MonthTasks from '../Components/Dashboard/MonthTasks';
import { ApprovalRequestsStateArray } from '../Components/Dashboard/AddTask';
// Initial state with an empty key and tasks array
const initialApprovalRequestsState: ApprovalRequestsStateArray = [];
const AppRoutes: React.FC = () => {
  const userEmail = localStorage.getItem('email');
  const [pieChartData, setPieChartData] = useState<{ [key: string]: number }>({});
  const [approvalRequestsData, setApprovalRequestsData] = useState<ApprovalRequestsStateArray>(initialApprovalRequestsState);

  useEffect(() => {
    // Retrieve approvalRequestsData from local storage
    const storedData = localStorage.getItem('approvalRequestsData');
    if (storedData) {
      setApprovalRequestsData(JSON.parse(storedData));
    }
  }, []); // Fetch data only once on component mount

  return (
    <Routes>
      <Route path="/" element={<Navigate to='/dashboard' />} />
      <Route element={<PrivateRoutes />}>
        <Route path="/dashboard" element={<Dashboard data={pieChartData}/>} />
        <Route path="/create-branch-admin" element={<CreateBranchAdmin />} />
        <Route path='/calendar' element={<ControlCalendar />} />
        <Route path="/onboardform" element={<OnboardForm />} />
        {/* ... (other routes) */}
        <Route path="/createuser" element={userEmail === 'sasikumarmurugan02@gmail.com' ? <CreateUser /> : <Navigate to="/dashboard" />} />
        <Route path='/userdetails' element={userEmail === 'sasikumarmurugan02@gmail.com' ? <UserDetails /> : <Navigate to="/dashboard" />} />
        <Route path='/employeeview' element={<EmployeeList />} />
        <Route
          path="/addtask"
          element={
            userEmail === 'sasikumarmurugan02@gmail.com' ? (
              <AddTask setPieChartData={setPieChartData} setApprovalRequestsData={setApprovalRequestsData} approvalRequestsData={approvalRequestsData}/>
            ) : (
                <Navigate to="/dashboard" />
              )
          }
        />
        <Route path="/userprofile/:userId" element={userEmail === 'sasikumarmurugan02@gmail.com' ? <UserProfile /> : <Navigate to="/dashboard" />} />
        <Route path="/createuser/:userId" element={userEmail === 'sasikumarmurugan02@gmail.com' ? <CreateUser /> : <Navigate to="/dashboard" />} />
        <Route path='/approvalrequests' element={(userEmail === 'sasikumarmurugan02@gmail.com') ? <ApprovalRequest/> : <Navigate to="/dashboard" />} />
        <Route path='/monthTasks' element={(userEmail === 'sasikumarmurugan02@gmail.com') ? <MonthTasks/> : <Navigate to="/dashboard" />} />
      </Route>
    </Routes>
  );
};
export default AppRoutes;

ApprovalRequest.tsx

import React,{useEffect, useState, useRef} from 'react'
import { useNavigate } from 'react-router-dom';
import { ColumnsType } from 'antd/es/table'
import { EditOutlined, FolderViewOutlined} from '@ant-design/icons';
import { Progress } from 'antd';
import dayjs from 'dayjs';
import { v4 as uuidv4 } from 'uuid';
import '../Styles/ApprovalRequest.css';
import {
  Avatar,
  Space,
  Button,
  Table,
  Modal,
  Form,
  Input,
  Select,
  ConfigProvider,
  Tooltip,
  Tag,
  Popover,
  message,
  Checkbox,
  Pagination,
  Menu,
  Dropdown,
} from "antd";
import moment from "moment";
import { ExpandableConfig } from 'antd/lib/table/interface';
import 'moment/locale/en-in';
import {
  UserOutlined,
  DownOutlined,
  UpOutlined,
} from "@ant-design/icons";
import DashboardLayout from './Layout';
import { Task, ApprovalRequestsState, ApprovalRequestsStateArray } from './AddTask';
import { groupBy } from 'lodash';
import { ConstructionOutlined, TaskSharp } from '@mui/icons-material';
import { TableRowSelection } from 'antd/lib/table/interface';

// Define the type for RowSelectMethod
type RowSelectMethod = 'checkbox' | 'radio';

// interface GroupedTasks {
//   key: string;
//   slNo?: number;
//   month: string;
//   tasks: { 
//     [date: string]: {
//       key: string;
//       tasks: Task[]; 
//     } 
//   }; 
//   daysFilled: number;
//   totalDaysInMonth: number;
// }

export interface TaskObject {
  [date: string]: {
    key: string;
    tasks: Task[];
  };
}

interface GroupedTasks {
  key: string;
  slNo?: number;
  month: string;
  tasks: ApprovalRequestsStateArray;
  daysFilled: number;
  totalDaysInMonth: number;
}

const ApprovalRequest:React.FC= () => { 
  const navigate = useNavigate();
  const [forceUpdate, setForceUpdate] = useState(false);

  //const [selectedRows, setSelectedRows] = useState<React.Key[]>([]);
  const [selectedRows, setSelectedRows] = useState<string[]>([]);
  const [selectedInnerRows, setSelectedInnerRows] = useState<string[]>([]);
  //const[daysInMonth, getDaysInMonth]=useState<string[]>([]);
  const [groupedTasks, setGroupedTasks] = useState<{ [key: string]: GroupedTasks }>({});
  // State declaration with two keys
  //const [groupedTasks, setGroupedTasks] = useState<{ [month: string]: { [date: string]: GroupedTasks } }>({});
  const [expandedRow, setExpandedRow] = useState<string | null>(null);
  const [expandedInnerRow, setExpandedInnerRow] = useState<string | null>(null);
  const [modalVisible, setModalVisible] = useState<boolean>(false);
  const [modalContent, setModalContent] = useState<JSX.Element | null>(null);
  const [selectedUserId, setSelectedUserId] = useState<string | undefined>(undefined);
  const [comments, setComments] = useState('');
  const [commentVisible, setCommentVisible] = useState(false);
  const [approvalRequests, setApprovalRequests] = useState<Task[]>([]);
  const [monthTasks, setMonthTasks] = useState<TaskObject[]>([]);
  useEffect(() => {
    // Retrieve approvalRequestsData from local storage
    const storedData = localStorage.getItem('approvalRequestsData');
    if (storedData) {
        const approvalRequestsData = JSON.parse(storedData);
        setApprovalRequests(approvalRequestsData); // Update the state with fetched data
    }
  }, []); // Fetch data only once on component mount

  useEffect(() => {
      if (approvalRequests.length > 0) { // Check if approvalRequests has data
          // Process approvalRequests data
          handleGroupedTasks(approvalRequests);
      }
  }, [approvalRequests]);

  useEffect(() => {
    // Log monthTasks
    console.log("useEffect monthTasks", monthTasks);
    
    // Store monthTasks in localStorage
    localStorage.setItem('monthTasks', JSON.stringify(monthTasks));
  }, [monthTasks]); 

  const handleReject = () => {
    setCommentVisible(true);
  };

  const handleCancel = () => {
    setCommentVisible(false);
  };

  const handleInputChange = (e:any) => {
    setComments(e.target.value);
  };

  const handleSubmit = () => {
    // Handle submission logic here
    console.log('Comments:', comments);
    setCommentVisible(false);
  };

  const handleApprove = () => {
    // Filter out the selected row from the groupedTasks state
    const updatedGroupedTasks = { ...groupedTasks };
    console.log("handleApprove", updatedGroupedTasks);
    // Iterate through selected rows
    selectedInnerRows.forEach(rowKey => {
        // Check if the rowKey exists in updatedGroupedTasks and if its tasks property is defined
        if (updatedGroupedTasks[rowKey]?.tasks) {
            const tasks = updatedGroupedTasks[rowKey].tasks;
            // Iterate through tasks for each date
            Object.values(tasks).forEach(dateTasks => {
                // Iterate through individual tasks
                dateTasks.tasks.forEach(task => {
                    // Add a special CSS class or inline style to change the background color to green
                    (task as Task & { backgroundColor?: string }).backgroundColor = 'green'; // Adjust this to your styling needs
                });
            });
        }
    });
    console.log("updatedGroupedTaks", updatedGroupedTasks);
    // Update the selectedInnerRows array to remove the approved row
    setSelectedInnerRows([]);

    // Close the modal
    setModalVisible(false);

    // Update the state with the modified groupedTasks
    setGroupedTasks(updatedGroupedTasks);
};

  
  function getDaysInMonth(month: number, year: number) {
    // month is 0-based in JavaScript
    return new Date(year, month + 1, 0).getDate();
  }

  const handleGroupedTasks = (requestData: Task[]) => {
    // Group tasks by month
    const grouped = groupBy(requestData, (task: Task) => dayjs(task.date).format("YYYY-MM"));
    // Retrieve existing data from local storage
    const existingDataJSON = localStorage.getItem('groupedTasks');
    const existingData: { [key: string]: GroupedTasks } = existingDataJSON ? JSON.parse(existingDataJSON) : {};

    // Process each month's tasks
    for (const monthKey in grouped) {
        const tasksArray = grouped[monthKey] as Task[];
        console.log("tasksArray",tasksArray);
        const firstTaskDate = dayjs(tasksArray[0].date, 'YYYY-MM-DD');
        const formattedMonth = firstTaskDate.format("MMMM YYYY");
        const totalDaysInMonth = getDaysInMonth(firstTaskDate.month(), firstTaskDate.year());

        let daysFilled = 0;
        let tasks: ApprovalRequestsStateArray = [];

        tasksArray.forEach(task => {
            const dateKey = dayjs(task.date, 'YYYY-MM-DD').format('YYYY-MM-DD');
            if (existingData.hasOwnProperty(monthKey)) {
                const existingMonth = existingData[monthKey];
                console.log("existingMonth",existingMonth);
                // Check if the date already exists in tasks array
                const existingDateIndex = existingMonth.tasks.findIndex(date => date.date === dateKey);
                console.log("existingDateIndex",existingDateIndex);
                if (existingDateIndex !== -1) {
                    // If date exists, add task to existing tasks array for that date
                    existingMonth.tasks[existingDateIndex].tasks.push(task);
                } else {
                    // If date does not exist, add new date with task
                    existingMonth.tasks.push({ key: uuidv4(), date: dateKey, tasks: [task] });
                    daysFilled++;
                }
            } else {
                // Create new month with date and tasks
                const monthUUID = uuidv4(); // Generate unique key for the month
                tasks.push({ key: uuidv4(), date: dateKey, tasks: [task] }); // Include tasks array
                existingData[monthKey] = {
                    key: monthUUID,
                    month: formattedMonth,
                    daysFilled,
                    totalDaysInMonth,
                    tasks: tasks // Assign tasks array to the month
                };
                daysFilled++;
            }
        });

        // Update daysFilled for the existing month if necessary
        if (existingData.hasOwnProperty(monthKey)) {
            existingData[monthKey].daysFilled = daysFilled;
        }
    }

    // Set the updated data to local storage
    localStorage.setItem('groupedTasks', JSON.stringify(existingData));
    // Update the state with the combined data
    setGroupedTasks(existingData);
};



  
  const handleRowSelection = (selectedRowKeys: React.Key[]) => {
    console.log("handleRowSelection selectedRowKeys", selectedRowKeys); // Output selectedRowKeys to console
    setSelectedRows(selectedRowKeys as string[]);
  };

const handleInnerRowSelection = (     
  selectedRowKeys: React.Key[],
  selectedRows: TaskObject[],
  tasksForClickedMonth: TaskObject[]
) => {
  // Extracting keys from the tasksForClickedMonth array
  const taskKeys = tasksForClickedMonth.flatMap(task => Object.keys(task));
  
  console.log("taskkeys",taskKeys);
  setSelectedInnerRows(taskKeys as string[]); // Assuming selectedRowKeys are string keys
  console.log("handleInnerRowSelection tasksForClickedMonth", tasksForClickedMonth);
};

const rowSelection = {
  onChange: (selectedRowKeys: React.Key[], selectedRows: TaskObject[]) => {
    console.log('selectedRowKeys', selectedRowKeys, 'selectedRows: ', selectedRows);
    setSelectedInnerRows(selectedRowKeys as string[]);
    console.log(selectedInnerRows);
  },
  getCheckboxProps: (record: TaskObject) => ({
    disabled: false, // Column configuration not to be checked
    key: record.key,
  }),
};

useEffect(() => {
  console.log("selectedInnerRows", selectedInnerRows);
}, [selectedInnerRows]);

  const handleToggleRowExpand = (record: GroupedTasks, event: React.MouseEvent<HTMLElement>) => {
    // Update the expandedRow state using the functional form of setState
    setExpandedRow(prevExpandedRow => prevExpandedRow === record.month ? null : record.month);
    // Prevent event propagation
    event.stopPropagation();
  };

  const handleToggleInnerRowExpand = (record: TaskObject) => {
    const taskKeys = Object.keys(record?.tasks);
    if (taskKeys.length > 0) {
      // Get the first key from the tasks object
      const firstTaskKey = taskKeys[0];
      // Update the state with the first task key
      setExpandedInnerRow(prevExpandedInnerRow => {
        // Check if the current expanded row is the same as the first task key
        if (prevExpandedInnerRow === firstTaskKey) {
          // If it is, collapse the row by setting expandedInnerRow to null
          return null;
        } else {
          // Otherwise, expand the row by setting expandedInnerRow to the first task key
          return firstTaskKey;
        }
      });
    }
    console.log("handleToggleInnerRowExpand", expandedInnerRow);
  };
  
    const rowClassName = (record: GroupedTasks, index: number) => {
      return index % 2 === 0 ? 'even-row' : 'odd-row';
    };

      const getColumn = (formattedMonth: string) => {
        const column: ColumnsType<TaskObject> = [
          {
            title: 'Select All',
            dataIndex: 'date',
            key: 'date',
            width: '20%',
            fixed: 'left',
            render: (_, record: TaskObject) => {
              // Get the specific month key
              const monthKey = Object.keys(record).find(
                key =>
                  moment(key).format('YYYY-MM') ===
                  moment(formattedMonth, 'YYYY-MM').format('YYYY-MM')
              );
              if (!monthKey) return null; // If monthKey is not found, return null
        
              // Get the formatted date for the month key
              const formattedDate = moment(monthKey).format('YYYY-MM-DD');
              return formattedDate;
            },
          },     
          {
            title: '',
            dataIndex: 'tasks',
            key: 'tasks',
            width: '60%',
            render: (_, record: TaskObject) => {
              // Initialize variables to store task hours and total hours
              let totalHours = 0;
              const taskHours: { [key: string]: number } = {};
            
              // Iterate over each date in the record
              Object.entries(record).forEach(([date, dateTasks]) => {
                // Iterate over tasks for each date
                dateTasks.tasks.forEach(task => {
                  const totalHoursForTask = parseFloat(task.totalHours || '0');
                  totalHours += totalHoursForTask; // Accumulate total hours
                  taskHours[task?.task] = (taskHours[task?.task] || 0) + totalHoursForTask; // Add task hours
                });
              });
            
              // Calculate extra hours if total hours exceed 9
              const extraHours = totalHours > 9 ? totalHours - 9 : 0;
            
              return (
                <div>
                  <ul style={{ display: 'flex', flexDirection: 'row', listStyle: 'none', padding: 0}}>
                    {/* Render task hours for each task */}
                    {Object.entries(taskHours).map(([taskName, taskTotalHours], index) => (
                      <li key={index} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', margin: '5px' }}>
                        <div style={{ paddingRight: '20px' }}>
                          <div style={{ color: 'grey', paddingBottom: '5px' }}>
                            {taskName}
                          </div>
                          <div style={{ fontWeight: "bold", fontSize: '20px', color: 'black' }}>
                            {taskTotalHours}H
                          </div>
                        </div>
                        <div>
                          <Progress
                            type="circle"
                            percent={Math.round((taskTotalHours / 9) * 100)} // Ensure it's an integer
                            width={60}
                          />
                        </div>
                      </li>
                    ))}
                    {/* Render extra hours and total hours */}
                    <li style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white',  margin: '5px' }}>
                      <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                        Extra Hours
                      </div>
                      <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: "bold", fontSize: '20px' }}>
                        {extraHours}H
                      </div>
                    </li>
                    <li style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', margin: '5px' }}>
                      <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                        Total Hours
                      </div>
                      <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: 'bold', fontSize: '20px' }}>
                        {totalHours}H
                      </div>
                    </li>
                  </ul>
                </div>
              );
            },
          },      
          {
            title: '',
            dataIndex: 'actions',
            key: 'actions',
            fixed: 'right',
            width: '20%',
            render: (_, record: TaskObject) => (
              <div>
                {/* Check if the record has tasks */}
                {record && Object.keys(record).length > 0 ? (
                  // Render the appropriate icon based on the expanded state
                  expandedInnerRow === Object.keys(record)[0] ? (
                    <UpOutlined
                      style={{
                        cursor: 'pointer',
                        color: '#0B4266',
                        fontSize: '16px',
                      }}
                      onClick={() => handleToggleInnerRowExpand(record)}
                    />
                  ) : (
                    <DownOutlined
                      style={{
                        cursor: 'pointer',
                        color: '#0B4266',
                        fontSize: '16px',
                      }}
                      onClick={() => handleToggleInnerRowExpand(record)}
                    />
                  )
                ) : null}
              </div>
            ),
          }  
        ];
        return column;
      };
    
    const innerColumn: ColumnsType<Task> = [
      {
        title: 'Sl.no',
        className: 'ant-table-column-title',
        dataIndex: 'slNo',
        key: 'slNo',
        fixed: 'left',
        render: (_, __, index) => <span>{index + 1}</span>,
      },  
      {
        title: 'Task',
        sorter: (a: Task, b: Task) => {
          return a.task.localeCompare(b.task);
        },
        dataIndex: 'task',
        key: 'task',
        fixed: 'left',
      },
      {
        title: 'Start Time',
        sorter: (a: Task, b: Task) => {
          return a.startTime.localeCompare(b.startTime);
        },
        dataIndex: 'startTime',
        key: 'startTime',
        fixed: 'left',
      },
      {
        title: 'End Time',
        sorter: (a: Task, b: Task) => {
          return a.endTime.localeCompare(b.endTime);
        },
        dataIndex: 'endTime',
        key: 'endTime',
        fixed: 'left',
      },
      {
        title: 'Total Hours',
        sorter: (a: Task, b: Task) => {
          return a.totalHours.localeCompare(b.totalHours);
        },
        dataIndex: 'totalHours',
        key: 'totalHours',
        fixed: 'left',
      },
      {
        title: 'Description',
        sorter: (a: Task, b: Task) => {
          return a.description.localeCompare(b.description);
        },
        dataIndex: 'description',
        key: 'description',
        fixed: 'left',
      },
    ];
    
    const columns: ColumnsType<GroupedTasks> = [
      {
        title: 'Sl.no',
        className: 'ant-table-column-title',
        dataIndex: 'slNo',
        key: 'slNo',
        fixed: 'left',
        render: (_, __, index) => <span>{index + 1}</span>,
      },
      {
        title: 'Employee',
        className: ' ant-table-column-title',
        dataIndex: 'tasks',
        render: (tasks: ApprovalRequestsStateArray) => {
          const userId = tasks[0]?.tasks[0]?.userId || '';
          return (
            <Space className="flex gap-5">
              <Avatar icon={<UserOutlined />} size={45} />
              <div>
                <div>
                  <strong>Sasi Kumar</strong>
                </div>
                <div>{userId}</div>
              </div>
            </Space>
          );
        },
        sorter: (a: GroupedTasks, b: GroupedTasks) => {
          const userIdA = a.tasks[0]?.tasks[0]?.userId || '';
          const userIdB = b.tasks[0]?.tasks[0]?.userId || '';
          return userIdA.localeCompare(userIdB);
        },
      },
      {
        title: 'Month',
        sorter: (a, b) => a.month.localeCompare(b.month),
        className: 'ant-table-column-title',
        dataIndex: 'month',
        key: 'month',
        fixed: 'left',
      },
      {
        title: 'Requested On',
        className: 'ant-table-column-title',
        dataIndex: 'tasks',
        key: 'date',
        fixed: 'left',
        render: (tasks: ApprovalRequestsStateArray) => {
          const earliestDate = tasks.reduce((earliest, current) => {
            return earliest.date < current.date ? earliest : current;
          }, tasks[0]);
          const formattedDate = earliestDate ? moment(earliestDate.date).format('YYYY-MM-DD') : '';
          return formattedDate;
        },
      },
      {
        title: 'Days Filled',
        className: 'ant-table-column-title',
        dataIndex: 'daysFilled',
        key: 'daysFilled',
        render: (_, record) => {
          const dateKeysFilled = record.tasks.length;
          return <span>{`${dateKeysFilled} / ${record.totalDaysInMonth}`}</span>;
        },
        sorter: (a: GroupedTasks, b: GroupedTasks) => a.tasks.length - b.tasks.length,
      },
      {
        title: ' ',
        dataIndex: 'actions',
        key: 'actions',
        render: (_, record, index) => (
          <div>
            {expandedRow === record.month ? (
              <UpOutlined
                style={{
                  cursor: 'pointer',
                  color: '#0B4266',
                  fontSize: '16px',
                }}
                onClick={(event) => handleToggleRowExpand(record, event)}
              />
            ) : (
              <DownOutlined
                style={{
                  cursor: 'pointer',
                  color: '#0B4266',
                  fontSize: '16px',
                }}
                onClick={(event) => handleToggleRowExpand(record, event)}
              />
            )}
          </div>
        ),
      },
    ];
  
    const expandable: ExpandableConfig<GroupedTasks> = {
      expandedRowRender: (record: GroupedTasks) => {
          const taskHours: { [key: string]: number } = {};
          for (const approvalRequest of record.tasks) {
            console.log("expandable-approvalRequest",approvalRequest);
              for (const task of approvalRequest.tasks) {
                console.log("expandable-task",task);
                  const taskKey = task.task; // Assuming 'task' property is the key for the task
                  console.log("expandable-taskKey",taskKey);
                  if (taskKey) {
                      if (taskHours.hasOwnProperty(taskKey)) {
                          taskHours[taskKey] += parseFloat(task.totalHours || '0');
                          console.log("expandable-if-taskKey",taskKey, taskHours);
                      } else {
                          taskHours[taskKey] = parseFloat(task.totalHours || '0');
                          console.log("expandable-else-taskKey",taskKey, taskHours);
                      }
                      console.log("expandable-taskKey",taskKey, taskHours);
                  }
              }
          }
  
          // After calculating the total hours for each task, convert them to fixed decimals
          for (const taskName in taskHours) {
            console.log("expandable-taskName",taskName);
              if (taskHours.hasOwnProperty(taskName)) {
                  taskHours[taskName] = parseFloat(taskHours[taskName].toFixed(2));
                  console.log("expandable-if",taskName, taskHours);
              }
          }
         
  
          // Calculate total hours and extra hours
          const totalHours = Math.floor(Object.values(taskHours).reduce((acc, curr) => acc + curr, 0));
          const regularHours = Math.min(totalHours, 9);
          const extraHours = totalHours - regularHours;
  
          // Render expanded row content
          if (expandedRow === record.month) {
              return (
                  <div>
                      <ul style={{ display: 'flex', justifyContent: 'space-around', listStyle: 'none' }}>
                          {Object.entries(taskHours).map(([taskName, taskTotalHours], index) => (
                              <div key={index} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
                                  <div style={{ paddingRight: '20px' }}>
                                      <div style={{ color: 'grey', paddingBottom: '5px' }}>
                                          {taskName}
                                      </div>
                                      <div style={{ fontWeight: "bold", fontSize: '20px', color: 'black' }}>
                                          {taskTotalHours}H
                                      </div>
                                  </div>
                                  <div>
                                      <Progress
                                          type="circle"
                                          percent={Math.round((taskTotalHours / 9) * 100)} // Ensure it's an integer
                                          width={60}
                                      />
                                  </div>
                              </div>
                          ))}
                          {/* Render extra hours and total hours */}
                          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
                              <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                                  Extra Hours
                              </div>
                              <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: "bold", fontSize: '20px' }}>
                                  {extraHours}H
                              </div>
                          </div>
                          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
                              <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                                  Total Hours
                              </div>
                              <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: 'bold', fontSize: '20px' }}>
                                  {totalHours}H
                              </div>
                          </div>
                      </ul>
                  </div>
              );
          }
          return null;
      },
      expandRowByClick: true,
  };
  
    
    
    
    const aggregatedData: GroupedTasks[] = Object.keys(groupedTasks).map((monthKey: string) => {
      const monthData = groupedTasks[monthKey];
      const monthTasks: ApprovalRequestsStateArray = [];
      let daysFilled = 0;
      for (const dateKey in monthData.tasks) {
        if (monthData.tasks[dateKey].tasks.length > 0) {
          monthTasks.push(monthData.tasks[dateKey]);
          daysFilled++;
        }
      }
      const totalDaysInMonth = monthData.totalDaysInMonth;
      console.log("aggregatedData", monthData);
      return {
        key: monthData.key,
        month: monthData.month,
        tasks: monthTasks,
        daysFilled: daysFilled,
        totalDaysInMonth: totalDaysInMonth
      };
    });
    
  
    const flattenedData = (groupedTasks: TaskObject) => {
      const tasks: TaskObject[] = [];
      const keys = Object.keys(groupedTasks);
      console.log("keys", keys);
      // Iterate over each key
      keys.forEach(key => {
          // Find the monthData corresponding to the current key
          const groupedData = groupedTasks[key];
          console.log("monthdata", groupedData);
          if (groupedData) {
              // Convert monthData into TaskObject
              const taskObject: TaskObject = {
                  [key]: {
                      key: groupedData.key,
                      tasks: groupedData.tasks
                  }
              };
              tasks.push(taskObject);
          }
      });
  
      return tasks;
  };
  
    const handleRowClick = (
      record: TaskObject,
      formattedMonth: string,
      event: React.MouseEvent<HTMLElement>
    ) => {
      console.log('handleRowClick record', record);
      const tasksForClickedMonth: TaskObject[] = flattenedData(
        record
      );
    
      // Set the month tasks in the state
      setMonthTasks(tasksForClickedMonth);
      console.log("tasksForClickedMonth",tasksForClickedMonth);
      // Set the modal content and make the modal visible
      setModalContent(
        <div>
          <Table
          rowSelection={{
            type: 'checkbox',
            selectedRowKeys: selectedInnerRows,
            ...rowSelection,
            onChange(selectedRowKeys, selectedRows, info) {
                console.log(selectedRowKeys,selectedRows,info)
            },          
          }}          
            style={{
              backgroundColor: 'white',
              border: '1px solid grey',
              borderRadius: '5px',
            }}
            columns={getColumn(formattedMonth)} 
            rowClassName="rowstyle"
            dataSource={tasksForClickedMonth} // Pass the tasks for the clicked month here
            pagination={false}
            expandable={{
              expandedRowRender: (record: TaskObject) => {
                const handleInnerRowExpand = (dateKey: string) => {
                  const tasksForDate = record[dateKey]?.tasks || [];
                  return (
                    <Table
                      columns={innerColumn as ColumnsType<Task>}
                      dataSource={tasksForDate}
                      pagination={false}
                    />
                  );
                };
              
                return (
                  <>
                    {Object.keys(record).map(dateKey => (
                      <div key={dateKey}>
                        <div>Date: {dateKey}</div>
                        {handleInnerRowExpand(dateKey)}
                      </div>
                    ))}
                  </>
                );
              },
              
    
              expandRowByClick: true,
              expandIcon: () => null,
            }}
          />
        </div>
      );
      // Set the modal content and make the modal visible
      setModalVisible(true);
    
      // Prevent event propagation
      event.stopPropagation();
    };
     
  return (
    <DashboardLayout>
      <div>
        <Table
           rowSelection={{
            type: 'checkbox',
            selectedRowKeys: selectedRows,
            onChange: handleRowSelection,
            getCheckboxProps: (record: GroupedTasks) => ({
              // Use the `key` field as the identifier for row selection
              key: record.key,
              disabled: false, // You can adjust these additional props as needed
            }),
          }}   
          // onRow={(record: GroupedTasks) => ({
          //   onClick: (event: React.MouseEvent<HTMLElement>) => {
          //     const userId = record.tasks[Object.keys(record.tasks)[0]].tasks[0]?.userId;
          //     setSelectedUserId(userId); // Set the userId in state
          //     // Extract necessary data from the GroupedTasks record
          //     const monthYear = record.month;
          //     const [monthName, year] = monthYear.split(' ');
          //     const monthNumber = moment().month(monthName).format('MM');
          //     const formattedMonth = `${year}-${monthNumber}`;
          //     // Convert GroupedTasks record into TaskObject
          //     const tasksObject: TaskObject = record.tasks;
          //     console.log("onRow-tasksObject", tasksObject);
          //     console.log("taskObject", tasksObject);
          //     const tasksForClickedMonth: TaskObject[] = flattenedData(
          //       tasksObject
          //     );
          //     console.log("onRow-tasksForClickedMonth", tasksForClickedMonth);
          //     setMonthTasks(tasksForClickedMonth);
          //     // Pass TaskObject and formattedMonth to handleRowClick
          //     //handleRowClick(tasksObject, formattedMonth, event);
          //     navigate(`/monthtasks?formattedMonth=${formattedMonth}&userId=${userId}`, {state: {
          //       formattedMonth: formattedMonth,
          //       userId: userId,
          //       tasksObject: tasksObject,
          //       tasksForClickedMonth: tasksForClickedMonth,
          //   }});
          //   },
          // })}
          
          style={{ backgroundColor: 'white' }}
          columns={columns}
          dataSource={aggregatedData}
          pagination={false}
          //expandable={expandable}
          expandable={{
            expandedRowRender: expandable.expandedRowRender,
            expandRowByClick: false,
            // expandIcon: ({ expanded, onExpand, record }) => (
            //   expanded ? 
            //     <UpOutlined onClick={(event) => onExpand(record, event)} /> :
            //     <DownOutlined onClick={(event) => onExpand(record, event)} />
            // ),
          }}  
        />
      </div>
      <Modal
        title={
          modalContent ? (
            <div>
              <Space className="flex gap-5">
                <Avatar icon={<UserOutlined />} size={45} />
                <div>
                  <div>
                    <strong>Sasi Kumar</strong>
                  </div>
                  {/* Displaying the userId */}
                  <div>{selectedUserId}</div>
                </div>
              </Space>
            </div>
          ) : null
        }
        visible={modalVisible}
        onCancel={() => setModalVisible(false)}
        footer={null}
        width="80%"
      >
        {modalContent}
        <div style={{display:'flex', justifyContent:'flex-end', margin:"10px 20px"}}>
          <Button style={{width:'10%', backgroundColor:'green', color:'white'}} onClick={handleApprove}>Approve</Button>
          <Button style={{ width: '10%', backgroundColor: 'red', color: 'white' }} onClick={handleReject}>
            Reject
          </Button>
          <Modal
            title="Comments"
            className='modalTitle'
            visible={commentVisible}
            onCancel={handleCancel}
            footer={[
              // <Button key="cancel" onClick={handleCancel}>
              //   Cancel
              // </Button>,
              <Button style={{ width: '20%', backgroundColor: '#0B4266', color: 'white' }} key="submit" type="primary" onClick={handleSubmit}>
                Submit
              </Button>,
            ]}
          >
            <Input.TextArea placeholder='Write here...' rows={4} value={comments} onChange={handleInputChange} />
          </Modal>
        </div>
      </Modal>
    </DashboardLayout>
  );
  
}

export default ApprovalRequest


19/2/2024

import React, { useState, useEffect, useCallback } from 'react';
import { Input, TimePicker, Select, notification, DatePicker} from 'antd';
import { SearchOutlined } from '@mui/icons-material';
import dayjs from 'dayjs';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { useMsal } from '@azure/msal-react';
import '../Styles/CreateUser.css';
import DashboardLayout from './Layout';
import '../Styles/AddTask.css';
import {Table} from 'antd';
import { ColumnsType } from "antd/es/table";
import ApprovalRequest from './ApprovalRequest';
import { EditOutlined, DeleteOutlined,CloseCircleOutlined,LeftOutlined, RightOutlined } from '@ant-design/icons';
import Dashboard from './Dashboard';
export interface Task {
  key?:string;
  idx: number; // Add this line
  date: string;
  userId: string;
  task: string;
  startTime: string;
  endTime: string;
  totalHours: string;
  description: string;
  reportingTo: string;
  slNo?: number;
  isNew?: boolean
}

type AddTaskProps = {
  setPieChartData: React.Dispatch<React.SetStateAction<{ [key: string]: number }>>;
  setApprovalRequestsData: React.Dispatch<React.SetStateAction<Task[]>>;
  approvalRequestsData: Task[];
};

const AddTask: React.FC<AddTaskProps> = ({ setPieChartData, setApprovalRequestsData }) => {
  const navigate = useNavigate();
  const [deletedTask, setDeletedTask] = useState(false);
  const [formWidth, setFormWidth] = useState(800);
  const [currentDate, setCurrentDate] = useState(dayjs());
  const [currentWeek, setCurrentWeek] = useState(dayjs().startOf('week'));
  const [currentMonth, setCurrentMonth] = useState(dayjs().startOf('month'));
  const [isFormEnabled, setIsFormEnabled] = useState(false);
  const [addTask, setAddTask] = useState<Task>({
    idx: 1, // Set initial idx
    date: currentDate.format('YYYY-MM-DD'),
    userId: '123',
    task: '',
    startTime: '',
    endTime: '',
    totalHours: '',
    description: '',
    reportingTo: '',
  });
  const [deletedTaskIdx, setDeletedTaskIdx] = useState<number | null>(null);
  const [taskList, setTaskList] = useState<Task[]>([]);
  const [filteredTasks, setFilteredTasks] = useState<Task[]>([]);
  const reportingOptions = ['ManagerA', 'ManagerB', 'ManagerC'];
  const taskOptions = ['Task','Project','Learning','Training','Meeting'];
  const [filterOption, setFilterOption] = useState('Date');
  const [isEdited, setIsEdited]= useState<boolean>(false);
  // State to manage the search input
  const [searchInput, setSearchInput] = useState('');
  const [isFormSubmitted, setIsFormSubmitted] = useState(false);
  const [selectedKeysToHide, setSelectedKeysToHide]=useState<string[]>([]);
 const updateSlNo = (tasks: Task[], deleteTask: boolean): Task[] => {
  return tasks.map((task, index) => ({
    ...task,
    slNo: index + 1,
    idx: deleteTask ? index + 1 : task.idx
  }));
};

  useEffect(() => {
    const updateFormWidth = () => {
      const formElement = document.getElementById('myForm');
      if (formElement) {
        const newWidth = formElement.offsetWidth;
        setFormWidth(newWidth);
      }
    };

    window.addEventListener('resize', updateFormWidth);
    updateFormWidth();

    return () => {
      window.removeEventListener('resize', updateFormWidth);
    };
  }, []);

  const borderStyle = {
    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)', // Add box shadow
    margin: '10px 20px',
   // padding: '10px 20px',
    width: formWidth + 'px',
  };

  useEffect(()=>{
    const storedKeysString: string | null = localStorage.getItem('selectedKeys');
    if (storedKeysString !== null) {
        const storedKeys: string[] = JSON.parse(storedKeysString);
        console.log("storedKeys", storedKeys);
        setSelectedKeysToHide(storedKeys);
    } else {
       console.log("else-useEffect", storedKeysString);
    }
  },[])
  
  const handleInputChange = (field: keyof Task, value: string) => {
    if (field === 'date') {
      const selectedDate = dayjs(value);
      if (selectedDate.isAfter(dayjs(), 'day')) {
        // Display a notification
        notification.warning({
          message: 'Warning',
          description: 'Cannot select a future date.',
        });
        // Set the selected date to today
        setCurrentDate(dayjs());
      } else {
        // Update the state with the selected date
        setCurrentDate(selectedDate);
      }
    }
  
    // Keep userId constant
    if (field === 'userId') {
      setAddTask((prevTask) => ({ ...prevTask, [field]: value }));
    } else {
      // Update startTime or endTime with the new value
      const updatedTime = value || dayjs().format('hh:mm A');
      setAddTask((prevTask) => ({ ...prevTask, [field]: updatedTime }));
      // Calculate the duration and update totalHours
      const updatedStartTime = field === 'startTime' ? updatedTime : addTask.startTime || dayjs().format('hh:mm A');
      const updatedEndTime = field === 'endTime' ? updatedTime : addTask.endTime || dayjs().format('hh:mm A');
      const duration = dayjs(updatedEndTime, 'hh:mm A').diff(dayjs(updatedStartTime, 'hh:mm A'), 'hour', true);
      setAddTask((prevTask) => ({
        ...prevTask,
        startTime: field === 'startTime' ? updatedTime : addTask.startTime,
        endTime: field === 'endTime' ? updatedTime : addTask.endTime,
        totalHours: duration.toFixed(2),
      }));
    }
  };
  
  useEffect(() => {
    const storedTaskListString = localStorage.getItem('taskList');
    const storedTaskList = storedTaskListString ? JSON.parse(storedTaskListString) : [];

    // Assuming deletedTask is a state variable
    const updatedTaskList = updateSlNo(storedTaskList, deletedTask);

    setTaskList(updatedTaskList);
    setFilteredTasks(updatedTaskList);
  }, [deletedTask]); // Include deletedTask in the dependency array

  useEffect(() => {
    // Filter tasks based on the addTask.date when it changes
    if (addTask.date) {
      const filtered = taskList.filter(task => task.date === addTask.date);
      setFilteredTasks(updateSlNo(filtered, deletedTask)); // Update slNo when loading tasks
    } else {
      // If no date is selected, display all tasks
      setFilteredTasks(updateSlNo(taskList, deletedTask)); // Update slNo when loading tasks
    }
  }, [addTask.date, taskList]);

  useEffect(() => {
    // Update addTask with the current date
    if (!isEdited) {
      // Update addTask with the current date only when not in edit mode
      setAddTask((prevAddTask) => ({
        ...prevAddTask,
        date: dayjs(currentDate).format('YYYY-MM-DD'),
    }));
  }
    //setFilteredTasks(taskList);
    // Filter tasks based on the filterOption and currentDate when they change
    let filtered: Task[] = [];

    if (searchInput) {
      // If there is a search input, filter tasks based on date or month
      const searchDate = dayjs(searchInput);
      filtered = taskList.filter((task) => {
        if (filterOption === 'Date') {
          return dayjs(task.date).isSame(searchDate, 'day');
        } else if (filterOption === 'Week') {
          const startOfWeek = currentWeek.startOf('week');
          const endOfWeek = currentWeek.endOf('week');
          return (
            (dayjs(task.date).isSame(startOfWeek) || dayjs(task.date).isAfter(startOfWeek)) &&
            (dayjs(task.date).isSame(endOfWeek) || dayjs(task.date).isBefore(endOfWeek))
          );
        } else if (filterOption === 'Month') {
          // Format the searchInput in the same way as the task date
          const formattedSearchMonth = searchDate.format('MMMM');
          return dayjs(task.date).format('MMMM') === formattedSearchMonth;
        }
        return false;
      });
    }  else {
      // If no search input, apply the regular filtering based on filterOption and currentDate
      if (filterOption === 'Date') {
        filtered = taskList.filter((task) => task.date === dayjs(currentDate).format('YYYY-MM-DD'));
        console.log("useEffect-date", filtered)
      } else if (filterOption === 'Week') {
        const startOfWeek = currentWeek.startOf('week');
        const endOfWeek = currentWeek.endOf('week');
        filtered = taskList.filter(
          (task) =>
            (dayjs(task.date).isSame(startOfWeek) || dayjs(task.date).isAfter(startOfWeek)) &&
            (dayjs(task.date).isSame(endOfWeek) || dayjs(task.date).isBefore(endOfWeek))
        );
        console.log("useeffect-week", filtered);
      } else if (filterOption === 'Month') {
        const startOfMonth = currentMonth.startOf('month');
        const endOfMonth = currentMonth.endOf('month');
        filtered = taskList.filter(
          (task) =>
            (dayjs(task.date).isSame(startOfMonth) || dayjs(task.date).isAfter(startOfMonth)) &&
            (dayjs(task.date).isSame(endOfMonth) || dayjs(task.date).isBefore(endOfMonth))
        );
        console.log("useeffect", filtered);
      }
    }

    setFilteredTasks(updateSlNo(filtered, deletedTask));
  //  console.log("useeffect filtered-task", filteredTasks);
  }, [isEdited, filterOption, currentDate, currentMonth, currentWeek, taskList, searchInput]);

  const handleFilterChange = (value: any) => {
    setFilterOption(value);
  };

  const handleLeftArrowClick = () => {
    if (filterOption === 'Date') {
      console.log("handleLeftArrowClick -prev", currentDate);
      const previousDate = currentDate.subtract(1, 'day');
      console.log("handleLeftArrowClick previousDate",previousDate)
      setCurrentDate(previousDate);

    } else if (filterOption === 'Week') {
      const previousWeekStart = currentWeek.subtract(1, 'week').startOf('week');
      const previousWeekEnd = currentWeek.subtract(1, 'week').endOf('week');
      setCurrentWeek(previousWeekStart);
      console.log("previousWeek",previousWeekStart)
    } else if (filterOption === 'Month') {
      const previousMonthStart = currentMonth.subtract(1, 'month').startOf('month');
      const previousMonthEnd = currentMonth.subtract(1, 'month').endOf('month');
      setCurrentMonth(previousMonthStart);
    }
  };

  const handleRightArrowClick = () => {
    if (filterOption === 'Date') {
      const nextDate = currentDate.add(1, 'day');
      if(nextDate.isAfter(dayjs(), 'day')){
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future weeks.',
        });
        return;
      }
      setCurrentDate(nextDate);
    } else if (filterOption === 'Week') {
      const nextWeekStart = currentWeek.add(1, 'week').startOf('week');
      const nextWeekEnd = currentWeek.add(1, 'week').endOf('week');
      if (nextWeekStart.isAfter(dayjs(), 'day')) {
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future weeks.',
        });
        return;
      }
      setCurrentWeek(nextWeekStart);
      
    } else if (filterOption === 'Month') {
      const nextMonthStart = currentMonth.add(1, 'month').startOf('month');
      if (nextMonthStart.isAfter(dayjs(), 'day')) {
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future months.',
        });
        return;
      }
      setCurrentMonth(nextMonthStart);
    }
    
  };

  const handleToggleForm = () => {
    setIsFormEnabled((prevIsFormEnabled) => !prevIsFormEnabled);
  
    // If you want to reset the form when disabling it, you can reset the form state here
    if (!isFormEnabled) {
      setAddTask({
        date: dayjs(currentDate).format('YYYY-MM-DD'),
        userId: '123',
        task: '',
        startTime: '',
        endTime: '',
        totalHours:'',
        description: '',
        reportingTo: '',
        idx: addTask.idx,
      });
    }
  };

  const handleFormSubmit = () => {
    // Check for overlapping tasks in the specified time range
    const overlappingTask = taskList.find(task => {
      const newTaskStartTime = dayjs(addTask.startTime, 'hh:mm A');
      const newTaskEndTime = dayjs(addTask.endTime, 'hh:mm A');
      const taskStartTime = dayjs(task.startTime, 'hh:mm A');
      const taskEndTime = dayjs(task.endTime, 'hh:mm A');
    
      // Check if the new task overlaps with any existing task
      return (
        !isEdited && task.date === addTask.date &&
        (
          ((newTaskStartTime.isSame(taskStartTime) || newTaskStartTime.isAfter(taskStartTime)) && newTaskStartTime.isBefore(taskEndTime)) ||
          ((newTaskEndTime.isSame(taskStartTime) || newTaskEndTime.isAfter(taskStartTime)) && newTaskEndTime.isBefore(taskEndTime)) ||
          (newTaskStartTime.isBefore(taskStartTime) && (newTaskEndTime.isSame(taskEndTime) || newTaskEndTime.isAfter(taskEndTime)))
        )
      );
    });
      
    if (overlappingTask) {
      notification.warning({
        message: 'Restricted',
        description: 'Task already exists in the specified time range.',
      });
      return;
    }

    if (isEdited) {
      // If editing, update the existing task
      const updatedTaskList = taskList.map(task =>
        task.idx === addTask.idx ? { ...addTask } : task
      );
      setTaskList(updatedTaskList);
      setFilteredTasks(updateSlNo(updatedTaskList, deletedTask));
      localStorage.setItem('taskList', JSON.stringify(updatedTaskList));
      setIsEdited(false);
    } else {
      // Update the taskList
      const updatedTaskList = [
        ...taskList,
        { ...addTask, idx: taskList.length + 1, isNew: true }
      ];
      setTaskList(updatedTaskList);
      setFilteredTasks(updateSlNo(updatedTaskList, deletedTask));
      localStorage.setItem('taskList', JSON.stringify(updatedTaskList));
    }
  
    // Clear the form with the default date and reset idx
    setAddTask({
      idx: taskList.length + 2, // Set a new idx
      date: dayjs(currentDate).format('YYYY-MM-DD'),
      userId: '123',
      task: '',
      startTime: '',
      endTime: '',
      totalHours: '',
      description: '',
      reportingTo: '',
      isNew: true, // Ensure isNew remains true
    });
    setIsEdited(false);
    setIsFormSubmitted(true);
};



  const handleClearSubmit = () => {
    // Clear the form with the default date and set idx
    setAddTask({
      date: dayjs(addTask.date).format('YYYY-MM-DD'),
      userId: '123',
      task: '',
      startTime: '',
      endTime: '',
      totalHours:'',
      description: '',
      reportingTo: '',
      idx: addTask.idx 
    });
  }
  
  const handleEditTask = (idx: number) => {
    const taskToEdit = taskList.find((task) => task.idx === idx);
    const isExistingTask = taskToEdit !== undefined; // Check if taskToEdit is defined
    // if (taskToEdit) {
        // const isDateSelected = selectedKeysToHide.includes(taskToEdit.date);
        
    //     // if (isDateSelected && isExistingTask) {
    //     //     // Date is selected and it's an existing task, so prevent further action
    //     //     // You can display a message or handle this case according to your application's logic
    //     //     return;
    //     // }

    //     // setIsEdited(true);
    //     // setAddTask({
    //     //     date: taskToEdit.date,
    //     //     userId: taskToEdit.userId,
    //     //     task: taskToEdit.task,
    //     //     startTime: taskToEdit.startTime,
    //     //     endTime: taskToEdit.endTime,
    //     //     totalHours: taskToEdit.totalHours,
    //     //     description: taskToEdit.description,
    //     //     reportingTo: taskToEdit.reportingTo,
    //     //     idx: taskToEdit.idx, 
    //     // });

    //     // // Now, you can perform additional actions or display a modal for editing
    //     // setCurrentDate(dayjs(taskToEdit.date));

    // }

    if (taskToEdit) {
      const isDateSelected = selectedKeysToHide.includes(taskToEdit.date);

      if (isDateSelected && taskToEdit.isNew) {
          // If the task is newly added and its date is selected, allow editing
          setIsEdited(true);
          setAddTask({ ...taskToEdit });
          setCurrentDate(dayjs(taskToEdit.date));
      } else if (!isDateSelected) {
          // If the date is not selected, allow editing
          setIsEdited(true);
          setAddTask({ ...taskToEdit });
          setCurrentDate(dayjs(taskToEdit.date));
      } else {
          // Date is selected and it's an existing task, so prevent further action
          // You can display a message or handle this case according to your application's logic
          return;
      }
  } else {
      // Handle the case where taskToEdit is undefined
      // You can display a message or handle this case according to your application's logic
      return;
  }
};

// const handleEditTask = (idx: number) => {
//   const taskToEdit = taskList.find((task) => task.idx === idx);
//   if (taskToEdit) {
//       setIsEdited(true);
//       setAddTask({
//           date: taskToEdit.date,
//           userId: taskToEdit.userId,
//           task: taskToEdit.task,
//           startTime: taskToEdit.startTime,
//           endTime: taskToEdit.endTime,
//           totalHours: taskToEdit.totalHours,
//           description: taskToEdit.description,
//           reportingTo: taskToEdit.reportingTo,
//           idx: taskToEdit.idx, 
//       });

//       // Now, you can perform additional actions or display a modal for editing
//       setCurrentDate(dayjs(taskToEdit.date));
//   }
// };


  const handleDeleteTask = useCallback((idx: number) => {
    // Toggle the deletedTask flag
    setDeletedTask(true);
    // Save idx in state
    setDeletedTaskIdx(idx);
  }, []);

  useEffect(() => {
    if (deletedTask) {
      // Implement the logic to delete the task based on idx
      const updatedTaskList = taskList.filter(task => {
        // Check if the task date is not included in selectedKeysToHide and isNew is true
        return !selectedKeysToHide.includes(task.date) || task.isNew;
      });
  
      // Reindex the idx starting from 1 and use deletedTask flag
      const reindexedTaskList = updateSlNo(updatedTaskList, deletedTask);
  
      setTaskList(reindexedTaskList);
      setFilteredTasks(reindexedTaskList);
  
      // Update localStorage
      localStorage.setItem('taskList', JSON.stringify(reindexedTaskList));
  
      // Reset the deletedTask flag after updating
      setDeletedTask(false);
    }
  }, [deletedTask, deletedTaskIdx, selectedKeysToHide, taskList]);
  
  // const handleOverallSubmit = () => {
  //   // Assuming you have an API endpoint for approval requests
  //   //const apiUrl = 'http://localhost:3000/approvalrequests';

  //   // Prepare the data to be sent
  //   const requestData = filteredTasks.map(task => ({
  //     date: task.date,
  //     userId: task.userId,
  //     task: task.task,
  //     startTime: task.startTime,
  //     endTime: task.endTime,
  //     totalHours: task.totalHours,
  //     description: task.description,
  //     reportingTo: task.reportingTo,
  //     idx: task.idx,
  //   }));
  //   // Navigate to the approvalrequests component with the data
  //   navigate('/approvalrequests', { state: { requestData } });
  //   // Make the HTTP POST request to the /approvalrequests endpoint
  //   // fetch(apiUrl, {
  //   //   method: 'POST',
  //   //   headers: {
  //   //     'Content-Type': 'application/json',
  //   //   },
  //   //   body: JSON.stringify(requestData),
  //   // })
  //   //   .then(response => {
  //   //     if (!response.ok) {
  //   //       console.log("network response was not okay");
  //   //       throw new Error('Network response was not ok');
          
  //   //     }
  //   //     return response.json();
  //   //   })
  //   //   .then(data => {
  //   //     // Handle the success response from the server
  //   //     console.log('Submission successful:', data);
  //   //     // You may want to show a success message or redirect the user
  //   //     // Show success notification
  //   //     notification.success({
  //   //       message: 'Submission Successful',
  //   //       description: 'Task details submitted successfully!',
  //   //     });
  //   //   })
  //   //   .catch(error => {
  //   //     // Handle errors during the fetch
  //   //     console.error('Error during submission:', error);
  //   //     // Show error notification
  //   //     notification.error({
  //   //       message: 'Submission Failed',
  //   //       description: 'There was an error submitting the task details.',
  //   //     });
  //   //     // You may want to show an error message to the user
  //   //   });
  // };

  const handleOverallSubmit = () => {
    // Prepare the data to be sent
    const requestData: Task[] = filteredTasks.map(task => ({
        date: task.date,
        userId: task.userId,
        task: task.task,
        startTime: task.startTime,
        endTime: task.endTime,
        totalHours: task.totalHours,
        description: task.description,
        reportingTo: task.reportingTo,
        idx: task.idx,
    }));

    // Set the success notification
    notification.success({
        message: 'Submission Successful',
        description: 'Task details submitted successfully!',
    });
    navigate('/approvalrequests')
    // Set the approvalRequestsData state
    console.log("handleOverAllsubmit", requestData);
    setApprovalRequestsData(requestData);

    // Store the approvalRequestsData in local storage
    localStorage.setItem('approvalRequestsData', JSON.stringify(requestData));
};

  const columns: ColumnsType<Task> = [
    {
      title: 'Sl.no',
      sorter: (a: Task, b: Task) => (a.slNo && b.slNo ? a.slNo - b.slNo : 0),
      dataIndex: 'slNo',
      key: 'slNo',
      fixed: 'left',
    },
    {
      title: 'Task',
      sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
      dataIndex: 'task',
      key: 'task',
      fixed: 'left',
    },
    {
      title: 'Date',
      sorter: (a: Task, b: Task) => a.date.localeCompare(b.date),
      dataIndex: 'date',
      key: 'date',
      fixed: 'left',
    },
    {
      title: 'Start Time',
      sorter: (a: Task, b: Task) => a.startTime.localeCompare(b.startTime),
      dataIndex: 'startTime',
      key: 'startTime',
      fixed: 'left',
    },
    {
      title: 'End Time',
      sorter: (a: Task, b: Task) => a.endTime.localeCompare(b.endTime),
      dataIndex: 'endTime',
      key: 'endTime',
      fixed: 'left',
    },
    {
      title: 'Total Hours',
      sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
      dataIndex: 'totalHours',
      key: 'totalHours',
      fixed: 'left',
    },
    {
      title: 'Description',
      sorter: (a: Task, b: Task) => a.description.localeCompare(b.description),
      dataIndex: 'description',
      key: 'description',
      fixed: 'left',
    },
    {
      title: 'Reporting To',
      sorter: (a: Task, b: Task) => a.reportingTo.localeCompare(b.reportingTo),
      dataIndex: 'reportingTo',
      key: 'reportingTo',
      fixed: 'left',
    },
    // {
    //   title: 'Actions',
    //   dataIndex: 'actions',
    //   key: 'actions',
    //   render: (_, record, index) => {
    //     const isDateSelected = selectedKeysToHide.includes(record.date); // Assuming record.date represents the date of the task
    //     return (
    //       <div>
    //         <EditOutlined
    //           onClick={() => handleEditTask(record.idx)}
    //           style={{
    //             marginRight: '8px',
    //             cursor: isDateSelected ? 'not-allowed' : 'pointer',
    //             color: isDateSelected ? 'grey' : 'blue',
    //             fontSize: '20px',
    //           }}
    //           disabled={isDateSelected}
    //         />
    //         <DeleteOutlined
    //           onClick={() => handleDeleteTask(record.idx)}
    //           style={{
    //             cursor: isDateSelected ? 'not-allowed' : 'pointer',
    //             color: isDateSelected ? 'grey' : 'red',
    //             fontSize: '20px',
    //           }}
    //           disabled={isDateSelected}
    //         />
    //       </div>
    //     );
    //   },
    // }    
    {
      title: 'Actions',
      dataIndex: 'actions',
      key: 'actions',
      render: (_, record, index) => {
        const isExistingTask = taskList.some(task => task.idx === record.idx);
        console.log("isExistingTask", isExistingTask);
        const isDateSelected = selectedKeysToHide.includes(record.date); // Assuming record.date represents the date of the task
        const isNewTask = record.isNew; // Assuming 'isNew' is a property of the task representing whether it's newly added
    
        return (
          <div>
            <EditOutlined
              onClick={() => handleEditTask(record.idx)}
              style={{
                marginRight: '8px',
                cursor: ( !isNewTask  && isDateSelected) ? 'not-allowed' : 'pointer',
                color: ( !isNewTask  && isDateSelected) ? 'grey' : 'blue',
                fontSize: '20px',
              }}
              disabled={( !isNewTask  && isDateSelected)}
            />
            <DeleteOutlined
              onClick={() => handleDeleteTask(record.idx)}
              style={{
                cursor: ( !isNewTask  && isDateSelected)? 'not-allowed' : 'pointer',
                color: ( !isNewTask  && isDateSelected) ? 'grey' : 'red',
                fontSize: '20px',
              }}
              disabled={( !isNewTask  && isDateSelected)}
            />
          </div>
        );
      },
    }
       
  ]

  return (
    <DashboardLayout>
      <div className='createuser-main'>
        <div className='header'>
          <div>
            <h1>Add Task</h1>
          </div>
          { filterOption === 'Month' ? (
            <div style={{display:'flex', justifyContent:'flex-end'}}>
              <div className='date'>From: {dayjs(currentMonth).format('YYYY-MM-DD')}</div>
              <div className='date' style={{ marginLeft: '40px' }}>To: {dayjs(currentMonth).endOf('month').format('YYYY-MM-DD')}</div>
            </div>
            ) : filterOption === 'Week' ? (
              <div style={{display:'flex', justifyContent:'flex-end'}}>
                <div className='date'>From: {dayjs(currentWeek).format('YYYY-MM-DD')}</div>
                <div className='date' style={{ marginLeft: '40px' }}>To: {dayjs(currentWeek).endOf('week').format('YYYY-MM-DD')}</div>
              </div>
            )  : (
              <div className='date'>Date: {currentDate.format('YYYY-MM-DD')}</div>
            )
          }
        </div>
        {(filterOption === 'Date' || ((filterOption === 'Week' || filterOption === 'Month') && isEdited)) || isFormEnabled  ? ( <form id="myForm" style={borderStyle}>
            <div>
            {isFormEnabled && (
              <CloseCircleOutlined
                style={{ margin: '10px 20px', display: 'flex', justifyContent: 'flex-end', color: 'red' }}
                onClick={handleToggleForm} // Call the handleToggleForm function on click
              />
            )}
              <div className='section-addtask'>
              <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label htmlFor='addTaskID'>Date</label>
                  </div>
                  {/* <input
                    type="date"
                    style={{ width: '100%' }}
                    className='timepicker'
                  /> */}
                  <Input
                    type='date'
                    placeholder='Enter your Employee ID'
                    value={currentDate.format('YYYY-MM-DD')} 
                    onChange={(e) => handleInputChange('date', e.target.value)}
                  />
                </div>
                {/* <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label htmlFor='addTaskID'>User ID</label>
                  </div>
                  <Input
                    placeholder='Enter your Employee ID'
                    value={addTask.userId}
                    onChange={(e) => handleInputChange('userId', e.target.value)}  
                  />
                </div> */}
                 <div className='create-layout-addtask'>
                  <div>
                    <label htmlFor='task'>Task</label>
                  </div>
                  <div>
                    <select
                      id='task'
                      value={addTask.task}
                      onChange={(e) => handleInputChange('task', e.target.value)}
                    >
                      {taskOptions.map((option) => (
                          <option key={option} value={option}>
                            {option}
                          </option>
                        ))}
                    </select>
                  </div>
                </div>
              </div>
              <div className='section-addtask'>
                <div className='create-layout-addtask-left'>
                  <div>
                    <label htmlFor='startTime'>Start Time</label>
                  </div>
                  <TimePicker
                    value={
                      addTask.startTime
                        ? dayjs(addTask.startTime, 'hh:mm A') // Convert to dayjs here
                        : null
                    }
                    onChange={(time, timeString) =>
                      handleInputChange('startTime', timeString)
                    }
                    className='timepicker'
                    format='hh:mm A' // Set the format to include AM/PM
                  />
                </div>
                <div className='create-layout-addtask'>
                  <div>
                    <label htmlFor='endTime'>End Time</label>
                  </div>
                  <TimePicker
                    value={
                      addTask.endTime
                        ? dayjs(addTask.endTime, 'HH:mm A') // Convert to dayjs here
                        : null
                    }
                    onChange={(time, timeString) =>
                      handleInputChange('endTime', timeString)
                    }
                    className='timepicker'
                    format='hh:mm A' 
                    rootClassName='timer'
                  />
                </div>
              </div>
              <div className='section-addtask'>
                
              <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label htmlFor='totalHours'>Total Hours</label>
                  </div>
                  <Input
                    placeholder='Enter your Total Hours'
                    value={addTask.totalHours}
                    onChange={(e) => handleInputChange('totalHours', e.target.value)}
                    
                  />
                </div>
                <div className='create-layout-addtask-reportingTo  '>
                  <div className='create-layout-reportingTo'>
                    <label htmlFor='reportingTo'>Reporting To</label>
                  </div>
                  <select
                    id='reportingTo-addtask'
                    value={addTask.reportingTo}
                    onChange={(e) => handleInputChange('reportingTo', e.target.value)}
                  >
                    <option value=''>Select Reporting To</option>
                    {reportingOptions.map((option) => (
                      <option key={option} value={option}>
                        {option}
                      </option>
                    ))}
                  </select>
                </div> 
              </div>  
              <div>
                <div className='create-layout-description'>
                  <div>
                    <label>Description</label>
                  </div>
                  <textarea
                    value={addTask.description}
                    onChange={(e) => handleInputChange('description', e.target.value)}
                    className='description-input'
                  />
                </div>
              </div>
            </div>
              
            
            <div className='button'>
              <button type='button' id='cancel-addtask' onClick={handleClearSubmit}>
                Clear
              </button>
              {isEdited ? (
              <button type='button' id='submit-addtask' onClick={handleFormSubmit}>
                Save
              </button>
            ):(
              <button type='button' id='submit-addtask' onClick={handleFormSubmit}>
                Add Task
              </button>
            )}
            </div>

        </form>):null}
        <>
        <div>
          <div style={{ display:'flex', justifyContent:'space-between', margin:'10px 20px' }}>
            <Input
            className="search-addtask"
            placeholder="Search by Date"
            allowClear
            suffix={<SearchOutlined style={{ color: "#04172480" }} />}
            onChange={(e) => {
            //  console.log("Search input value:", e.target.value);
              setSearchInput(e.target.value);
            }}
          />
         {!(filterOption === 'Date' && !isFormEnabled) && (
            <button
              id='cancel'
              onClick={handleToggleForm}
              disabled={isFormEnabled} // Disable the button when the form is enabled
            >
              Add Task
            </button>
          )}
          <div style={{display:'flex', justifyContent:'flex-end'}}>
          <button type='button' id='submit-less' onClick={handleLeftArrowClick}>
            <LeftOutlined />
          </button>

        {/* <Select
           
            style={{
              marginTop: '10px',
              display: 'flex',
              padding: '0.5em 2em',
              border: 'transparent',
              boxShadow: '2px 2px 4px rgba(0,0,0,0.4)',
              justifyContent: 'center',
              alignItems: 'center',
              gap: '10px',
              borderRadius: '4px',
              color:'white',
              background: '#0B4266',
              cursor: 'pointer',
              appearance: 'none',
              WebkitAppearance: 'none',
              MozAppearance: 'none',
            }}
            defaultValue="Date"
            onChange={handleFilterChange}
        >
          <Select.Option value="Date">Date</Select.Option>
          <Select.Option value="Week">Week</Select.Option>
          <Select.Option value="Month">Month</Select.Option>
        </Select> */}
          <select 
            id='submit' 
            style={{ appearance: 'none', WebkitAppearance: 'none', MozAppearance: 'none' }} 
            onChange={(e) => handleFilterChange(e.target.value)} value={filterOption}
          >
            <option style={{textAlign:'center'}} value='Date'>Date</option>
            <option style={{textAlign:'center'}} value='Week'>Week</option>
            <option style={{textAlign:'center'}} value='Month'>Month</option>
          </select>
          <button type='button' id='submit-less' onClick={handleRightArrowClick}>
            <RightOutlined />
          </button>
          </div>
        </div>
      </div>
        <Table
            columns={columns}
            dataSource={filteredTasks}
            pagination={false}
          />
            <button type='button' id='submit-overall' onClick={handleOverallSubmit}>
              Submit
            </button>
        </>
      </div>
    </DashboardLayout>
  );
};
export default AddTask;