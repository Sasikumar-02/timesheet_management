AddTask.tsx

import React, { useState, useEffect, useCallback, ChangeEvent } from 'react';
import { Input, TimePicker, Select, notification, DatePicker, Button} from 'antd';
import { SearchOutlined } from '@mui/icons-material';
import dayjs from 'dayjs';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { useMsal } from '@azure/msal-react';
import '../Styles/CreateUser.css';
import DashboardLayout from './Layout';
import '../Styles/AddTask.css';
import {Table} from 'antd';
import { ColumnsType } from "antd/es/table";
import ApprovalRequest from './ApprovalRequest';
import { EditOutlined, DeleteOutlined,CloseCircleOutlined,LeftOutlined, RightOutlined } from '@ant-design/icons';
import Dashboard from './Dashboard';
import {Modal} from 'antd';
import { RecentRejected, SelectedKeys, RejectedKeys } from './MonthTasks';
import asset from '../../assets/images/asset.svg';
export interface DateTask{
  key: string;
  task: Task[];
}

export interface RequestedOn {
  [key: string]: string[]; // Each key represents a month (e.g., "February 2024") with an array of dates
}


export interface Task {
  key?:string;
  idx: number; // Add this line
  date: string;
  userId: string;
  task: string;
  startTime: string;
  endTime: string;
  totalHours: string;
  description: string;
  reportingTo: string;
  slNo?: number;
}

type AddTaskProps = {
  setPieChartData: React.Dispatch<React.SetStateAction<{ [key: string]: number }>>;
  setApprovalRequestsData: React.Dispatch<React.SetStateAction<Task[]>>;
  approvalRequestsData: Task[];
};

const AddTask: React.FC<AddTaskProps> = ({ setPieChartData, setApprovalRequestsData }) => {
  const userId = '123';
  const { Option } = Select; // Destructure the Option component from Select
  const navigate = useNavigate();
  const {confirm}= Modal;
  const location = useLocation();
  const { formattedDate } = location.state || { formattedDate: dayjs() }; // Access formattedDate from location.state
  const [deletedTask, setDeletedTask] = useState(false);
  const [formWidth, setFormWidth] = useState(800);
  const [currentDate, setCurrentDate] = useState(dayjs(formattedDate));
  const [currentWeek, setCurrentWeek] = useState(dayjs().startOf('week'));
  const [currentMonth, setCurrentMonth] = useState(dayjs().startOf('month'));
  const [isFormEnabled, setIsFormEnabled] = useState(false);
  const [cancelButton, setCancelButton] = useState(false);
  const [addTask, setAddTask] = useState<Task>({
    idx: 1, // Set initial idx
    date: currentDate.format('YYYY-MM-DD'),
    userId: userId,
    task: '',
    startTime: '',
    endTime: '',
    totalHours: '',
    description: '',
    reportingTo: '',
  });
  const [deletedTaskIdx, setDeletedTaskIdx] = useState<number | null>(null);
  const [taskList, setTaskList] = useState<Task[]>([]);
  const [filteredTasks, setFilteredTasks] = useState<Task[]>([]);
  const reportingOptions = ['ManagerA', 'ManagerB', 'ManagerC'];
  const taskOptions = ['Task','Project','Learning','Training','Meeting'];
  const [filterOption, setFilterOption] = useState('Date');
  const [isEdited, setIsEdited]= useState<boolean>(false);
  // State to manage the search input
  const [searchInput, setSearchInput] = useState('');
  const [isFormSubmitted, setIsFormSubmitted] = useState(false);
  const [selectedKeysToHide, setSelectedKeysToHide]=useState<string[]>([]);
 const updateSlNo = (tasks: Task[], deleteTask: boolean): Task[] => {
  return tasks.map((task, index) => ({
    ...task,
    slNo: index + 1,
    idx: deleteTask ? index + 1 : task.idx
  }));
};

  useEffect(() => {
    const updateFormWidth = () => {
      const formElement = document.getElementById('myForm');
      if (formElement) {
        const newWidth = formElement.offsetWidth;
        setFormWidth(newWidth);
      }
    };

    window.addEventListener('resize', updateFormWidth);
    updateFormWidth();

    return () => {
      window.removeEventListener('resize', updateFormWidth);
    };
  }, []);

  const borderStyle = {
    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)', // Add box shadow
    margin: '10px 20px',
   // padding: '10px 20px',
    //width: formWidth + 'px',
    width: '1350px',
    height:'540px'
  };

  useEffect(() => {
    const storedKeysString: string | null = localStorage.getItem('selectedKeys');
    if (storedKeysString !== null) {
        const storedKeys: SelectedKeys = JSON.parse(storedKeysString);
        if (storedKeys.hasOwnProperty(userId)) {
            setSelectedKeysToHide(storedKeys[userId]);
        } else {
            console.log("User ID not found in stored keys");
        }
    } else {
        console.log("else-useEffect", storedKeysString);
    }
}, []);
  
  const handleInputChange = (field: keyof Task, value: string) => {
    if (field === 'date') {
      const selectedDate = dayjs(value);
      if (selectedDate.isAfter(dayjs(), 'day')) {
        // Display a notification
        notification.warning({
          message: 'Warning',
          description: 'Cannot select a future date.',
        });
        // Set the selected date to today
        setCurrentDate(dayjs());
      } else {
        // Update the state with the selected date
        setCurrentDate(selectedDate);
      }
    }
  
    // Keep userId constant
    if (field === 'userId') {
      setAddTask((prevTask) => ({ ...prevTask, [field]: value }));
    } else {
      // Update startTime or endTime with the new value
      const updatedTime = value || dayjs().format('hh:mm A');
      setAddTask((prevTask) => ({ ...prevTask, [field]: updatedTime }));
      // Calculate the duration and update totalHours
      const updatedStartTime = field === 'startTime' ? updatedTime : addTask.startTime || dayjs().format('hh:mm A');
      const updatedEndTime = field === 'endTime' ? updatedTime : addTask.endTime || dayjs().format('hh:mm A');
      const duration = dayjs(updatedEndTime, 'hh:mm A').diff(dayjs(updatedStartTime, 'hh:mm A'), 'hour', true);
      setAddTask((prevTask) => ({
        ...prevTask,
        startTime: field === 'startTime' ? updatedTime : addTask.startTime,
        endTime: field === 'endTime' ? updatedTime : addTask.endTime,
        totalHours: duration.toFixed(2),
      }));
    }
  };
  
  useEffect(() => {
    const storedTaskListString = localStorage.getItem('taskList');
    const storedTaskList = storedTaskListString ? JSON.parse(storedTaskListString) : [];

    // Filter tasks based on the userId
    //const userTaskList = storedTaskList.filter((task:Task)=> task.userId === userId);

    // Assuming deletedTask is a state variable
    const updatedTaskList = updateSlNo(storedTaskList, deletedTask);

    setTaskList(updatedTaskList);
    setFilteredTasks(updatedTaskList);
  }, [deletedTask]); // Include deletedTask in the dependency array

  useEffect(() => {
    // Filter tasks based on the addTask.date and userId when it changes
    if (addTask.date) {
        const filtered = taskList.filter(task => task.date === addTask.date && task.userId === userId);
        setFilteredTasks(updateSlNo(filtered, deletedTask)); // Update slNo when loading tasks
    } else {
        // If no date is selected, display all tasks
        setFilteredTasks(updateSlNo(taskList, deletedTask)); // Update slNo when loading tasks
    }
}, [addTask.date, taskList]);


  useEffect(() => {
    // Update addTask with the current date
    if (!isEdited) {
      // Update addTask with the current date only when not in edit mode
      setAddTask((prevAddTask) => ({
        ...prevAddTask,
        date: dayjs(currentDate).format('YYYY-MM-DD'),
    }));
  }
    //setFilteredTasks(taskList);
    // Filter tasks based on the filterOption and currentDate when they change
    let filtered: Task[] = [];

    if (searchInput) {
      // If there is a search input, filter tasks based on date or month
      const searchDate = dayjs(searchInput);
      filtered = taskList.filter((task) => {
          if (filterOption === 'Date') {
            return ((dayjs(task.date).isSame(searchDate, 'day'))&&(task.userId===userId));
            } else if (filterOption === 'Week') {
              const startOfWeek = currentWeek.startOf('week');
              const endOfWeek = currentWeek.endOf('week');
              return (
                (dayjs(task.date).isSame(startOfWeek) || dayjs(task.date).isAfter(startOfWeek)) &&
                (dayjs(task.date).isSame(endOfWeek) || dayjs(task.date).isBefore(endOfWeek)) &&
                task.userId===userId
              );
            } else if (filterOption === 'Month') {
              // Format the searchInput in the same way as the task date
              const formattedSearchMonth = searchDate.format('MMMM');
              return ((dayjs(task.date).format('MMMM') === formattedSearchMonth) && (task.userId===userId));
            }
        return false;
      });
    }  else {
      // If no search input, apply the regular filtering based on filterOption and currentDate
      if (filterOption === 'Date') {
        filtered = taskList.filter((task) => 
          task.date === dayjs(currentDate).format('YYYY-MM-DD') && task.userId===userId);
        console.log("useEffect-date", filtered)
      } else if (filterOption === 'Week') {
        const startOfWeek = currentWeek.startOf('week');
        const endOfWeek = currentWeek.endOf('week');
        filtered = taskList.filter(
          (task) =>
            (dayjs(task.date).isSame(startOfWeek) || dayjs(task.date).isAfter(startOfWeek)) &&
            (dayjs(task.date).isSame(endOfWeek) || dayjs(task.date).isBefore(endOfWeek)) &&
            task.userId ===userId
        );
        console.log("useeffect-week", filtered);
      } else if (filterOption === 'Month') {
        const startOfMonth = currentMonth.startOf('month');
        const endOfMonth = currentMonth.endOf('month');
        filtered = taskList.filter(
          (task) =>
            (dayjs(task.date).isSame(startOfMonth) || dayjs(task.date).isAfter(startOfMonth)) &&
            (dayjs(task.date).isSame(endOfMonth) || dayjs(task.date).isBefore(endOfMonth)) && 
            (task.userId === userId)
        );
        console.log("useeffect", filtered);
      }
    }

    setFilteredTasks(updateSlNo(filtered, deletedTask));
  //  console.log("useeffect filtered-task", filteredTasks);
  }, [isEdited, filterOption, currentDate, currentMonth, currentWeek, taskList, searchInput]);

  const handleFilterChange = (value: any) => {
    setFilterOption(value);
  };

  const handleLeftArrowClick = () => {
    if (filterOption === 'Date') {
      console.log("handleLeftArrowClick -prev", currentDate);
      const previousDate = currentDate.subtract(1, 'day');
      console.log("handleLeftArrowClick previousDate",previousDate)
      setCurrentDate(previousDate);

    } else if (filterOption === 'Week') {
      const previousWeekStart = currentWeek.subtract(1, 'week').startOf('week');
      const previousWeekEnd = currentWeek.subtract(1, 'week').endOf('week');
      setCurrentWeek(previousWeekStart);
      console.log("previousWeek",previousWeekStart)
    } else if (filterOption === 'Month') {
      const previousMonthStart = currentMonth.subtract(1, 'month').startOf('month');
      const previousMonthEnd = currentMonth.subtract(1, 'month').endOf('month');
      setCurrentMonth(previousMonthStart);
    }
  };

  const handleRightArrowClick = () => {
    if (filterOption === 'Date') {
      const nextDate = currentDate.add(1, 'day');
      if(nextDate.isAfter(dayjs(), 'day')){
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future weeks.',
        });
        return;
      }
      setCurrentDate(nextDate);
    } else if (filterOption === 'Week') {
      const nextWeekStart = currentWeek.add(1, 'week').startOf('week');
      const nextWeekEnd = currentWeek.add(1, 'week').endOf('week');
      if (nextWeekStart.isAfter(dayjs(), 'day')) {
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future weeks.',
        });
        return;
      }
      setCurrentWeek(nextWeekStart);
      
    } else if (filterOption === 'Month') {
      const nextMonthStart = currentMonth.add(1, 'month').startOf('month');
      if (nextMonthStart.isAfter(dayjs(), 'day')) {
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future months.',
        });
        return;
      }
      setCurrentMonth(nextMonthStart);
    }
    
  };

  const handleToggleForm = () => {
    setIsFormEnabled((prevIsFormEnabled) => !prevIsFormEnabled);
    setCancelButton((prevIsFormEnabled) => !prevIsFormEnabled);
    // If you want to reset the form when disabling it, you can reset the form state here
    if (!isFormEnabled) {
      setAddTask({
        date: dayjs(currentDate).format('YYYY-MM-DD'),
        userId:userId,
        task: '',
        startTime: '',
        endTime: '',
        totalHours:'',
        description: '',
        reportingTo: '',
        idx: addTask.idx,
      });
    }
  };

  const handleFormSubmit = () => {

    // Check if the addTask date is included in selectedKeysToHide
    if (selectedKeysToHide.includes(addTask.date)) {
      notification.warning({
          message: 'Restricted',
          description: `The Task Approved: ${addTask.date} & Restrict to Add New Task`,
      });
      return;
  }

    // Check for overlapping tasks in the specified time range
    const overlappingTask = taskList.find(task => {
      if(task.userId !== addTask.userId) return false;
      const newTaskStartTime = dayjs(addTask.startTime, 'hh:mm A');
      const newTaskEndTime = dayjs(addTask.endTime, 'hh:mm A');
      const taskStartTime = dayjs(task.startTime, 'hh:mm A');
      const taskEndTime = dayjs(task.endTime, 'hh:mm A');
    
      // Check if the new task overlaps with any existing task
      return (
        !isEdited && task.date === addTask.date &&
        (
          ((newTaskStartTime.isSame(taskStartTime) || newTaskStartTime.isAfter(taskStartTime)) && newTaskStartTime.isBefore(taskEndTime)) ||
          ((newTaskEndTime.isSame(taskStartTime) || newTaskEndTime.isAfter(taskStartTime)) && newTaskEndTime.isBefore(taskEndTime)) ||
          (newTaskStartTime.isBefore(taskStartTime) && (newTaskEndTime.isSame(taskEndTime) || newTaskEndTime.isAfter(taskEndTime)))
        )
      );
    });
      
    if (overlappingTask) {
      notification.warning({
        message: 'Restricted',
        description: 'Task already exists in the specified time range.',
      });
      return;
    }

    if (isEdited) {
      // If editing, update the existing task
      const updatedTaskList = taskList.map(task =>
        (task.idx === addTask.idx) && (task.userId === addTask.userId)
         ? { ...addTask } : task
      );
      setTaskList(updatedTaskList);
      setFilteredTasks(updateSlNo(updatedTaskList, deletedTask));
      localStorage.setItem('taskList', JSON.stringify(updatedTaskList));
      setIsEdited(false);
    } else {
      // Update the taskList
      const updatedTaskList = [
        ...taskList,
        { ...addTask, idx: taskList.length + 1 }
      ];
      setTaskList(updatedTaskList);
      setFilteredTasks(updateSlNo(updatedTaskList, deletedTask));
      localStorage.setItem('taskList', JSON.stringify(updatedTaskList));
    }
  
    // Clear the form with the default date and reset idx
    setAddTask({
      idx: taskList.length + 2, // Set a new idx
      date: dayjs(currentDate).format('YYYY-MM-DD'),
      userId: userId,
      task: '',
      startTime: '',
      endTime: '',
      totalHours: '',
      description: '',
      reportingTo: '',
    });
    setIsEdited(false);
    setIsFormSubmitted(true);
};

  const handleClearSubmit = () => {
    // Clear the form with the default date and set idx
    setAddTask({
      date: dayjs(addTask.date).format('YYYY-MM-DD'),
      userId: userId,
      task: '',
      startTime: '',
      endTime: '',
      totalHours:'',
      description: '',
      reportingTo: '',
      idx: addTask.idx 
    });
  }
  
//   const handleEditTask = (idx: number) => {
//     const taskToEdit = taskList.find((task) => task.idx === idx);
//     const isExistingTask = taskToEdit !== undefined; // Check if taskToEdit is defined
//     // if (taskToEdit) {
//         // const isDateSelected = selectedKeysToHide.includes(taskToEdit.date);
        
//     //     // if (isDateSelected && isExistingTask) {
//     //     //     // Date is selected and it's an existing task, so prevent further action
//     //     //     // You can display a message or handle this case according to your application's logic
//     //     //     return;
//     //     // }

//     //     // setIsEdited(true);
//     //     // setAddTask({
//     //     //     date: taskToEdit.date,
//     //     //     userId: taskToEdit.userId,
//     //     //     task: taskToEdit.task,
//     //     //     startTime: taskToEdit.startTime,
//     //     //     endTime: taskToEdit.endTime,
//     //     //     totalHours: taskToEdit.totalHours,
//     //     //     description: taskToEdit.description,
//     //     //     reportingTo: taskToEdit.reportingTo,
//     //     //     idx: taskToEdit.idx, 
//     //     // });

//     //     // // Now, you can perform additional actions or display a modal for editing
//     //     // setCurrentDate(dayjs(taskToEdit.date));

//     // }

//     if (taskToEdit) {
//       const isDateSelected = selectedKeysToHide.includes(taskToEdit.date);

//       if (isDateSelected && taskToEdit.isNew) {
//           // If the task is newly added and its date is selected, allow editing
//           setIsEdited(true);
//           setAddTask({ ...taskToEdit });
//           setCurrentDate(dayjs(taskToEdit.date));
//       } else if (!isDateSelected) {
//           // If the date is not selected, allow editing
//           setIsEdited(true);
//           setAddTask({ ...taskToEdit });
//           setCurrentDate(dayjs(taskToEdit.date));
//       } else {
//           // Date is selected and it's an existing task, so prevent further action
//           // You can display a message or handle this case according to your application's logic
//           return;
//       }
//   } else {
//       // Handle the case where taskToEdit is undefined
//       // You can display a message or handle this case according to your application's logic
//       return;
//   }
// };

const handleEditTask = (idx: number) => {
  const taskToEdit = taskList.find((task) => (task.idx === idx) && (task.userId === addTask.userId));
  if (taskToEdit) {
    // Check if the date is included in selectedKeysToHide
    if (selectedKeysToHide.includes(taskToEdit.date)) {
      // Date is included in selectedKeysToHide, so prevent further action
      // You can display a message or handle this case according to your application's logic
      return;
    }

    setIsEdited(true);
  
    setAddTask({
        date: taskToEdit.date,
        userId: taskToEdit.userId,
        task: taskToEdit.task,
        startTime: taskToEdit.startTime,
        endTime: taskToEdit.endTime,
        totalHours: taskToEdit.totalHours,
        description: taskToEdit.description,
        reportingTo: taskToEdit.reportingTo,
        idx: taskToEdit.idx, 
    });

    // Now, you can perform additional actions or display a modal for editing
    setCurrentDate(dayjs(taskToEdit.date));
  }
};

const handleDeleteTask = useCallback((idx: number) => {
  const taskToDelete = taskList.find(task => (task.idx === idx));  //&&(task.userId === addTask.userId)
  
  if (!taskToDelete || selectedKeysToHide.includes(taskToDelete.date)) {
    // Task not found or its date is in selectedKeysToHide, do not delete
    return;
  }

  // Display confirmation modal before deleting the task
  confirm({
    title: 'Delete Task',
    content: 'Are you sure you want to delete the task?',
    okText: 'Yes',
    okButtonProps: {
      style: {
        width: '80px', backgroundColor: '#0B4266', color: 'white'
      },
    },
    cancelText: 'No',
    cancelButtonProps: {
      style: {
        width: '80px', backgroundColor: '#0B4266', color: 'white'
      },
    },
    onOk() {
      // Logic to delete the task if user confirms
      const updatedTaskList = taskList.filter(task => (task.idx !== idx)); //&&(task.userId==addTask.userId)
  
      // Reindex the idx starting from 1
      const reindexedTaskList = updateSlNo(updatedTaskList, true);
  
      setTaskList(reindexedTaskList);
      setFilteredTasks(reindexedTaskList);
  
      // Update localStorage
      localStorage.setItem('taskList', JSON.stringify(reindexedTaskList));
    },
    onCancel() {
      // Logic if user cancels deletion
    },
  });
}, [taskList, selectedKeysToHide]);


// const handleDeleteTask = useCallback((idx: number) => {
//   // Check if the date is included in selectedKeysToHide
//   const isDateIncluded = selectedKeysToHide.some(date => {
//       // Assuming taskList contains tasks with a 'date' property
//       const task = taskList.find(task => task.idx === idx);
//       return task && task.date === date;
//   });

//   // Toggle the deletedTask flag based on the presence of the date in selectedKeysToHide
//   setDeletedTask(!isDateIncluded);

//   // Save idx in state
//   setDeletedTaskIdx(idx);
// }, [selectedKeysToHide, taskList]);


//   useEffect(() => {
//     if (deletedTask) {
//       // Implement the logic to delete the task based on idx
//       const updatedTaskList = taskList.filter(task => {
//         // Check if the task date is not included in selectedKeysToHide and isNew is true
//         return !selectedKeysToHide.includes(task.date);
//       });
  
//       // Reindex the idx starting from 1 and use deletedTask flag
//       const reindexedTaskList = updateSlNo(updatedTaskList, deletedTask);
  
//       setTaskList(reindexedTaskList);
//       setFilteredTasks(reindexedTaskList);
  
//       // Update localStorage
//       localStorage.setItem('taskList', JSON.stringify(reindexedTaskList));
  
//       // Reset the deletedTask flag after updating
//       setDeletedTask(false);
//     }
//   }, [deletedTask, deletedTaskIdx, selectedKeysToHide, taskList]);

  // const handleDeleteTask = useCallback((idx: number) => {
  //   // Display confirmation modal before deleting the task
  //   confirm({
  //     title: 'Delete Task',
  //     content: 'Are you sure you want to delete the task?',
  //     okText: 'Yes',
  //     okButtonProps: {
  //       style: {
  //         width: '80px', backgroundColor: '#0B4266', color: 'white'
  //       },
  //     },
  //     cancelText: 'No',
  //     cancelButtonProps: {
  //       style: {
  //         width: '80px', backgroundColor: '#0B4266', color: 'white'
  //       },
  //     },
  //     onOk() {
  //       // Logic to delete the task if user confirms
  //       const updatedTaskList = taskList.filter(task => task.idx !== idx);
    
  //       // Reindex the idx starting from 1
  //       const reindexedTaskList = updateSlNo(updatedTaskList);
    
  //       setTaskList(reindexedTaskList);
  //       setFilteredTasks(reindexedTaskList);
    
  //       // Update localStorage
  //       localStorage.setItem('taskList', JSON.stringify(reindexedTaskList));
  //     },
  //     onCancel() {
  //       // Logic if user cancels deletion
  //     },
  //   });
  // }, [taskList]);

  
  
  // const handleOverallSubmit = () => {
  //   // Assuming you have an API endpoint for approval requests
  //   //const apiUrl = 'http://localhost:3000/approvalrequests';

  //   // Prepare the data to be sent
  //   const requestData = filteredTasks.map(task => ({
  //     date: task.date,
  //     userId: task.userId,
  //     task: task.task,
  //     startTime: task.startTime,
  //     endTime: task.endTime,
  //     totalHours: task.totalHours,
  //     description: task.description,
  //     reportingTo: task.reportingTo,
  //     idx: task.idx,
  //   }));
  //   // Navigate to the approvalrequests component with the data
  //   navigate('/approvalrequests', { state: { requestData } });
  //   // Make the HTTP POST request to the /approvalrequests endpoint
  //   // fetch(apiUrl, {
  //   //   method: 'POST',
  //   //   headers: {
  //   //     'Content-Type': 'application/json',
  //   //   },
  //   //   body: JSON.stringify(requestData),
  //   // })
  //   //   .then(response => {
  //   //     if (!response.ok) {
  //   //       console.log("network response was not okay");
  //   //       throw new Error('Network response was not ok');
          
  //   //     }
  //   //     return response.json();
  //   //   })
  //   //   .then(data => {
  //   //     // Handle the success response from the server
  //   //     console.log('Submission successful:', data);
  //   //     // You may want to show a success message or redirect the user
  //   //     // Show success notification
  //   //     notification.success({
  //   //       message: 'Submission Successful',
  //   //       description: 'Task details submitted successfully!',
  //   //     });
  //   //   })
  //   //   .catch(error => {
  //   //     // Handle errors during the fetch
  //   //     console.error('Error during submission:', error);
  //   //     // Show error notification
  //   //     notification.error({
  //   //       message: 'Submission Failed',
  //   //       description: 'There was an error submitting the task details.',
  //   //     });
  //   //     // You may want to show an error message to the user
  //   //   });
  // };

//   const handleOverallSubmit = () => {
//     // Prepare the data to be sent
//     const requestData: Task[] = filteredTasks.map(task => ({
//         date: task.date,
//         userId: task.userId,
//         task: task.task,
//         startTime: task.startTime,
//         endTime: task.endTime,
//         totalHours: task.totalHours,
//         description: task.description,
//         reportingTo: task.reportingTo,
//         idx: task.idx,
//     }));

//     // Set the success notification
//     notification.success({
//         message: 'Submission Successful',
//         description: 'Task details submitted successfully!',
//     });
//     navigate('/approvalrequests')
//     // Set the approvalRequestsData state
//     console.log("handleOverAllsubmit", requestData);
//     setApprovalRequestsData(requestData);
//     localStorage.setItem('requestedOn', addTask.date);
//     // Store the approvalRequestsData in local storage
//     localStorage.setItem('approvalRequestsData', JSON.stringify(requestData));

//     // Retrieve rejectedKeys from local storage
//     const rejectedKeysString = localStorage.getItem('rejectedKeys');
//     console.log("rejectedKeysString",rejectedKeysString);
//     if (rejectedKeysString) {
//       let parsedRejectedKeys: RecentRejected[] = JSON.parse(rejectedKeysString);
//       console.log("rejectedKeys", parsedRejectedKeys);
//       // Check if 'submit' exists in rejectedKeys
//       const date = requestData.length > 0 ? requestData[0].date : '';
//       if (parsedRejectedKeys.some((key) => key.date === date)) {
//         // Remove 'date' from rejectedKeys
//         const updatedRejectedKeys = parsedRejectedKeys.filter((key) => key.date !== date);

//         // Update rejectedKeys in local storage
//         localStorage.setItem('rejectedKeys', JSON.stringify(updatedRejectedKeys));
//     }
//     }
// };



const handleOverallSubmit = () => {

  // Filter tasks where userId matches addTask.userId
  const tasksToSend: Task[] = filteredTasks.filter(task => task.userId === addTask.userId);
    // Prepare the data to be sent
    const requestData: Task[] = tasksToSend.map(task => ({
        date: task.date,
        userId: task.userId,
        task: task.task,
        startTime: task.startTime,
        endTime: task.endTime,
        totalHours: task.totalHours,
        description: task.description,
        reportingTo: task.reportingTo,
        idx: task.idx,
    }));

    // Group tasks by date
    const groupedTasks: { [date: string]: Task[] } = {};
    requestData.forEach(task => {
        if (groupedTasks.hasOwnProperty(task.date)) {
            groupedTasks[task.date].push(task);
        } else {
            groupedTasks[task.date] = [task];
        }
    });

        // Determine the key based on the filterOption
    let key: string;
    if (filterOption === "Date") {
        key = currentDate.format("MMMM YYYY"); // Format Dayjs object to "February 2024"
    } else if (filterOption === 'Week') {
        key = currentWeek.startOf('week').format("MMMM YYYY"); // Format Dayjs object to "February 2024"
    } else {
        key = currentMonth.startOf('month').format("MMMM YYYY"); // Format Dayjs object to "February 2024"
    }

    let date: string[] = [];
    if (filterOption === "Date") {
        date.push(currentDate.format('YYYY-MM-DD')); // Format Dayjs object to "February 2024"
    } else if (filterOption === 'Week') {
        const fromDate = currentWeek.startOf('week').format("YYYY-MM-DD"); // Format Dayjs object to "February 2024"
        const toDate = currentWeek.endOf('week').format("YYYY-MM-DD");
        date.push(fromDate);
        date.push(toDate);
    } else {
        const fromDate = currentMonth.startOf('month').format("YYYY-MM-DD"); // Format Dayjs object to "February 2024"
        const toDate = currentMonth.endOf('month').format("YYYY-MM-DD");
        date.push(fromDate);
        date.push(toDate);
    }

    // Retrieve requestedOn from local storage
    const requestedOnString = localStorage.getItem('requestedOn');
    const requestedOn: RequestedOn = requestedOnString ? JSON.parse(requestedOnString) : {};

    // Update requestedOn with the new date
    requestedOn[key] = date;

    // Update requestedOn in local storage
    localStorage.setItem('requestedOn', JSON.stringify(requestedOn));


    // Store the approvalRequestsData in local storage as an object
    const approvalRequestedData: { [date: string]: Task[] } = groupedTasks;
    localStorage.setItem('approvalRequestedData', JSON.stringify(approvalRequestedData));

    // Assuming userId is available in your component's scope

    // Retrieve rejectedKeys from local storage for the specific userId
    const rejectedKeysString = localStorage.getItem('rejectedKeys');
    console.log("rejectedKeysString", rejectedKeysString);

    if (rejectedKeysString) {
        const parsedRejectedKeys: RejectedKeys = JSON.parse(rejectedKeysString);
        console.log("rejectedKeys", parsedRejectedKeys);

        // Check if userId exists in rejectedKeys
        if (parsedRejectedKeys.hasOwnProperty(userId)) {
            // Get the rejectedKeys for the specific userId
            const userRejectedKeys = parsedRejectedKeys[userId];

            // Check if 'submit' exists in rejectedKeys for the specific user
            const date = requestData.length > 0 ? requestData[0].date : '';
            if (userRejectedKeys.some((key) => key.date === date)) {
                // Remove 'date' from rejectedKeys for the specific user
                const updatedRejectedKeys = userRejectedKeys.filter((key) => key.date !== date);

                // Update rejectedKeys in local storage for the specific user
                parsedRejectedKeys[userId] = updatedRejectedKeys;
                localStorage.setItem('rejectedKeys', JSON.stringify(parsedRejectedKeys));
            }
        }
    }

    // Set the success notification
    notification.success({
        message: 'Submission Successful',
        description: 'Task details submitted successfully!',
    });

    // Navigate to approval requests page
    navigate('/approvalrequests');
};

  const columns: ColumnsType<Task> = [
    {
      title: 'Sl.no',
      //sorter: (a: Task, b: Task) => (a.slNo && b.slNo ? a.slNo - b.slNo : 0),
      dataIndex: 'slNo',
      key: 'slNo',
      fixed: 'left',
    },
    {
      title: 'Task',
      //sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
      dataIndex: 'task',
      key: 'task',
      fixed: 'left',
    },
    {
      title: 'Date',
      //sorter: (a: Task, b: Task) => a.date.localeCompare(b.date),
      dataIndex: 'date',
      key: 'date',
      fixed: 'left',
    },
    {
      title: 'Start Time',
      //sorter: (a: Task, b: Task) => a.startTime.localeCompare(b.startTime),
      dataIndex: 'startTime',
      key: 'startTime',
      fixed: 'left',
    },
    {
      title: 'End Time',
      //sorter: (a: Task, b: Task) => a.endTime.localeCompare(b.endTime),
      dataIndex: 'endTime',
      key: 'endTime',
      fixed: 'left',
    },
    {
      title: 'Total Hours',
      //sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
      dataIndex: 'totalHours',
      key: 'totalHours',
      fixed: 'left',
    },
    {
      title: 'Description',
      //sorter: (a: Task, b: Task) => a.description.localeCompare(b.description),
      dataIndex: 'description',
      key: 'description',
      fixed: 'left',
    },
    {
      title: 'Reporting To',
      //sorter: (a: Task, b: Task) => a.reportingTo.localeCompare(b.reportingTo),
      dataIndex: 'reportingTo',
      key: 'reportingTo',
      fixed: 'left',
    },
    // {
    //   title: 'Actions',
    //   dataIndex: 'actions',
    //   key: 'actions',
    //   render: (_, record, index) => {
    //     const isDateSelected = selectedKeysToHide.includes(record.date); // Assuming record.date represents the date of the task
    //     return (
    //       <div>
    //         <EditOutlined
    //           onClick={() => handleEditTask(record.idx)}
    //           style={{
    //             marginRight: '8px',
    //             cursor: isDateSelected ? 'not-allowed' : 'pointer',
    //             color: isDateSelected ? 'grey' : 'blue',
    //             fontSize: '20px',
    //           }}
    //           disabled={isDateSelected}
    //         />
    //         <DeleteOutlined
    //           onClick={() => handleDeleteTask(record.idx)}
    //           style={{
    //             cursor: isDateSelected ? 'not-allowed' : 'pointer',
    //             color: isDateSelected ? 'grey' : 'red',
    //             fontSize: '20px',
    //           }}
    //           disabled={isDateSelected}
    //         />
    //       </div>
    //     );
    //   },
    // }    
    {
      title: 'Actions',
      dataIndex: 'actions',
      key: 'actions',
      render: (_, record, index) => {
        const isExistingTask = taskList.some(task => task.idx === record.idx);
        const isDateSelected = selectedKeysToHide.includes(record.date);
        
        // Filter tasks by userId
        const userTasks = taskList.filter(task => task.userId === record.userId);
        
        // Check if the user has tasks for the selected date
        const hasUserTasksForDate = userTasks.some(task => task.date === record.date);
    
        return (
          <div>
            <EditOutlined
              onClick={() => handleEditTask(record.idx)}
              style={{
                marginRight: '8px',
                cursor: (isDateSelected || !hasUserTasksForDate) ? 'not-allowed' : 'pointer',
                color: (isDateSelected || !hasUserTasksForDate) ? 'grey' : 'blue', 
                fontSize: '20px',
              }}
              disabled={isDateSelected || !hasUserTasksForDate}
            />
            <DeleteOutlined
              onClick={() => handleDeleteTask(record.idx)}
              style={{
                cursor: (isDateSelected || !hasUserTasksForDate) ? 'not-allowed' : 'pointer',
                color: (isDateSelected || !hasUserTasksForDate) ? 'grey' : 'red',
                fontSize: '20px',
              }}
              disabled={isDateSelected || !hasUserTasksForDate}
            />
          </div>
        );
      },
    }    
    
       
  ]

  return (
    <DashboardLayout>
      <div className='createuser-main'>
        <div className='header'>
          <div>
            <h1>Add Task</h1>
          </div>
          { filterOption === 'Month' ? (
            <div style={{display:'flex', justifyContent:'flex-end'}}>
              <div className='date'>From: {dayjs(currentMonth).format('YYYY-MM-DD')}</div>
              <div className='date' style={{ marginLeft: '40px' }}>To: {dayjs(currentMonth).endOf('month').format('YYYY-MM-DD')}</div>
            </div>
            ) : filterOption === 'Week' ? (
              <div style={{display:'flex', justifyContent:'flex-end'}}>
                <div className='date'>From: {dayjs(currentWeek).format('YYYY-MM-DD')}</div>
                <div className='date' style={{ marginLeft: '40px' }}>To: {dayjs(currentWeek).endOf('week').format('YYYY-MM-DD')}</div>
              </div>
            )  : (
              <div className='date'>Date: {currentDate.format('YYYY-MM-DD')}</div>
            )
          }
        </div>
        {(filterOption === 'Date' || ((filterOption === 'Week' || filterOption === 'Month') && isEdited)) || isFormEnabled  ? ( <form id="myForm" style={borderStyle}>
            <div>
              {isFormEnabled && (
                <CloseCircleOutlined
                  style={{ margin: '10px 20px', display: 'flex', justifyContent: 'flex-end', color: 'red' }}
                  onClick={handleToggleForm} // Call the handleToggleForm function on click
                />
              )}
              <div className='section-addtask' style={{width:'70%'}}>
                <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label style={{color:'#0B4266'}} htmlFor='addTaskID'>Date</label>
                  </div>
                  {/* <input
                    type="date"
                    style={{ width: '100%' }}
                    className='timepicker'
                  /> */}
                  <Input
                    type='date'
                    
                    placeholder='Enter your Employee ID'
                    value={currentDate.format('YYYY-MM-DD')} 
                    onChange={(e) => handleInputChange('date', e.target.value)}
                  />
                  {/* <DatePicker
                      value={dayjs(currentDate)} // Convert currentDate to Dayjs object
                      format="YYYY-MM-DD" // Specify the date format
                      onChange={(date, dateString) => handleInputChange('date', dateString)} // Use dateString to get the selected date
                      style={{ width: '100%', height:'35%' }} // Adjust the width as needed
                  /> */}
                </div>
                {/* <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label htmlFor='addTaskID'>User ID</label>
                  </div>
                  <Input
                    placeholder='Enter your Employee ID'
                    value={addTask.userId}
                    onChange={(e) => handleInputChange('userId', e.target.value)}  
                  />
                </div> */}
                 <div className='create-layout-addtask'>
                  <div>
                    <label style={{color:'#0B4266'}} htmlFor='task'>Task</label>
                  </div>
                  <div>
                    <select
                      id='task'
                      value={addTask.task}
                      onChange={(e) => handleInputChange('task', e.target.value)}
                    >
                      {taskOptions.map((option) => (
                          <option key={option} value={option}>
                            {option}
                          </option>
                        ))}
                    </select>
                  </div>
                  
                </div>
                <div className='create-layout-addtask'>
                  <div>
                    <label style={{color:'#0B4266'}} htmlFor='task'>Task</label>
                  </div>
                  <div>
                    <select
                      id='task'
                      value={addTask.task}
                      onChange={(e) => handleInputChange('task', e.target.value)}
                    >
                      {taskOptions.map((option) => (
                          <option key={option} value={option}>
                            {option}
                          </option>
                        ))}
                    </select>
                  </div>
                  
                </div>
              </div>
              <div style={{display:'flex', alignItems:'flex-end'}}>
                <div>
                  <div className='section-addtask' style={{width:'140%'}}>
                    <div className='create-layout-addtask-left'>
                      <div>
                        <label htmlFor='startTime'>Start Time</label>
                      </div>
                      <TimePicker
                        value={
                          addTask.startTime
                            ? dayjs(addTask.startTime, 'hh:mm A') // Convert to dayjs here
                            : null
                        }
                        onChange={(time, timeString) =>
                          handleInputChange('startTime', timeString)
                        }
                        className='timepicker'
                        format='hh:mm A' // Set the format to include AM/PM
                      />
                    </div>
                    <div className='create-layout-addtask'>
                      <div>
                        <label style={{color:'#0B4266'}} htmlFor='endTime'>End Time</label>
                      </div>
                      <TimePicker
                        value={
                          addTask.endTime
                            ? dayjs(addTask.endTime, 'HH:mm A') // Convert to dayjs here
                            : null
                        }
                        onChange={(time, timeString) =>
                          handleInputChange('endTime', timeString)
                        }
                        className='timepicker'
                        format='hh:mm A' 
                        rootClassName='timer'
                      />
                    </div>
                  </div>
                  <div className='section-addtask' style={{width:'140%'}}>
                    
                  <div className='create-layout-addtask-left  '>
                      <div style={{marginBottom:'10px'}}>
                        <label style={{color:'#0B4266'}} htmlFor='totalHours'>Total Hours</label>
                      </div>
                      <Input
                        placeholder='Enter your Total Hours'
                        value={addTask.totalHours}
                        onChange={(e) => handleInputChange('totalHours', e.target.value)}
                        
                      />
                    </div>
                    <div className='create-layout-addtask-reportingTo  '>
                      <div className='create-layout-reportingTo'>
                        <label style={{color:'#0B4266'}} htmlFor='reportingTo'>Reporting To</label>
                      </div>
                      <select
                        id='reportingTo-addtask'
                        value={addTask.reportingTo}
                        onChange={(e) => handleInputChange('reportingTo', e.target.value)}
                      >
                        <option value=''>Select Reporting To</option>
                        {reportingOptions.map((option) => (
                          <option key={option} value={option}>
                            {option}
                          </option>
                        ))}
                      </select>
                    </div> 
                  </div>  
                  <div>
                    <div className='create-layout-description'>
                      <div>
                        <label style={{color:'#0B4266'}}>Description</label>
                      </div>
                      <textarea
                        value={addTask.description}
                        onChange={(e) => handleInputChange('description', e.target.value)}
                        className='description-input'
                        style={{width:'265%'}}
                      />
                    </div>
                  </div>
                </div>
                <div>
                  <img
                  src={asset}
                  alt="..."
                  style={{ marginLeft: "auto",width:'750px', height:'200px'}}
                  />
                </div>
              </div>
            </div>
              
            
            <div className='button' style={{marginBottom:'10px'}}>
              <Button  id='cancel-addtask' onClick={handleClearSubmit} style={{width:'10%'}}>
                Clear
              </Button>
              {isEdited ? (
              <Button id={addTask.totalHours? 'submit-addtask-active':'submit-addtask'} onClick={handleFormSubmit}>
                Save
              </Button>
            ):(
              <Button  id={addTask.totalHours? 'submit-addtask-active':'submit-addtask'} onClick={handleFormSubmit}>
                Add Task
              </Button>
            )}
            </div>

        </form>):null}
        <>
        <div>
          <div style={{ display:'flex', justifyContent:'space-between', margin:'10px 20px' }}>
            <div style={{display:'flex'}}>
              <Button id='submit-less' onClick={handleLeftArrowClick}> 
                      <LeftOutlined />
                  </Button>
                  {/* <select 
                      id='submit' 
                      style={{ appearance: 'none', WebkitAppearance: 'none', MozAppearance: 'none' }} 
                      onChange={(e) => handleFilterChange(e.target.value)} value={filterOption}
                  >
                      <option style={{textAlign:'center'}} value='Date'>Date</option>
                      <option style={{textAlign:'center'}} value='Week'>Week</option>
                      <option style={{textAlign:'center'}} value='Month'>Month</option>
                  </select> */}
                  <Button id='submit-less' onClick={handleRightArrowClick}>
                      <RightOutlined />
                  </Button>

            </div>
            
            {/* <Input
            className="search-addtask"
            placeholder="Search by Date"
            allowClear
            suffix={<SearchOutlined style={{ color: "#04172480" }} />}
            onChange={(e) => {
            //  console.log("Search input value:", e.target.value);
              setSearchInput(e.target.value);
            }}
          /> */}
         
          <div style={{display:'flex', justifyContent:'flex-end'}}>
          {/* <button type='button' id='submit-less' onClick={handleLeftArrowClick}>
            <LeftOutlined />
          </button> */}

        {/* <Select
           
            style={{
              marginTop: '10px',
              display: 'flex',
              padding: '0.5em 2em',
              border: 'transparent',
              boxShadow: '2px 2px 4px rgba(0,0,0,0.4)',
              justifyContent: 'center',
              alignItems: 'center',
              gap: '10px',
              borderRadius: '4px',
              color:'white',
              background: '#0B4266',
              cursor: 'pointer',
              appearance: 'none',
              WebkitAppearance: 'none',
              MozAppearance: 'none',
            }}
            defaultValue="Date"
            onChange={handleFilterChange}
        >
          <Select.Option value="Date">Date</Select.Option>
          <Select.Option value="Week">Week</Select.Option>
          <Select.Option value="Month">Month</Select.Option>
        </Select> */}
        {!cancelButton && !(filterOption === 'Date' && !isFormEnabled) && (
            <Button
              id='cancel-new'
              onClick={handleToggleForm}
              disabled={isFormEnabled} // Disable the button when the form is enabled
            >
              Add Task
            </Button>
          )}
          <Select 
                    id='submit' 
                    style={{color:'white', appearance: 'none', WebkitAppearance: 'none', MozAppearance: 'none', marginTop:'10px', height:'95%', width:'120px' }} 
                    onChange={(value) => handleFilterChange(value)} 
                    value={filterOption}
                    dropdownStyle={{ textAlign: 'center' }} // Style the dropdown menu
                >
                    <Option value='Date'>Date</Option>
                    <Option value='Week'>Week</Option>
                    <Option value='Month'>Month</Option>
                </Select>
          {/* <button type='button' id='submit-less' onClick={handleRightArrowClick}>
            <RightOutlined />
          </button> */}
          </div>
        </div>
      </div>
        <Table
            style={{fontSize:'12px', fontFamily:'poppins', fontWeight:'normal', color: '#0B4266'}}
            className='addtask-table'
            columns={columns}
            dataSource={filteredTasks}
            pagination={false}
          />
            <Button id='submit-overall' onClick={handleOverallSubmit}>
              Submit
            </Button>
        </>
      </div>
    </DashboardLayout>
  );
};
export default AddTask;

ApprovalRequests.tsx

import React,{useEffect, useState, useRef} from 'react'
import { useNavigate } from 'react-router-dom';
import { ColumnsType } from 'antd/es/table'
import { EditOutlined, FolderViewOutlined} from '@ant-design/icons';
import { Progress } from 'antd';
import dayjs from 'dayjs';
import { v4 as uuidv4 } from 'uuid';
import '../Styles/ApprovalRequest.css';
import {
  Avatar,
  Space,
  Button,
  Table,
  Modal,
  Form,
  Input,
  Select,
  ConfigProvider,
  Tooltip,
  Tag,
  Popover,
  message,
  Checkbox,
  Pagination,
  Menu,
  Dropdown,
} from "antd";
import moment from "moment";
import { ExpandableConfig } from 'antd/lib/table/interface';
import 'moment/locale/en-in';
import {
  UserOutlined,
  DownOutlined,
  UpOutlined,
} from "@ant-design/icons";
import DashboardLayout from './Layout';
import { Task } from './AddTask';
import { groupBy } from 'lodash';
import { ConstructionOutlined } from '@mui/icons-material';
import { TableRowSelection } from 'antd/lib/table/interface';
import { RequestedOn } from './AddTask';
import type { ThemeConfig } from "antd";
import { theme } from "antd";
import { SelectedKeys, RejectedKeys, RecentRejected } from './MonthTasks';
// Define the type for RowSelectMethod
type RowSelectMethod = 'checkbox' | 'radio';

const config: ThemeConfig = {
  token: {
    colorPrimary: "#0B4266",
    colorPrimaryBg: "white",
  },
};

  interface DateTask{
    key: string;
    task: Task[];
  }

// interface GroupedTasks {
//   key: string;
//   slNo?: number;
//   month: string;
//   tasks: { 
//     [date: string]: {
//       key: string;
//       tasks: Task[]; 
//     } 
//   }; 
//   daysFilled: number;
//   totalDaysInMonth: number;
// }

export interface TaskObject {
  [date: string]: {
    key: string;
    tasks: Task[];
  };
}

interface SetGroupedTasks{
  [key: string]: GroupedTasks
}
interface UserGroupedTask {
  [userId: string]: SetGroupedTasks;   
  
}
interface GroupedTasks {
  key: string;
  slNo?: number;
  month: string;
  tasks: TaskObject;
  daysFilled: number;
  totalDaysInMonth: number;
}

interface ApprovalRequestsProps {
  selectedKeys: string[]; // Define the type for selectedKeys prop
}

const ApprovalRequest:React.FC = () => { 
  const userId = '123'; // Replace 'YOUR_USER_ID' with the actual user id you want to check
  const [selectedKeys, setSelectedKeys] = useState<string[]>([]);
  const [rejectedKeys, setRejectedKeys] = useState<RecentRejected[]>([]);
  const navigate = useNavigate();
  //const [selectedRows, setSelectedRows] = useState<React.Key[]>([]);
  const [selectedRows, setSelectedRows] = useState<string[]>([]);
  const [selectedInnerRows, setSelectedInnerRows] = useState<string[]>([]);
  //const[daysInMonth, getDaysInMonth]=useState<string[]>([]);
  const [groupedTasks, setGroupedTasks] = useState<UserGroupedTask>({});
  // State declaration with two keys
  //const [groupedTasks, setGroupedTasks] = useState<{ [month: string]: { [date: string]: GroupedTasks } }>({});
  const [expandedRow, setExpandedRow] = useState<string | null>(null);
  const [expandedInnerRow, setExpandedInnerRow] = useState<string | null>(null);
  const [modalVisible, setModalVisible] = useState<boolean>(false);
  const [modalContent, setModalContent] = useState<JSX.Element | null>(null);
  const [selectedUserId, setSelectedUserId] = useState<string | undefined>(undefined);
  const [comments, setComments] = useState('');
  const [commentVisible, setCommentVisible] = useState(false);
  const [approvalRequests, setApprovalRequests] = useState<DateTask[]>([]);
  const [monthTasks, setMonthTasks] = useState<TaskObject[]>([]);
  useEffect(() => {
    // Retrieve approvalRequestsData from local storage
    const storedData = localStorage.getItem('approvalRequestedData');
    console.log("approvalRequests", storedData);
    if (storedData) {
        const approvalRequestsData: { [key: string]: Task[] } = JSON.parse(storedData);
        console.log("approvalRequests", approvalRequestsData);

        // Convert the object to an array of DateTask objects
        const dateTasks: DateTask[] = Object.keys(approvalRequestsData).map(key => ({
            key: key,
            task: approvalRequestsData[key]
        }));
        console.log("approvalRequests-datetasks", dateTasks);

        setApprovalRequests(dateTasks); // Update the state with fetched data
    }
    console.log("approvalRequests-approvalrequests", approvalRequests);
}, []); // Fetch data only once on component mount

  useEffect(() => {
        const storedKeysString: string | null = localStorage.getItem('selectedKeys');
        if (storedKeysString !== null) {
            const storedKeys: SelectedKeys = JSON.parse(storedKeysString);
           
            if (storedKeys.hasOwnProperty(userId)) {
                setSelectedKeys(storedKeys[userId]);
            } else {
                console.log("User ID not found in stored keys");
            }
        } else {
            console.log("else-useEffect", storedKeysString);
        }
    }, []);

    useEffect(() => {
      const storedKeysString: string | null = localStorage.getItem('rejectedKeys');
      if (storedKeysString !== null) {
          const storedKeys: RejectedKeys = JSON.parse(storedKeysString);
          const userRejectedKeys = storedKeys[userId];
          if (userRejectedKeys) {
            console.log("userRejectedKeys", userRejectedKeys);
              setRejectedKeys(userRejectedKeys);
          }
      } else {
          console.log("else-useEffect", storedKeysString);
      }
  }, []);


  useEffect(() => {
    console.log("useeffect", approvalRequests.length);
    if (approvalRequests.length > 0) { // Check if approvalRequests has data
        // Process approvalRequests data
        handleGroupedTasks(approvalRequests);
    }
}, [approvalRequests]);

useEffect(() => {
  const storedData = localStorage.getItem('groupedTasks');
  if (storedData && (selectedKeys.length > 0 || rejectedKeys.length>0)) {
    const parsedData: UserGroupedTask = JSON.parse(storedData);
    const updatedData = Object.keys(parsedData).reduce((acc: UserGroupedTask, userId: string) => {
      const userData = parsedData[userId];
      
      // Check if userData is not null or undefined
      if (userData) {
        const filteredSetGroupedTasks: SetGroupedTasks = {};
        Object.keys(userData).forEach((monthKey: string) => {
          const monthData = userData[monthKey];
          const filteredTasks: TaskObject = {};
          Object.keys(monthData.tasks).forEach((dateKey: string) => {
            if (!selectedKeys.includes(dateKey) && !rejectedKeys.some((rejected) => rejected.date === dateKey)) {
              filteredTasks[dateKey] = monthData.tasks[dateKey];
            }
          });
          if (Object.keys(filteredTasks).length > 0) {
            filteredSetGroupedTasks[monthKey] = { ...monthData, tasks: filteredTasks };
          }
        });
        if (Object.keys(filteredSetGroupedTasks).length > 0) {
          acc[userId] = filteredSetGroupedTasks;
        }
      }

      return acc;
    }, {});
    setGroupedTasks(updatedData);
  }
}, [selectedKeys, rejectedKeys]);


  const handleReject = () => {
    setCommentVisible(true);
  };

  const handleCancel = () => {
    setCommentVisible(false);
  };

  const handleInputChange = (e:any) => {
    setComments(e.target.value);
  };

  const handleSubmit = () => {
    // Handle submission logic here
    console.log('Comments:', comments);
    setCommentVisible(false);
  };

//   const handleApprove = () => {
//     // Filter out the selected row from the groupedTasks state
//     const updatedGroupedTasks = { ...groupedTasks };
//     console.log("handleApprove", updatedGroupedTasks);
//     // Iterate through selected rows
//     selectedInnerRows.forEach(rowKey => {
//         // Check if the rowKey exists in updatedGroupedTasks and if its tasks property is defined
//         if (updatedGroupedTasks[rowKey]?.tasks) {
//             const tasks = updatedGroupedTasks[rowKey].tasks;
//             // Iterate through tasks for each date
//             Object.values(tasks).forEach(dateTasks => {
//                 // Iterate through individual tasks
//                 dateTasks.tasks.forEach(task => {
//                     // Add a special CSS class or inline style to change the background color to green
//                     (task as Task & { backgroundColor?: string }).backgroundColor = 'green'; // Adjust this to your styling needs
//                 });
//             });
//         }
//     });
//     console.log("updatedGroupedTaks", updatedGroupedTasks);
//     // Update the selectedInnerRows array to remove the approved row
//     setSelectedInnerRows([]);

//     // Close the modal
//     setModalVisible(false);

//     // Update the state with the modified groupedTasks
//     setGroupedTasks(updatedGroupedTasks);
// };

  
  function getDaysInMonth(month: number, year: number) {
    // month is 0-based in JavaScript
    return new Date(year, month + 1, 0).getDate();
  }
  
  const handleGroupedTasks = (requestData: DateTask[]) => {
    // Group tasks by month
    console.log("handleGroupedtasks- requestData", requestData);
    const grouped = groupBy(requestData, (task: DateTask) => dayjs(task.key).format("YYYY-MM"));
    console.log("handleGroupedTasks-grouped", grouped);
    // Retrieve existing data from local storage
    const existingDataJSON = localStorage.getItem('groupedTasks');
    const existingData: UserGroupedTask = existingDataJSON ? JSON.parse(existingDataJSON) : {};
  
    // Process each month's tasks
    for (const monthKey in grouped) {
      console.log("monthKey", monthKey);
      const tasksArray = grouped[monthKey] as DateTask[];
      console.log("tasksArray", tasksArray);
      const firstTaskDate = dayjs(tasksArray[0].key, 'YYYY-MM-DD');
      const formattedMonth = firstTaskDate.format("MMMM YYYY");
      const totalDaysInMonth = getDaysInMonth(firstTaskDate.month(), firstTaskDate.year());
  
      let daysFilled = 0;
      const tasks: TaskObject = {};
      tasksArray.forEach(taskObj => {
        console.log("taskObj", taskObj);
        const dateKey = dayjs(taskObj.key, 'YYYY-MM-DD').format('YYYY-MM-DD');
        if (existingData[userId]?.hasOwnProperty(monthKey)) {
          if (!existingData[userId][monthKey]?.tasks.hasOwnProperty(dateKey)) {
            // Create a new date key entry with all tasks from the tasksArray
            existingData[userId][monthKey].tasks[dateKey] = { key: uuidv4(), tasks: taskObj.task };
            daysFilled++;
          } else {
            if (existingData[userId][monthKey]?.tasks[dateKey].tasks.length === 0) {
              console.log("sasi", dateKey);
              return;
            }
            existingData[userId][monthKey].tasks[dateKey].tasks = [...taskObj.task];
          }
        } else {
          const dateUUID = uuidv4(); // Generate unique key for the date
          tasks[dateKey] = { key: dateUUID, tasks: taskObj.task };
          daysFilled++;
        }
      });
  
      if (!existingData[userId]?.hasOwnProperty(monthKey)) {
        const monthUUID = uuidv4(); // Generate unique key for the month
        existingData[userId] = existingData[userId] || {};
        existingData[userId][monthKey] = {
          key: monthUUID,
          month: formattedMonth,
          daysFilled,
          totalDaysInMonth,
          tasks
        };
      } else {
        existingData[userId][monthKey].daysFilled = daysFilled; // Update daysFilled
      }
    }
  
    // Set the updated data to local storage
    localStorage.setItem('groupedTasks', JSON.stringify(existingData));
  
    // Update the state with the combined data
    // You'll need to manage the state accordingly as per your application's structure
    setGroupedTasks(existingData);
    setApprovalRequests([]);
  };
  


  //   useEffect(() => {
  //     const storedData = localStorage.getItem('groupedTasks');
    
  //     if (storedData && selectedKeys.length > 0) {
  //         const parsedData: UserGroupedTask = JSON.parse(storedData);
          
  //         const updatedData = Object.keys(parsedData).reduce((acc: UserGroupedTask, userId: string) => {
  //             const userGroupedTasks = parsedData[userId];
              
  //             const updatedUserGroupedTasks: SetGroupedTasks = Object.keys(userGroupedTasks).reduce((userAcc: SetGroupedTasks, monthKey: string) => {
  //                 const monthData = userGroupedTasks[monthKey];
  //                 const filteredTasks: TaskObject = {};

  //                 Object.keys(monthData.tasks).forEach(dateKey => {
  //                     if (!selectedKeys.includes(dateKey) && !rejectedKeys.some(rejected => rejected.date === dateKey)) {
  //                         filteredTasks[dateKey] = monthData.tasks[dateKey];
  //                     }
  //                 });

  //                 if (Object.keys(filteredTasks).length > 0) {
  //                     userAcc[monthKey] = { ...monthData, tasks: filteredTasks };
  //                 }
                  
  //                 return userAcc;
  //             }, {});

  //             if (Object.keys(updatedUserGroupedTasks).length > 0) {
  //                 acc[userId] = updatedUserGroupedTasks;
  //             }
              
  //             return acc;
  //         }, {});

  //         setGroupedTasks(updatedData);
  //     }
  // }, [selectedKeys, rejectedKeys]);

  
  const handleRowSelection = (selectedRowKeys: React.Key[]) => {
    console.log("handleRowSelection selectedRowKeys", selectedRowKeys); // Output selectedRowKeys to console
    setSelectedRows(selectedRowKeys as string[]);
  };

// const handleInnerRowSelection = (     
//   selectedRowKeys: React.Key[],
//   selectedRows: TaskObject[],
//   tasksForClickedMonth: TaskObject[]
// ) => {
//   // Extracting keys from the tasksForClickedMonth array
//   const taskKeys = tasksForClickedMonth.flatMap(task => Object.keys(task));
  
//   console.log("taskkeys",taskKeys);
//   setSelectedInnerRows(taskKeys as string[]); // Assuming selectedRowKeys are string keys
//   console.log("handleInnerRowSelection tasksForClickedMonth", tasksForClickedMonth);
// };

const rowSelection = {
  onChange: (selectedRowKeys: React.Key[], selectedRows: TaskObject[]) => {
    console.log('selectedRowKeys', selectedRowKeys, 'selectedRows: ', selectedRows);
    setSelectedInnerRows(selectedRowKeys as string[]);
    console.log(selectedInnerRows);
  },
  getCheckboxProps: (record: TaskObject) => ({
    disabled: false, // Column configuration not to be checked
    key: record.key,
  }),
};

useEffect(() => {
  console.log("selectedInnerRows", selectedInnerRows);
}, [selectedInnerRows]);

  const handleToggleRowExpand = (record: GroupedTasks, event: React.MouseEvent<HTMLElement>) => {
    // Update the expandedRow state using the functional form of setState
    setExpandedRow(prevExpandedRow => prevExpandedRow === record.month ? null : record.month);
    // Prevent event propagation
    event.stopPropagation();
  };

  const handleToggleInnerRowExpand = (record: TaskObject) => {
    const taskKeys = Object.keys(record?.tasks);
    if (taskKeys.length > 0) {
      // Get the first key from the tasks object
      const firstTaskKey = taskKeys[0];
      // Update the state with the first task key
      setExpandedInnerRow(prevExpandedInnerRow => {
        // Check if the current expanded row is the same as the first task key
        if (prevExpandedInnerRow === firstTaskKey) {
          // If it is, collapse the row by setting expandedInnerRow to null
          return null;
        } else {
          // Otherwise, expand the row by setting expandedInnerRow to the first task key
          return firstTaskKey;
        }
      });
    }
    console.log("handleToggleInnerRowExpand", expandedInnerRow);
  };
  
    const rowClassName = (record: GroupedTasks, index: number) => {
      return index % 2 === 0 ? 'even-row' : 'odd-row';
    };

    const monthTaskDatas: TaskObject[] = Object.values(monthTasks).map(dateData => {
      console.log("monthTaskData-monthtasks", monthTasks)
      console.log("dateData", dateData);
      if (!dateData) return {}; // Check if dateData is undefined or null
      // const taskObject: TaskObject = {};
      // Object.entries(dateData).forEach(([date, data]) => {
      //     taskObject[date] = {
      //         key: data?.key,
      //         tasks: data?.tasks
      //     };
      // });
      // console.log("taskObject",taskObject);
      // return taskObject;
      return dateData ;
  });

  const monthTasksData: DateTask[] = monthTaskDatas.map(taskObject => {
      console.log("monthTasksData",taskObject);
      const date = Object.keys(taskObject)[0]; // Assuming there's only one key in TaskObject
      console.log("date", date)
      const { key, tasks } = taskObject[date];
      return { key, task: tasks }; // Assuming 'tasks' property is mapped to 'task' in DateTask
  });

  

  const handleInnerRowSelection = (selectedRowKeys: React.Key[]) => {
    console.log("handleInnerRowSelection selectedRowKeys", selectedRowKeys); // Output selectedRowKeys to console
    setSelectedInnerRows(selectedRowKeys as string[]);
  };
  

      // const getColumn = (formattedMonth: string) => {
      //   const column: ColumnsType<TaskObject> = [
      //     {
      //       title: 'Select All',
      //       dataIndex: 'date',
      //       key: 'date',
      //       width: '20%',
      //       fixed: 'left',
      //       render: (_, record: TaskObject) => {
      //         // Get the specific month key
      //         const monthKey = Object.keys(record).find(
      //           key =>
      //             moment(key).format('YYYY-MM') ===
      //             moment(formattedMonth, 'YYYY-MM').format('YYYY-MM')
      //         );
      //         if (!monthKey) return null; // If monthKey is not found, return null
        
      //         // Get the formatted date for the month key
      //         const formattedDate = moment(monthKey).format('YYYY-MM-DD');
      //         return formattedDate;
      //       },
      //     },     
      //     {
      //       title: '',
      //       dataIndex: 'tasks',
      //       key: 'tasks',
      //       width: '60%',
      //       render: (_, record: TaskObject) => {
      //         // Initialize variables to store task hours and total hours
      //         let totalHours = 0;
      //         const taskHours: { [key: string]: number } = {};
            
      //         // Iterate over each date in the record
      //         Object.entries(record).forEach(([date, dateTasks]) => {
      //           // Iterate over tasks for each date
      //           dateTasks.tasks.forEach(task => {
      //             const totalHoursForTask = parseFloat(task.totalHours || '0');
      //             totalHours += totalHoursForTask; // Accumulate total hours
      //             taskHours[task?.task] = (taskHours[task?.task] || 0) + totalHoursForTask; // Add task hours
      //           });
      //         });
            
      //         // Calculate extra hours if total hours exceed 9
      //         const extraHours = totalHours > 9 ? totalHours - 9 : 0;
            
      //         return (
      //           <div>
      //             <ul style={{ display: 'flex', flexDirection: 'row', listStyle: 'none', padding: 0}}>
      //               {/* Render task hours for each task */}
      //               {Object.entries(taskHours).map(([taskName, taskTotalHours], index) => (
      //                 <li key={index} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', margin: '5px' }}>
      //                   <div style={{ paddingRight: '20px' }}>
      //                     <div style={{ color: 'grey', paddingBottom: '5px' }}>
      //                       {taskName}
      //                     </div>
      //                     <div style={{ fontWeight: "bold", fontSize: '20px', color: 'black' }}>
      //                       {taskTotalHours}H
      //                     </div>
      //                   </div>
      //                   <div>
      //                     <Progress
      //                       type="circle"
      //                       percent={Math.round((taskTotalHours / 9) * 100)} // Ensure it's an integer
      //                       width={60}
      //                     />
      //                   </div>
      //                 </li>
      //               ))}
      //               {/* Render extra hours and total hours */}
      //               <li style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white',  margin: '5px' }}>
      //                 <div style={{ color: '#0B4266', paddingRight: '20px' }}>
      //                   Extra Hours
      //                 </div>
      //                 <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: "bold", fontSize: '20px' }}>
      //                   {extraHours}H
      //                 </div>
      //               </li>
      //               <li style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', margin: '5px' }}>
      //                 <div style={{ color: '#0B4266', paddingRight: '20px' }}>
      //                   Total Hours
      //                 </div>
      //                 <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: 'bold', fontSize: '20px' }}>
      //                   {totalHours}H
      //                 </div>
      //               </li>
      //             </ul>
      //           </div>
      //         );
      //       },
      //     },      
      //     {
      //       title: '',
      //       dataIndex: 'actions',
      //       key: 'actions',
      //       fixed: 'right',
      //       width: '20%',
      //       render: (_, record: TaskObject) => (
      //         <div>
      //           {/* Check if the record has tasks */}
      //           {record && Object.keys(record).length > 0 ? (
      //             // Render the appropriate icon based on the expanded state
      //             expandedInnerRow === Object.keys(record)[0] ? (
      //               <UpOutlined
      //                 style={{
      //                   cursor: 'pointer',
      //                   color: '#0B4266',
      //                   fontSize: '16px',
      //                 }}
      //                 onClick={() => handleToggleInnerRowExpand(record)}
      //               />
      //             ) : (
      //               <DownOutlined
      //                 style={{
      //                   cursor: 'pointer',
      //                   color: '#0B4266',
      //                   fontSize: '16px',
      //                 }}
      //                 onClick={() => handleToggleInnerRowExpand(record)}
      //               />
      //             )
      //           ) : null}
      //         </div>
      //       ),
      //     }  
      //   ];
      //   return column;
      // };
    

      const getColumn = (formattedMonth: string) => {
        const column: ColumnsType<DateTask> = [
            {
                title: 'Select All',
                dataIndex: 'date',
                key: 'date',
                width: '20%',
                fixed: 'left',
                render: (_, record: DateTask) => {
                    // Get the specific month key

                    const date = record.task.length > 0 ? record.task[0].date : '';
                    return date;
                    // const date = record.task.map(date=>date.date);
                    // return date;
                    // const monthKey = Object.keys(record).find(
                    //     key =>
                    //         moment(key).format('YYYY-MM') ===
                    //         moment(formattedMonth, 'YYYY-MM').format('YYYY-MM')
                    // );
                    // if (!monthKey) return null; // If monthKey is not found, return null
    
                    // // Get the formatted date for the month key
                    // const formattedDate = moment(monthKey).format('YYYY-MM-DD');
                    // return formattedDate;
                },
            },
            {
                title: '',
                dataIndex: 'tasks',
                key: 'tasks',
                width: '60%',
                render: (_, record: DateTask) => {
                    // Initialize variables to store task hours and total hours
                    let totalHours = 0;
                    const taskHours: { [key: string]: number } = {};
                    // Iterate over each task in the record
                    record.task.forEach(task => {
                        const totalHoursForTask = parseFloat(task.totalHours || '0');
                        totalHours += totalHoursForTask; // Accumulate total hours
                        taskHours[task?.task] = (taskHours[task?.task] || 0) + totalHoursForTask; // Add task hours
                    });
    
                    // Calculate extra hours if total hours exceed 9
                    const extraHours = totalHours > 9 ? totalHours - 9 : 0;
    
                    return (
                        <div>
                            <ul style={{ display: 'flex', flexDirection: 'row', listStyle: 'none', padding: 0 }}>
                                {/* Render task hours for each task */}
                                {Object.entries(taskHours).map(([taskName, taskTotalHours], index) => (
                                    <li key={index} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', margin: '5px' }}>
                                        <div style={{ paddingRight: '20px' }}>
                                            <div style={{ color: 'grey', paddingBottom: '5px' }}>
                                                {taskName}
                                            </div>
                                            <div style={{ fontWeight: "bold", fontSize: '20px', color: 'black' }}>
                                                {taskTotalHours}H
                                            </div>
                                        </div>
                                        <div>
                                            <Progress
                                                type="circle"
                                                percent={Math.round((taskTotalHours / 9) * 100)} // Ensure it's an integer
                                                width={60}
                                            />
                                        </div>
                                    </li>
                                ))}
                                {/* Render extra hours and total hours */}
                                <li style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', margin: '5px' }}>
                                    <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                                        Extra Hours
                                    </div>
                                    <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: "bold", fontSize: '20px' }}>
                                        {extraHours.toFixed(2)}H
                                    </div>
                                </li>
                                <li style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white', margin: '5px' }}>
                                    <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                                        Total Hours
                                    </div>
                                    <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: 'bold', fontSize: '20px' }}>
                                        {totalHours}H
                                    </div>
                                </li>
                            </ul>
                        </div>
                    );
                },
            },
            Table.EXPAND_COLUMN
        ];
    
        return column;
    };

    const innerColumn: ColumnsType<Task> = [
      {
        title: 'Sl.no',
        className: 'ant-table-column-title',
        dataIndex: 'slNo',
        key: 'slNo',
        fixed: 'left',
        render: (_, __, index) => <span>{index + 1}</span>,
      },  
      {
        title: 'Task',
        sorter: (a: Task, b: Task) => {
          return a.task.localeCompare(b.task);
        },
        dataIndex: 'task',
        key: 'task',
        fixed: 'left',
      },
      {
        title: 'Start Time',
        sorter: (a: Task, b: Task) => {
          return a.startTime.localeCompare(b.startTime);
        },
        dataIndex: 'startTime',
        key: 'startTime',
        fixed: 'left',
      },
      {
        title: 'End Time',
        sorter: (a: Task, b: Task) => {
          return a.endTime.localeCompare(b.endTime);
        },
        dataIndex: 'endTime',
        key: 'endTime',
        fixed: 'left',
      },
      {
        title: 'Total Hours',
        sorter: (a: Task, b: Task) => {
          return a.totalHours.localeCompare(b.totalHours);
        },
        dataIndex: 'totalHours',
        key: 'totalHours',
        fixed: 'left',
      },
      {
        title: 'Description',
        sorter: (a: Task, b: Task) => {
          return a.description.localeCompare(b.description);
        },
        dataIndex: 'description',
        key: 'description',
        fixed: 'left',
      },
    ];
    
    const columns: ColumnsType<GroupedTasks> = [
      {
        title: 'Sl.no',
        className: 'ant-table-column-title',
        dataIndex: 'slNo',
        key: 'slNo',
        fixed: 'left',
        render: (_, __, index) => <span>{index + 1}</span>,
      },    
      {
        title: "Employee",
        className: ' ant-table-column-title',
        dataIndex: "tasks",
        render: (tasks: { [date: string]: { key: string; tasks: Task[] } }) => {
          const userId = tasks[Object.keys(tasks)[0]].tasks[0]?.userId || '';
          return (
            <Space className="flex gap-5">
              <Avatar icon={<UserOutlined />} size={45} />
              <div>
                <div>
                  <strong>Sasi Kumar</strong>
                </div>
                <div>{userId}</div>
              </div>
            </Space>
          );
        },
        // sorter: (a: GroupedTasks, b: GroupedTasks) => {
        //   const userIdA = a.tasks[Object.keys(a.tasks)[0]].tasks[0]?.userId || '';
        //   const userIdB = b.tasks[Object.keys(b.tasks)[0]].tasks[0]?.userId || '';
        //   return userIdA.localeCompare(userIdB);
        // },
      },          
      {
        title: 'Month',
        //sorter: (a, b) => a.month.localeCompare(b.month),
        className: 'ant-table-column-title',
        dataIndex: 'month',
        key: 'month',
        fixed: 'left',
      },
      {
        title: 'Requested On',
        className: 'ant-table-column-title',
        dataIndex: 'month', // Use the month key from the data to fetch the requestedOn data
        key: 'date',
        fixed: 'left',
        render: (month: string) => {
            // Retrieve the requestedOn from local storage
            const requestedOnString = localStorage.getItem('requestedOn');
            const requestedOn: RequestedOn = requestedOnString ? JSON.parse(requestedOnString) : {};
    
            // Retrieve the dates array corresponding to the month
            const dates = requestedOn[month] || [];
    
            // If dates array is empty, return empty string
            if (dates.length === 0) return '';
    
            // Format dates array as a string to display
            let formattedDates: string;
            if (dates.length === 1) {
                // If there is only one date, display it
                formattedDates = dates[0];
            } else {
                // If there are two dates, display in "From: date1 To: date2" format
                formattedDates = `From: ${dates[0]} To: ${dates[1]}`;
            }
    
            return formattedDates;
        },
      },     
      {
        title: 'Days Filled',
        className: 'ant-table-column-title',
        dataIndex: 'daysFilled',
        key: 'daysFilled',
        render: (daysFilled, record) => {
          const dateKeysFilled = Object.keys(record.tasks).length;
          return (
            <span>{`${dateKeysFilled} / ${record.totalDaysInMonth}`}</span>
          );
        },
        //sorter: (a: GroupedTasks, b: GroupedTasks) => Object.keys(a.tasks).length - Object.keys(b.tasks).length,
      },    
      Table.EXPAND_COLUMN
    ];
  
    const expandable: ExpandableConfig<GroupedTasks> = {
      expandedRowRender: (record: GroupedTasks) => {
        const taskHours: { [key: string]: number } = {};
        for (const dateKey in record.tasks) {
          record.tasks[dateKey].tasks.forEach(task => {
            if (taskHours.hasOwnProperty(task.task)) {
              taskHours[task.task] += parseFloat(task.totalHours || '0');
            } else {
              taskHours[task.task] = parseFloat(task.totalHours || '0');
            }
          });
        }
        
        // After calculating the total hours for each task, convert them to fixed decimals
        for (const taskName in taskHours) {
          if (taskHours.hasOwnProperty(taskName)) {
            taskHours[taskName] = parseFloat(taskHours[taskName].toFixed(2));
          }
        }
        
        const totalHours = Math.floor(Object.values(taskHours).reduce((acc, curr) => acc + curr, 0));
        const regularHours = Math.min(totalHours, 9);
        const extraHours = totalHours - regularHours;
    
        if (expandedRow === record.month) {
          return (
            <div>
              <ul style={{ display: 'flex', justifyContent: 'space-around', listStyle: 'none' }}>
                {Object.entries(taskHours).map(([taskName, taskTotalHours], index) => (
                  <div key={index} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
                    <div style={{ paddingRight: '20px' }}>
                      <div style={{ color: 'grey', paddingBottom: '5px' }}>
                        {taskName}
                      </div>
                      <div style={{ fontWeight: "bold", fontSize: '20px', color: 'black' }}>
                        {taskTotalHours}H
                      </div>
                    </div>
                    <div>
                      <Progress
                        type="circle"
                        percent={Math.round((taskTotalHours / 9) * 100)} // Ensure it's an integer
                        width={60}
                      />
                    </div>
                  </div>
                ))}
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
                  <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                    Extra Hours
                  </div>
                  <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: "bold", fontSize: '20px' }}>
                    {extraHours}H
                  </div>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
                  <div style={{ color: '#0B4266', paddingRight: '20px' }}>
                    Total Hours
                  </div>
                  <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: 'bold', fontSize: '20px' }}>
                    {totalHours}H
                  </div>
                </div>
              </ul>
            </div>
          );
        }
        return null;
      },
      expandRowByClick: true,
      //expandIcon: () => null
    };
    
    
    const aggregatedData: GroupedTasks[] = Object.keys(groupedTasks).flatMap((userId: string) => {
      const userGroupedTasks = groupedTasks[userId];
      return Object.keys(userGroupedTasks).map((monthKey: string) => {
        console.log("aggregatedData-monthKey", monthKey);
        const monthData = userGroupedTasks[monthKey];
        console.log("aggregatedData-monthData", monthData);
        const monthTasks: TaskObject = {};
        let daysFilled = 0;
        for (const dateKey in monthData.tasks) {
          if (Object.keys(monthData.tasks[dateKey].tasks).length > 0) {
            monthTasks[dateKey] = monthData.tasks[dateKey];
            daysFilled++;
          }
        }
        const totalDaysInMonth = monthData.totalDaysInMonth;
        console.log("aggregatedData", monthData);
        return {
          key: monthData.key,
          month: monthData.month,
          tasks: monthTasks,
          daysFilled: daysFilled,
          totalDaysInMonth: totalDaysInMonth
        };
      });
    });
  
    const flattenedData = (groupedTasks: TaskObject) => {
      const tasks: TaskObject[] = [];
      const keys = Object.keys(groupedTasks);
      console.log("keys", keys);
      // Iterate over each key
      keys.forEach(key => {
          // Find the monthData corresponding to the current key
          const groupedData = groupedTasks[key];
          console.log("monthdata", groupedData);
          if (groupedData) {
              // Convert monthData into TaskObject
              const taskObject: TaskObject = {
                  [key]: {
                      key: groupedData.key,
                      tasks: groupedData.tasks
                  }
              };
              tasks.push(taskObject);
          }
      });
  
      return tasks;
  };
  
    const handleRowClick = (
      record: TaskObject,
      formattedMonth: string,
      event: React.MouseEvent<HTMLElement>
    ) => {
    
      // Set the month tasks in the state
      //setMonthTasks(tasksForClickedMonth);
      //console.log("tasksForClickedMonth",tasksForClickedMonth);
      // Set the modal content and make the modal visible
      setModalContent(
        <div>
          <Table
                rowSelection={{
                    type: 'checkbox',
                    selectedRowKeys: selectedInnerRows,
                    onChange: handleInnerRowSelection
                }}
                style={{
                    backgroundColor: 'white',
                    border: '1px solid grey',
                    borderRadius: '5px',
                }}
                columns={getColumn(formattedMonth)} 
                rowClassName="rowstyle"
                dataSource={monthTasksData}
                pagination={false}
                // expandable={{
                //     expandedRowRender: (record: DateTask) => {
                //         const handleInnerRowExpand = (dateKey: string) => {
                //             const tasksForDate = record.task.find(task => task.date === dateKey);
                //             return (
                //                 <Table
                //                     columns={innerColumn as ColumnsType<Task>}
                //                     dataSource={tasksForDate ? [tasksForDate] : []} // Pass an array with the task if found, otherwise an empty array
                //                     pagination={false}
                //                 />
                //             );
                //         };
                        
                //         return (
                //             <>
                //                 {record.task.map(task => (
                //                     <div key={task.date}>
                //                         <div>Date: {task.date}</div>
                //                         {handleInnerRowExpand(task.date)}
                //                     </div>
                //                 ))}
                //             </>
                //         );
                //     },
                //     expandRowByClick: true,
                //     expandIcon: () => null,
                // }}

                expandable={{
                    expandedRowRender: (record: DateTask) => {
                        const handleInnerRowExpand = () => {
                            return (
                                <Table
                                    columns={innerColumn as ColumnsType<Task>}
                                    dataSource={record.task} // Pass all tasks in the date as dataSource
                                    pagination={false}
                                />
                            );
                        };
                        
                        return (
                            <>
                                {handleInnerRowExpand()}
                            </>
                        );
                    },
                    expandRowByClick: true,
                    expandIcon: ({ expanded, onExpand, record }) =>
                        expanded ? (
                            <UpOutlined onClick={e => onExpand(record, e)} style={{float:'right'}} />
                        ) : (
                            <DownOutlined onClick={e => onExpand(record, e)} style={{float: 'right'}}/>
                        ),
                }}
                
                
            />
        </div>
      );
      // Set the modal content and make the modal visible
      setModalVisible(true);
    
      // Prevent event propagation
      event.stopPropagation();
    };
     
  return (
    <DashboardLayout>
      <div>
          <Table
            rowSelection={{
              type: 'checkbox',
              selectedRowKeys: selectedRows,
              onChange: handleRowSelection,
              getCheckboxProps: (record: GroupedTasks) => ({
                // Use the `key` field as the identifier for row selection
                key: record.key,
                disabled: false, // You can adjust these additional props as needed
              }),
            }}  
            onRow={(record: GroupedTasks) => ({
              onClick: (event: React.MouseEvent<HTMLElement>) => {
                const userId = record.tasks[Object.keys(record.tasks)[0]].tasks[0]?.userId;
                setSelectedUserId(userId); // Set the userId in state
                // Extract necessary data from the GroupedTasks record
                const monthYear = record.month;
                const [monthName, year] = monthYear.split(' ');
                const monthNumber = moment().month(monthName).format('MM');
                const formattedMonth = `${year}-${monthNumber}`;
                // Convert GroupedTasks record into TaskObject
                const tasksObject: TaskObject = record.tasks;
                console.log("onRow-tasksObject", tasksObject);
                console.log("taskObject", tasksObject);
                const tasksForClickedMonth: TaskObject[] = flattenedData(
                  tasksObject
                );
                console.log("onRow-tasksForClickedMonth", tasksForClickedMonth);
                setMonthTasks(tasksForClickedMonth);
                // Pass TaskObject and formattedMonth to handleRowClick
                //handleRowClick(tasksObject, formattedMonth, event);
                navigate(`/monthtasks?formattedMonth=${formattedMonth}&userId=${userId}`, {state: {
                  formattedMonth: monthYear, //formattedMonth
                  userId: userId,
                  tasksObject: tasksObject,
                  tasksForClickedMonth: tasksForClickedMonth,
              }});
              },
            })}
            rowClassName={(record: GroupedTasks, index: number) =>
              index % 2 === 0 ? 'even-row' : 'odd-row'
            }
            className='custom-table'
            columns={columns}
           dataSource={aggregatedData}
            pagination={false}
            //expandable={expandable}
            // expandable={{
            //   expandedRowRender: (record: GroupedTasks) => {
            //     const taskHours: { [key: string]: number } = {};
            //     let totalExtraHours = 0; // Track total extra hours for all dates
                
            //     for (const dateKey in record.tasks) {
            //       record.tasks[dateKey].tasks.forEach(task => {
            //         if (taskHours.hasOwnProperty(task.task)) {
            //           taskHours[task.task] += parseFloat(task.totalHours || '0');
            //         } else {
            //           taskHours[task.task] = parseFloat(task.totalHours || '0');
            //         }
            //       });
            //     }
                
            //     // After calculating the total hours for each task, convert them to fixed decimals
            //     for (const taskName in taskHours) {
            //       if (taskHours.hasOwnProperty(taskName)) {
            //         taskHours[taskName] = parseFloat(taskHours[taskName].toFixed(2));
            //       }
            //     }
                
            //     const totalHours = Math.floor(Object.values(taskHours).reduce((acc, curr) => acc + curr, 0));
            //     const regularHours = Math.min(totalHours, 9);
            //     let extraHours = totalHours - regularHours;
                
            //     // Calculate extra hours for each date
            //     for (const dateKey in record.tasks) {
            //       const dateTotalHours = record.tasks[dateKey].tasks.reduce((acc, task) => acc + parseFloat(task.totalHours || '0'), 0);
            //       if (dateTotalHours > 9) {
            //         extraHours += dateTotalHours - 9; // Increment extra hours by the difference
            //         totalExtraHours += dateTotalHours - 9; // Track total extra hours
            //       }
            //     }
                
            //     return (
            //       <div>
            //         <ul style={{ display: 'flex', justifyContent: 'space-around', listStyle: 'none' }}>
            //           {Object.entries(taskHours).map(([taskName, taskTotalHours], index) => (
            //             <div key={index} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
            //               <div style={{ paddingRight: '20px' }}>
            //                 <div style={{ color: 'grey', paddingBottom: '5px' }}>
            //                   {taskName}
            //                 </div>
            //                 <div style={{ fontWeight: "bold", fontSize: '20px', color: 'black' }}>
            //                   {taskTotalHours}H
            //                 </div>
            //               </div>
            //               <div>
            //                 <Progress
            //                   type="circle"
            //                   percent={Math.round((taskTotalHours / 9) * 100)} // Ensure it's an integer
            //                   width={60}
            //                 />
            //               </div>
            //             </div>
            //           ))}
            //           {/* <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
            //             <div style={{ color: '#0B4266', paddingRight: '20px' }}>
            //               Extra Hours
            //             </div>
            //             <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: "bold", fontSize: '20px' }}>
            //               {extraHours}H
            //             </div>
            //           </div> */}
            //           <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
            //             <div style={{ color: '#0B4266', paddingRight: '20px' }}>
            //               Extra Hours
            //             </div>
            //             <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: 'bold', fontSize: '20px' }}>
            //               {totalExtraHours.toFixed(2)}H
            //             </div>
            //           </div>
            //           <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', border: '1px solid black', borderRadius: '20px', padding: '10px 20px', backgroundColor: 'white' }}>
            //             <div style={{ color: '#0B4266', paddingRight: '20px' }}>
            //               Total Hours
            //             </div>
            //             <div style={{ border: '1px solid grey', backgroundColor: '#F5F7F9', padding: '20px 10px', borderRadius: '10px', color: '#0B4266', fontWeight: 'bold', fontSize: '20px' }}>
            //               {totalHours}H
            //             </div>
            //           </div>
                    
            //         </ul>
            //       </div>
            //     );
            //   },
            //   expandRowByClick: true,
            //   expandIcon: ({ expanded, onExpand, record }) => (
            //     expanded ? 
            //       <UpOutlined onClick={(event) => onExpand(record, event)} /> :
            //       <DownOutlined onClick={(event) => onExpand(record, event)} />
            //   ),
            // }}
          />
        
      </div>
      <Modal
        title={
          modalContent ? (
            <div>
              <Space className="flex gap-5">
                <Avatar icon={<UserOutlined />} size={45} />
                <div>
                  <div>
                    <strong>Sasi Kumar</strong>
                  </div>
                  {/* Displaying the userId */}
                  <div>{selectedUserId}</div>
                </div>
              </Space>
            </div>
          ) : null
        }
        visible={modalVisible}
        onCancel={() => setModalVisible(false)}
        footer={null}
        width="80%"
      >
        {modalContent}
        <div style={{display:'flex', justifyContent:'flex-end', margin:"10px 20px"}}>
          <Button style={{width:'10%', backgroundColor:'green', color:'white'}}>Approve</Button>
          <Button style={{ width: '10%', backgroundColor: 'red', color: 'white' }} onClick={handleReject}>
            Reject
          </Button>
          <Modal
            title="Comments"
            className='modalTitle'
            visible={commentVisible}
            onCancel={handleCancel}
            footer={[
              // <Button key="cancel" onClick={handleCancel}>
              //   Cancel
              // </Button>,
              <Button style={{ width: '20%', backgroundColor: '#0B4266', color: 'white' }} key="submit" type="primary" onClick={handleSubmit}>
                Submit
              </Button>,
            ]}
          >
            <Input.TextArea placeholder='Write here...' rows={4} value={comments} onChange={handleInputChange} />
          </Modal>
        </div>
      </Modal>
    </DashboardLayout>
  );
  
}

export default ApprovalRequest

MonthTasks.tsx


import React,{useState, useEffect, SetStateAction} from 'react'
import moment from 'moment'
import isEqual from 'lodash/isEqual';
import {
    UserOutlined,
    DownOutlined,
    UpOutlined,
} from "@ant-design/icons";
import { useParams, useLocation } from 'react-router-dom';
import dayjs from 'dayjs';
import {Button, Modal, Progress, Input, Space, Avatar, Select, ConfigProvider } from 'antd';
import DashboardLayout from './Layout'
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, ReferenceLine , Label} from 'recharts';
import { ColumnsType } from 'antd/es/table'
import { Table } from 'antd'
import { TaskObject } from './ApprovalRequest'
import { Task } from './AddTask'
import ApprovalRequest from './ApprovalRequest';
import '../Styles/ApprovalRequest.css';
import type { ThemeConfig } from "antd";
import { Pie } from 'react-chartjs-2';
import Chart from 'react-apexcharts';
import { ApexOptions } from 'apexcharts';

import { theme } from "antd";
import { DateTask } from './AddTask';

export interface SelectedKeys {
    [userId: string]: string[];
}

export interface RecentRejected {
    date: string;
    comment: string;
}
export interface RejectedKeys {
    [userId: string]: RecentRejected[];
}


const config: ThemeConfig = {
    token: {
      colorPrimary: "#0b4266",
      colorPrimaryBg: "white",
      colorFillAlter: "rgba(231, 236, 240, 0.3)",
      colorPrimaryBgHover: "white",
      borderRadiusLG: 4,
      colorFill: "#0b4266",
      colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)",
    },
  };


interface ApprovalRequestsProps{
    setSelectedKeys: React.Dispatch<React.SetStateAction<string[]>>;
}
const MonthTasks: React.FC = () => {
    const [selectedKeys, setSelectedKeys]= useState<string[]>([]);
    const {Option}= Select
    const location = useLocation();
    const { formattedMonth, userId, tasksForClickedMonth, tasksObject } = location.state;
    const [selectedUserId, setSelectedUserId] = useState<string | undefined>(undefined);
    // const {formattedMonth='', userId=''}=useParams();
    const [monthTasks, setMonthTasks] = useState<{ [key: string]: TaskObject }>({});
    const [selectedRows, setSelectedRows] = useState<string[]>([]);
    //const [selectedKeys, setSelectedKeys]=useState<string[]>([]);
    const [rowTask, setRowTask]= useState<string[]>([]);
    const [comments, setComments] = useState('');
    const [commentVisible, setCommentVisible] = useState(false);
    const [monthTasksData, setMonthTasksData] = useState<DateTask[]>([]);
    const [rejectKeys, setRejectKeys]= useState<RejectedKeys>({});
    const [rejectDates, setRejectDates]= useState<RejectedKeys>({});
    const [hoveredRow, setHoveredRow] = useState<DateTask | null>(null); // Initialize hoveredRow with DateTask or null
    const [chartData, setChartData] = useState<{ labels: string[]; series: number[] }>({ labels: [], series: [] }); // Initialize chartData with appropriate types
    console.log("received data", formattedMonth,userId, tasksForClickedMonth)
    const [chartOptions, setChartOptions] = useState({});
    const [chartSeries, setChartSeries] = useState<number[]>([]);
    // Function to prepare data for the pie chart
    const preparePieChartData = () => {
        // Initialize an object to store total hours per task
        const taskHoursPerDay: { [key: string]: number } = {};
    
        // Iterate over each day's tasks data
        monthTasksData.forEach(dateTask => {
            const tasks = dateTask.task;
    
            // Iterate over each task for the current day
            tasks.forEach(task => {
                const taskName = task.task;
                const totalHours = parseFloat(task.totalHours || '0');
    
                // Accumulate total hours for each task
                taskHoursPerDay[taskName] = (taskHoursPerDay[taskName] || 0) + totalHours;
            });
        });
    
        // Extract task names and total hours as series data for the pie chart
        const seriesData = Object.values(taskHoursPerDay);
        const labels = Object.keys(taskHoursPerDay);
    
        // Set up options for the pie chart
        const options = {
            chart: {
                type: 'pie',
            },
            labels: labels,
        };
    
        setChartOptions(options);
        setChartSeries(seriesData);
    };

      // Function to extract date from tasks
      function extractDateFromTasks(tasks: Task[]): string | null {
        // Assuming all tasks have the same date
        return tasks.length > 0 ? tasks[0].date : null;
    }
    
    let chartDatas: { date: string, percentage: number | null }[] = [];
    let desiredMonth: string | null = null;
    
    if (monthTasksData.length > 0 && monthTasksData[0].task.length > 0) {
        desiredMonth = monthTasksData[0].task[0].date;
    }
    
    if (desiredMonth) {
        const startDate = dayjs(desiredMonth).startOf('month').toDate();
        const endDate = dayjs(desiredMonth).endOf('month').toDate();
    
        const totalHoursPerDay = monthTasksData.map(dateTask => {
            const totalHours = dateTask.task.reduce((total, task) => total + parseFloat(task.totalHours), 0);
            return { date: extractDateFromTasks(dateTask.task), totalHours };
        });
    
        const extraHoursPerDay = monthTasksData.map(dateTask => {
            const totalHours = dateTask.task.reduce((total, task) => total + parseFloat(task.totalHours), 0);
            const extraHours = totalHours - 8; // Assuming 8 hours is a regular workday
            return { date: extractDateFromTasks(dateTask.task), extraHours };
        });
    
        const percentageExtraHoursPerDay = extraHoursPerDay.map(({ date, extraHours }) => {
            const totalHours = totalHoursPerDay.find(day => day.date === date)?.totalHours || 0;
            const percentage = totalHours >= 9 ? (extraHours / totalHours) * 100 : 0;
            return { date, percentage };
        });
    
        const allDatesInMonth = [];
        let currentDate = dayjs(startDate);
        while (currentDate.isBefore(endDate) || currentDate.isSame(endDate, 'day')) {
            allDatesInMonth.push(currentDate.format('YYYY-MM-DD'));
            currentDate = currentDate.add(1, 'day');
        }
    
        chartDatas = allDatesInMonth.map(date => {
            const dataForDate = percentageExtraHoursPerDay.find(data => data.date === date);
            return { date, percentage: dataForDate ? dataForDate.percentage : 0 };
        });
    } else {
        console.log('No tasks found or invalid date range.');
    }
    
    
    

    useEffect(() => {
        // Prepare data for the pie chart when monthTasksData changes
        preparePieChartData();
    }, [monthTasksData]);

    useEffect(() => {
        setMonthTasks(tasksForClickedMonth);
        setRowTask(tasksObject);
    }, [tasksForClickedMonth, tasksObject]);
    
    useEffect(() => {
        const storedKeysString: string | null = localStorage.getItem('selectedKeys');
        if (storedKeysString !== null) {
            const storedKeys: string[] = JSON.parse(storedKeysString);
            setSelectedKeys(storedKeys);
        } else {
           console.log("else-useEffect", storedKeysString);
        }
    }, []);
    
    


    const handleRowSelection = (selectedRowKeys: React.Key[]) => {
        setSelectedRows(selectedRowKeys as string[]);
        setSelectedKeys(selectedRowKeys as string[]);
        console.log("handleRowSelection", selectedRowKeys);
    };

    const handleReject = () => {
        setCommentVisible(true);
        let updatedRejectKeys: RejectedKeys = { ...rejectKeys };
        let updatedRejectDates: RejectedKeys = { ...rejectDates };
    
        const updatedMonthTasksData = monthTasksData.filter(row => {
            const isRowIncluded = selectedRows.includes(row.key);
            console.log("isRowIncluded", isRowIncluded);
            if (isRowIncluded) {
                const userId = '123'; // Assuming a static userId for this example
                if (!updatedRejectKeys[userId]) {
                    updatedRejectKeys[userId] = [];
                    updatedRejectDates[userId] = [];
                }
                const datekey: string = row.task.length > 0 ? row.task[0].date : '';
                console.log("handleReject-datekey",datekey);
                updatedRejectKeys[userId].push({ date: datekey, comment: comments });
                updatedRejectDates[userId].push({ date: datekey, comment: comments });
            }
            return !isRowIncluded;
        });
    
        setRejectKeys(updatedRejectKeys);
        setRejectDates(updatedRejectDates);
        setMonthTasksData(updatedMonthTasksData);
        
    };
    
    
      const handleCancel = () => {
        setCommentVisible(false);
      };

      const handleSubmit = () => {
        let key: RejectedKeys = {};
        let date: RejectedKeys = {};
        const updatedMonthTasksData = monthTasksData.filter(row => {
            const isRowIncluded = selectedRows.includes(row.key);
            if (isRowIncluded) {
                const userId = '123'; // Assuming a static userId for this example
                if (!key[userId]) {
                    key[userId] = [];
                    date[userId] = [];
                }
                key[userId].push({ date: row.task.length > 0 ? row.task[0].date : '', comment: comments }); // Assuming comment is empty
                date[userId].push({ date: row.task.length > 0 ? row.task[0].date : '', comment: comments }); // Assuming comment is empty
            }
            return !isRowIncluded;
        });
        const storedRejectedKeys: RejectedKeys = JSON.parse(localStorage.getItem('rejectedKeys') || '{}');
        const storedRecentRejected: RejectedKeys = JSON.parse(localStorage.getItem('recentRejected') || '{}');
    
        Object.keys(rejectKeys).forEach(userId => {
            console.log("userId -handleSubmit", userId);
            const userRejectedKeys = rejectKeys[userId];
            console.log("userRejectedKeys -handleSubmit", userRejectedKeys);
            const userComments = comments;
    
            // Update rejectedKeys
            const newKeysToAdd = userRejectedKeys.filter(newKey => !storedRejectedKeys[userId]?.some(item => item.date === newKey.date));
            storedRejectedKeys[userId] = [...(storedRejectedKeys[userId] || []), ...newKeysToAdd.map(item => ({ date: item.date, comment: userComments }))];
    
            // Update recentRejected
            storedRecentRejected[userId] = [...(storedRecentRejected[userId] || []), ...userRejectedKeys.map(item => ({ date: item.date, comment: userComments }))];
        });
    
        localStorage.setItem('rejectedKeys', JSON.stringify(storedRejectedKeys));
        localStorage.setItem('recentRejected', JSON.stringify(storedRecentRejected));

        console.log("key", key);
        console.log("handleReject-updatedMonthTasksData", updatedMonthTasksData);
    
        setMonthTasksData(updatedMonthTasksData);
    
        // Update monthTasks - Assuming monthTasks is an object containing tasks grouped by date
        const updatedMonthTasksDataObj: { [key: string]: TaskObject } = {};
    
        // Set the updated monthTasks data
        setMonthTasks(updatedMonthTasksDataObj);
        setSelectedRows([]);
        console.log('Comments:', comments);
        setCommentVisible(false);
    };
   
    
    // const handleSubmit = () => {
    //     // Handle submission logic here
    //     const userId = '123'; // Assuming a static userId for this example
    
    //     // Get stored rejected keys from localStorage or initialize an empty object if none exists
    //     const storedRejectedKeys: RejectedKeys = JSON.parse(localStorage.getItem('rejectedKeys') || '{}');
    //     console.log("handleSubmit - storedRejectedKeys:", storedRejectedKeys);
    
    //     const newKeysToAdd = Object.keys(storedRejectedKeys[userId] || {}).filter(newKey => {
    //         return !storedRejectedKeys[userId] || !storedRejectedKeys[userId].some(rejected => rejected.date === newKey);
    //     });
    //     console.log("handleSubmit - newKeysToAdd:", newKeysToAdd);
    
    //     // Update storedRejectedKeys with the new keys to add
    //     const updatedRejectedKeys: RejectedKeys = {
    //         ...storedRejectedKeys,
    //         [userId]: [
    //             ...(storedRejectedKeys[userId] || []),
    //             ...newKeysToAdd.map(dateKey => ({ date: dateKey, comment: comments }))
    //         ]
    //     };
    //     console.log("handleSubmit - updatedRejectedKeys:", updatedRejectedKeys);
    //     localStorage.setItem('rejectedKeys', JSON.stringify(updatedRejectedKeys));
    
    //     // Store recent rejected dates along with comments in the local storage under the key "recentRejected"
    //     const recentRejected: RejectedKeys = JSON.parse(localStorage.getItem('recentRejected') || '{}');
    //     const updatedRecentRejected: RejectedKeys = {
    //         ...recentRejected,
    //         [userId]: [
    //             ...(recentRejected[userId] || []),
    //             ...newKeysToAdd.map(dateKey => ({ date: dateKey, comment: comments }))
    //         ]
    //     };
    //     console.log("handleSubmit - updatedRecentRejected:", updatedRecentRejected);
    //     localStorage.setItem('recentRejected', JSON.stringify(updatedRecentRejected));
    
    //     const updatedMonthTasksDataObj = Object.keys(monthTasks).reduce((acc: { [key: string]: TaskObject }, dateKey: string) => {
    //         const dateData = monthTasks[dateKey];
    //         const filteredData = Object.fromEntries(Object.entries(dateData).filter(([date, data]) => !updatedRejectedKeys[userId].some(rejected => rejected.date === date)));
    //         console.log("filteredData", filteredData);
    //         if (Object.keys(filteredData).length > 0) {
    //             acc[dateKey] = filteredData;
    //         }
    //         return acc;
    //     }, {});
    
    //     setMonthTasks(updatedMonthTasksDataObj);
    //     console.log("handleSubmit - updatedMonthTasksDataObj:", updatedMonthTasksDataObj);
    
    //     console.log('handleSubmit - Comments:', comments);
    //     setCommentVisible(false);
    // };
    
    
    const handleInputChange = (e:any) => {
        setComments(e.target.value);
      };

    const handleApprove = async () => {
        const userId = '123'; // Assuming a static userId for this example
        let key: SelectedKeys = {};
        let date: SelectedKeys = {};
        const updatedMonthTasksData = monthTasksData.filter(row => {
            const isRowIncluded = selectedRows.includes(row.key);
            if (isRowIncluded) {
                if (!key[userId]) {
                    key[userId] = [];
                    date[userId] = [];
                }
                key[userId].push(row.key);
                const datekey = row.task.length > 0 ? row.task[0].date : '';
                date[userId].push(datekey);
            }
            return !isRowIncluded;
        });
    
        setSelectedKeys(date[userId]);
    
        // Get stored keys from localStorage or initialize an empty array if none exists
        const storedSelectedKeys: SelectedKeys = JSON.parse(localStorage.getItem('selectedKeys') || '{}');
        const storedRejectedKeys: RejectedKeys = JSON.parse(localStorage.getItem('rejectedKeys') || '{}');
    
        // Filter out keys that are already present in storedSelectedKeys to avoid duplicates
        const newKeysToAdd = date[userId].filter(newKey => !storedSelectedKeys[userId]?.includes(newKey));
    
        // Update storedSelectedKeys with the new keys to add
        storedSelectedKeys[userId] = [...(storedSelectedKeys[userId] || []), ...newKeysToAdd];
        localStorage.setItem('selectedKeys', JSON.stringify(storedSelectedKeys));
    
        // Remove keys from rejectedKeys
        const updatedRejectedKeys: RejectedKeys = {};
        Object.keys(storedRejectedKeys).forEach(uid => {
            updatedRejectedKeys[uid] = storedRejectedKeys[uid].filter(rejectedKey => !key[userId].includes(rejectedKey.date));
        });
        localStorage.setItem('rejectedKeys', JSON.stringify(updatedRejectedKeys));
    
        // Update recent approved tasks in local storage
        const storedRecentApproved: SelectedKeys = JSON.parse(localStorage.getItem('recentApproved') || '{}');
        storedRecentApproved[userId] = date[userId];
        localStorage.setItem('recentApproved', JSON.stringify(storedRecentApproved));
    
        // Wait for the localStorage to be updated before continuing
        await new Promise(resolve => setTimeout(resolve, 0));
    
        console.log("key", key);
        console.log("handleApprove-updatedMonthTasksData", updatedMonthTasksData);
    
        setMonthTasksData(updatedMonthTasksData);
    
        const updatedMonthTasksDataObj = Object.keys(monthTasks).reduce((acc: { [key: string]: TaskObject }, dateKey: string) => {
            const dateData = monthTasks[dateKey];
            const filteredData = Object.fromEntries(Object.entries(dateData).filter(([date, data]) => !key[userId].includes(data.key)));
            console.log("filteredData", filteredData);
            if (Object.keys(filteredData).length > 0) {
                acc[dateKey] = filteredData;
            }
            return acc;
        }, {});
    
        setMonthTasks(updatedMonthTasksDataObj);
        console.log("handleApprove-updatedMonthTasksDataObj", updatedMonthTasksDataObj);
    
        setSelectedRows([]);
    };

    const monthTaskDatas: TaskObject[] = Object.values(monthTasks).map(dateData => {
        console.log("monthTaskData-monthtasks", monthTasks)
        console.log("dateData", dateData);
        if (!dateData) return {}; // Check if dateData is undefined or null
        return dateData ;
    });

    
    useEffect(() => {
        // Process the monthTaskDatas and store it in the state
        const processedMonthTasksData: DateTask[] = monthTaskDatas.map(taskObject => {
            const date = Object.keys(taskObject)[0]; // Assuming there's only one key in TaskObject
            const { key, tasks } = taskObject[date];
            return { key, task: tasks }; // Store the data according to the DateTask interface
        });
    
        // Check if the processed data is different from the current state
        if (!isEqual(processedMonthTasksData, monthTasksData)) {
            // Update the state with the processed data
            setMonthTasksData(processedMonthTasksData);
        }
    }, [monthTaskDatas, monthTasksData]); // Add monthTasksData to the dependency array

    const handleRowHover = (record: DateTask) => {
        setHoveredRow(record); // Ensure hoveredRow is initialized correctly
        
        // Initialize an object to store total hours for each task name
        const taskTotalHours: { [key: string]: number } = {};
        
        // Calculate total hours for each task name
        record.task.forEach(task => {
            const totalHoursForTask = parseFloat(task.totalHours || '0');
            // Accumulate total hours for each task name
            taskTotalHours[task.task] = (taskTotalHours[task.task] || 0) + totalHoursForTask;
        });
        
        // Calculate total hours for all tasks
        let totalHours = Object.values(taskTotalHours).reduce((acc, curr) => acc + curr, 0);
        
        // If total hours are less than 9, consider them as 9
        totalHours = Math.max(totalHours, 9);
        console.log("totalHours", totalHours);
        
        // Calculate percentages for each task based on total hours
        const percentages = Object.entries(taskTotalHours).map(([taskName, taskTotalHours]) => ({
            taskName,
            percentage: ((taskTotalHours / totalHours) * 100).toFixed(2),
        }));
        console.log("percentage", percentages);
        // Update chart data state
        setChartData({
            labels: percentages.map(entry => entry.taskName),
            series: percentages.map(entry => parseFloat(entry.percentage)),
        });
    };
    
    
    const handleRowLeave = () => {
        setHoveredRow(null); // Clear the hovered row
    };

    const getColumn = (formattedMonth: string) => {
        const column: ColumnsType<DateTask> = [
            {
                title: 'Date',
                dataIndex: 'date',
                key: 'date',
                width: '15%',
                fixed: 'left',
                render: (_, record: DateTask) => {
                    // Get the specific month key

                    const date = record.task.length > 0 ? record.task[0].date : '';
                    return date;
                },
            },
            {
                title: 'Project',
                dataIndex: 'tasks',
                key: 'tasks',
                width: '15%',
                fixed:'left',
                render: (_, record: DateTask) => {
                    // Initialize total hours for the 'Learning' task
                    let projectTotalHours = 0;
            
                    // Iterate over each task in the record
                    record.task.forEach(task => {
                        // Check if the current task is a 'Learning' task
                        if (task.task === 'Project') {
                            // Add the total hours of the 'Learning' task to the accumulated total
                            projectTotalHours += parseFloat(task.totalHours || '0');
                        }
                    });
            
                    return (
                        <div>
                            {projectTotalHours}H
                        </div>
                    );
                },
            },
            {
                title: 'Meeting',
                dataIndex: 'tasks',
                key: 'tasks',
                width: '15%',
                fixed: 'left',
                render: (_, record: DateTask) => {
                    // Initialize total hours for the 'Learning' task
                    let meetingTotalHours = 0;
            
                    // Iterate over each task in the record
                    record.task.forEach(task => {
                        // Check if the current task is a 'Learning' task
                        if (task.task === 'Meeting') {
                            // Add the total hours of the 'Learning' task to the accumulated total
                            meetingTotalHours += parseFloat(task.totalHours || '0');
                        }
                    });
            
                    return (
                        <div>
                            {meetingTotalHours}H
                        </div>
                    );
                },
            },            
            {
                title: 'Training',
                dataIndex: 'tasks',
                key: 'tasks',
                width: '15%',
                fixed:'left',
                render: (_, record: DateTask) => {
                    // Initialize total hours for the 'Learning' task
                    let trainingTotalHours = 0;
            
                    // Iterate over each task in the record
                    record.task.forEach(task => {
                        // Check if the current task is a 'Learning' task
                        if (task.task === 'Training') {
                            // Add the total hours of the 'Learning' task to the accumulated total
                            trainingTotalHours += parseFloat(task.totalHours || '0');
                        }
                    });
            
                    return (
                        <div>
                            {trainingTotalHours}H
                        </div>
                    );
                },
            },
            {
                title: 'Learning',
                dataIndex: 'tasks',
                key: 'tasks',
                width: '15%',
                fixed: 'left',
                render: (_, record: DateTask) => {
                    // Initialize total hours for the 'Learning' task
                    let learningTotalHours = 0;
            
                    // Iterate over each task in the record
                    record.task.forEach(task => {
                        // Check if the current task is a 'Learning' task
                        if (task.task === 'Learning') {
                            // Add the total hours of the 'Learning' task to the accumulated total
                            learningTotalHours += parseFloat(task.totalHours || '0');
                        }
                    });
            
                    return (
                        <div>
                            {learningTotalHours}H
                        </div>
                    );
                },
            },            
            {
                title: 'Shift Hours',
                dataIndex: 'tasks',
                key: 'tasks',
                width: '15%',
                fixed:'left',
                render: (_, record: DateTask) => {
                    // Initialize variables to store task hours and total hours
                    let totalHours = 0;
                    const taskHours: { [key: string]: number } = {};
                    // Iterate over each task in the record
                    record.task.forEach(task => {
                        const totalHoursForTask = parseFloat(task.totalHours || '0');
                        totalHours += totalHoursForTask; // Accumulate total hours
                        taskHours[task?.task] = (taskHours[task?.task] || 0) + totalHoursForTask; // Add task hours
                    });

                    // Calculate extra hours if total hours exceed 9
                    const extraHours = totalHours > 9 ? totalHours - 9 : 0;

                    // Filter and render only the total hours for the 'Project' tasks
                    return (
                        <div>
                            {totalHours}H
                        </div>
                    );
                },
            },
            {
                title: 'Extra Hours',
                dataIndex: 'tasks',
                key: 'tasks',
                width: '15%',
                fixed:'left',
                render: (_, record: DateTask) => {
                    // Initialize variables to store task hours and total hours
                    let totalHours = 0;
                    const taskHours: { [key: string]: number } = {};
                    // Iterate over each task in the record
                    record.task.forEach(task => {
                        const totalHoursForTask = parseFloat(task.totalHours || '0');
                        totalHours += totalHoursForTask; // Accumulate total hours
                        taskHours[task?.task] = (taskHours[task?.task] || 0) + totalHoursForTask; // Add task hours
                    });

                    // Calculate extra hours if total hours exceed 9
                    const extraHours = totalHours > 9 ? totalHours - 9 : 0;

                    // Filter and render only the total hours for the 'Project' tasks
                    return (
                        <div>
                            {extraHours}H
                        </div>
                    );
                },
            },
            Table.EXPAND_COLUMN
        ];
    
        return column;
    };
    

    const innerColumn: ColumnsType<Task> = [
        {
          title: 'Sl.no',
          className: 'ant-table-column-title',
          dataIndex: 'slNo',
          key: 'slNo',
          fixed: 'left',
          render: (_, __, index) => <span>{index + 1}</span>,
        },  
        {
          title: 'Task',
          sorter: (a: Task, b: Task) => {
            return a.task.localeCompare(b.task);
          },
          dataIndex: 'task',
          key: 'task',
          fixed: 'left',
        },
        {
          title: 'Start Time',
          sorter: (a: Task, b: Task) => {
            return a.startTime.localeCompare(b.startTime);
          },
          dataIndex: 'startTime',
          key: 'startTime',
          fixed: 'left',
        },
        {
          title: 'End Time',
          sorter: (a: Task, b: Task) => {
            return a.endTime.localeCompare(b.endTime);
          },
          dataIndex: 'endTime',
          key: 'endTime',
          fixed: 'left',
        },
        {
          title: 'Total Hours',
          sorter: (a: Task, b: Task) => {
            return a.totalHours.localeCompare(b.totalHours);
          },
          dataIndex: 'totalHours',
          key: 'totalHours',
          fixed: 'left',
        },
        {
          title: 'Description',
          sorter: (a: Task, b: Task) => {
            return a.description.localeCompare(b.description);
          },
          dataIndex: 'description',
          key: 'description',
          fixed: 'left',
        },
    ];
    return (
        <DashboardLayout>
            <div style={{display:'flex', alignItems:'flex-start', margin:'10px 20px'}}>
                <div>
                    <Space className="flex gap-5">
                        <Avatar icon={<UserOutlined />} size={65} />
                        <div>
                        <div>
                            <strong style={{fontSize:'20px'}}>Sasi Kumar</strong>
                        </div>
                        {/* Displaying the userId */}
                        <div style={{textAlign:'left', fontSize:'16px'}}>{userId}</div>
                        </div>
                    </Space>
                </div>

            </div>
            <div style={{ display: 'flex', justifyContent: 'space-between', margin: '10px 20px', alignItems: 'center' }}>
                <div style={{ 
                    transition: 'box-shadow .3s',
                    boxShadow: '0 0 4px rgba(33,33,33,.2)',  
                    borderRadius: '5px', 
                    padding: '46px', 
                    width: '48%', 
                    height: '100%', 
                    boxSizing: 'border-box',
                    display: 'flex', 
                    justifyContent: 'center', 
                    alignItems: 'center' 
                }}>
                    <Chart options={chartOptions} series={chartSeries} type="pie" width="380" />
                </div>
                <div style={{ transition: 'box-shadow .3s',
                    boxShadow: '0 0 4px rgba(33,33,33,.2)',  borderRadius: '5px', padding: '20px', width: '48%', boxSizing: 'border-box' }}>
                    <LineChart width={700} height={300} data={chartDatas} margin={{ top: 20, right: 30, left: 20, bottom: 10 }}>
                        <CartesianGrid strokeDasharray="3 3" />
                        <XAxis dataKey="date" />
                        <YAxis label={{ value: 'Percentage of Extra Hours Worked', angle: -90, position: 'insideMiddle', style: { paddingRight: '5px' } }} />
                        <Tooltip />
                        <Legend />
                        <Line type="monotone" dataKey="percentage" stroke="#8884d8" />
                    </LineChart>
                </div>
            </div>

            <div style={{fontWeight:'bold', color:'#0B4266',fontSize:'20px',textAlign:'center', margin:'10px 20px'}}>{formattedMonth}</div>
            <ConfigProvider theme={config}>
                <Table
                    rowSelection={{
                        type: 'checkbox',
                        selectedRowKeys: selectedRows,
                        onChange: handleRowSelection
                    }}
                    onRow={(record) => ({
                        onMouseEnter: () => handleRowHover(record), // Handle mouse enter event
                        onMouseLeave: () => handleRowLeave(), // Handle mouse leave event
                    })}
                    columns={getColumn(formattedMonth)} 
                    //rowClassName="rowstyle"
                    className='table-striped-rows approvalrequests-table'
                    dataSource={monthTasksData}
                    pagination={false}
                    expandable={{
                        expandedRowRender: (record: DateTask) => {
                            const handleInnerRowExpand = () => {
                                return (
                                    
                                    <Table
                                        columns={innerColumn as ColumnsType<Task>}
                                        dataSource={record.task} // Pass all tasks in the date as dataSource
                                        pagination={false}
                                    />
                                );
                            };
                            
                            return (
                                <>
                                    {handleInnerRowExpand()}
                                </>
                            );
                        },
                        expandRowByClick: true,
                        expandIcon: ({ expanded, onExpand, record }) =>
                            expanded ? (
                                <UpOutlined onClick={e => onExpand(record, e)} style={{float:'right'}} />
                            ) : (
                                <DownOutlined onClick={e => onExpand(record, e)} style={{float: 'right'}}/>
                            ),
                    }} 
                />     
            </ConfigProvider>
            <div style={{display:'flex', justifyContent:'flex-end', margin:"10px 20px"}}>
                
                <Button style={{height:'200%' ,width: '100px', backgroundColor: 'red', color: 'white', marginRight:'10px' }} onClick={handleReject}>
                  Reject
                </Button>
                <Button style={{height:'200%', width:'100px', backgroundColor:'green', color:'white'}} onClick={handleApprove}>Approve</Button>
                <Modal
                  title="Comments"
                  className='modalTitle'
                  visible={commentVisible}
                  onCancel={handleCancel}
                  footer={[
                    <Button style={{ width: '20%', backgroundColor: '#0B4266', color: 'white' }} key="submit" type="primary" onClick={handleSubmit}>
                      Submit
                    </Button>,
                  ]}
                >
                  <Input.TextArea placeholder='Write here...' rows={4} value={comments} onChange={handleInputChange} />
                </Modal>
              </div> 
        </DashboardLayout>

    )
}

export default MonthTasks


EmployeeTaskStatus.tsx

import React, { useEffect, useState } from 'react'
import DashboardLayout from './Layout'
import {
    UserOutlined,
    DownOutlined,
    LeftOutlined,
    RightOutlined,
    UpOutlined,
  } from "@ant-design/icons";
import dayjs from 'dayjs';
import Calendar from './Calendar'; // Import your Calendar component
import { useNavigate } from 'react-router-dom';
import ApexCharts from 'react-apexcharts';
//import { PieChart, Pie, Cell, Tooltip, Legend, LineChart, Line, XAxis, YAxis, CartesianGrid, ResponsiveContainer , Area, AreaChart} from 'recharts';
import { LineChart, XAxis, YAxis, CartesianGrid, Tooltip, Legend, Line, ResponsiveContainer, Brush, ReferenceLine, Label } from 'recharts';
import '../Styles/EmployeeTaskStatus.css';
import '../Styles/CreateUser.css';
import { notification, Card , ConfigProvider, Button} from 'antd';
import { Task } from './AddTask';
import { set } from 'lodash';
import { CatchingPokemonSharp } from '@mui/icons-material';
import asset from '../../assets/images/asset.svg'
import { Select } from 'antd'; // Import the Select component from Ant Design
import { RecentRejected } from './MonthTasks';
import type { ThemeConfig } from "antd";
import { theme } from "antd";
import { RejectedKeys, SelectedKeys } from './MonthTasks';
const config: ThemeConfig = {
    token: {
      colorPrimary: "#0b4266",
   
      colorPrimaryBg: "rgba(155, 178, 192, 0.2)",
   
      colorFillAlter: "rgba(231, 236, 240, 0.3)",
   
      colorPrimaryBgHover: "rgba(155, 178, 192, 0.2)",
   
      borderRadiusLG: 4,
   
      colorFill: "#0b4266",
   
      colorBgContainerDisabled: "rgba(0, 0, 0, 0.04)",
    },
  };
interface EmployeeTaskStatusProps{
    setSelectedMonth: React.Dispatch<React.SetStateAction<string>>;
    setSelectedYear: React.Dispatch<React.SetStateAction<string>>;
    pendingTask: string[];
}

const EmployeeTaskStatus = () => {
    const userId = '123'; // Assuming you have a function to get the current user's ID
    const { Option } = Select; // Destructure the Option component from Select
    const navigate = useNavigate();
    const [filterOption, setFilterOption] = useState('Month');
    const [currentDate, setCurrentDate] = useState(dayjs());
    const [currentWeek, setCurrentWeek] = useState(dayjs().startOf('week'));
    const [currentMonth, setCurrentMonth] = useState(dayjs().startOf('month'));
    const [taskList, setTaskList] = useState<Task[]>([]);
    const [filteredTasks, setFilteredTasks] = useState<Task[]>([]);
    const [approvedKeys, setApprovedKeys]= useState<string[]>([]);
    const [rejectedKeys, setRejectedKeys]= useState<RecentRejected[]>([]);
    const [rejectCount, setRejectCount]= useState(0);
    const [acceptCount, setAcceptCount]= useState(0);
    const [missedCount, setMissedCount]= useState(0);
    const [pendingCount, setPendingCount]= useState(0);
    const [pendingTask, setPendingTask]= useState<string[]>([]);
    const [performanceData, setPerformanceData] = useState<{ date: string, percentage: number }[]>([]);
    const [chartWidth, setChartWidth] = useState(window.innerWidth * 0.7); // Set initial chart width to 90% of window width
    const [selectedMonth, setSelectedMonth]=useState<string>('');
    const [selectedYear, setSelectedYear]=useState<string>('');
    const userName = localStorage.getItem("userName");
    console.log("userName", userName);
    const [recentApproved, setRecentApproved] = useState([]);
    const [recentRejected, setRecentRejected] = useState<RecentRejected[]>([]);

    useEffect(() => {
        // Fetch recentApproved dates from localStorage
        const recentApprovedFromStorage = JSON.parse(localStorage.getItem("recentApproved") || "[]");
        setRecentApproved(recentApprovedFromStorage);
    }, []);

    useEffect(() => {
        // Fetch data from localStorage
        const storedData = localStorage.getItem('recentRejected');
        if (storedData) {
            // Parse the stored data
            const parsedData: RecentRejected[] = JSON.parse(storedData);
            // Update the state
            setRecentRejected(parsedData);
        }
    }, []); // Empty dependency array to run this effect only once on component mount

    useEffect(() => {
        const handleResize = () => {
            setChartWidth(window.innerWidth * 0.2); // Update chart width when window is resized
        };

        window.addEventListener('resize', handleResize); // Add event listener for window resize

        return () => {
            window.removeEventListener('resize', handleResize); // Remove event listener on component unmount
        };
    }, []);
    const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042']; // Add more colors if needed
    useEffect(() => {
        const storedData = localStorage.getItem('taskList');
        if (storedData) {
            const parsedData: Task[] = JSON.parse(storedData);
            const filteredTasks = parsedData.filter((task: Task) => task.userId === userId);
            setTaskList(filteredTasks);
        }
        console.log("storedData", storedData);
    }, []);

    useEffect(() => {
        const storedKeysString: string | null = localStorage.getItem('selectedKeys');
        if (storedKeysString !== null) {
            const storedKeys: SelectedKeys = JSON.parse(storedKeysString);
            if (storedKeys.hasOwnProperty(userId)) {
                setApprovedKeys(storedKeys[userId]);
            } else {
                console.log("User ID not found in stored keys");
            }
        } else {
            console.log("else-useEffect", storedKeysString);
        }
    }, []);

    useEffect(() => {
      const storedKeysString: string | null = localStorage.getItem('rejectedKeys');
      if (storedKeysString !== null) {
          const storedKeys: RejectedKeys = JSON.parse(storedKeysString);
          
          const userRejectedKeys = storedKeys[userId];
          if (userRejectedKeys) {
              setRejectedKeys(userRejectedKeys);
          }
      } else {
          console.log("else-useEffect", storedKeysString);
      }
  }, []);


    function getDaysInMonth(month: number, year: number) {
        // month is 0-based in JavaScript
        return new Date(year, month + 1, 0).getDate();
      }

      useEffect(() => {
        let filtered: Task[] = [];
        let processedDates = new Set<string>(); // Set to store processed dates
        if (filterOption === 'Date') {
            filtered = taskList.filter((task) => task.date === dayjs(currentDate).format('YYYY-MM-DD'));
        } else if (filterOption === 'Week') {
            const startOfWeek = currentWeek.startOf('week');
            const endOfWeek = currentWeek.endOf('week');
            filtered = taskList.filter(
                (task) =>
                    (dayjs(task.date).isSame(startOfWeek) || dayjs(task.date).isAfter(startOfWeek)) &&
                    (dayjs(task.date).isSame(endOfWeek) || dayjs(task.date).isBefore(endOfWeek))
            );
        } else if (filterOption === 'Month') {
            const startOfMonth = currentMonth.startOf('month');
            const endOfMonth = currentMonth.endOf('month');
            filtered = taskList.filter(
                (task) =>
                    (dayjs(task.date).isSame(startOfMonth) || dayjs(task.date).isAfter(startOfMonth)) &&
                    (dayjs(task.date).isSame(endOfMonth) || dayjs(task.date).isBefore(endOfMonth))
            );
        }
    
        let newAcceptCount = 0;
        let newRejectCount = 0;
        let newPendingCount = 0;
        let taskPending: string[] = [];
        filtered.forEach(task => {
            const date = dayjs(task.date).format('YYYY-MM-DD');
            // Check if the date has already been processed
            if (!processedDates.has(date)) {
                processedDates.add(date); // Add date to processed dates set
                if (approvedKeys.includes(task.date)) {
                    newAcceptCount++;
                } else if (rejectedKeys.some(rejected => rejected.date === task.date)) {
                    console.log("rejectedKeys", rejectedKeys);
                    console.log("logkey", task.date);
                    newRejectCount++;
                }
                 else {
                    if (!approvedKeys.includes(task.date) && !taskPending.includes(task.date)) {
                        taskPending.push(task.date);
                        newPendingCount++;
                    }
                }
            }
        });
    
        // Get stored pending tasks from localStorage
        const storedPendingTasks = localStorage.getItem('pendingTask');
        let storedPendingTasksArray: string[] = [];
        if (storedPendingTasks) {
            storedPendingTasksArray = JSON.parse(storedPendingTasks);
        }
    
        // Remove any dates in stored pending tasks that are now in selectedKeys or rejectedKeys
        storedPendingTasksArray = storedPendingTasksArray.filter(date => {
            // Check if the date is not included in approvedKeys or rejectedKeys
            return !approvedKeys.includes(date) && !rejectedKeys.some(rejected => rejected.date === date);
        });
    
        // Concatenate new pending tasks and stored pending tasks (without selected or rejected keys)
        taskPending = [...taskPending, ...storedPendingTasksArray];
    
        // Remove duplicates from taskPending
        taskPending = Array.from(new Set(taskPending));
    
        // Convert array to JSON string
        const jsonString: string = JSON.stringify(taskPending);
    
        // Store the JSON string in localStorage
        localStorage.setItem('pendingTask', jsonString);
        let newMissedCount = 0;
    
        if (filterOption === 'Month') {
            // Calculate total days in the month
            const totalDaysInMonth = dayjs(currentMonth).daysInMonth();
            newMissedCount = totalDaysInMonth - newAcceptCount - newRejectCount - newPendingCount;
        } else if (filterOption === 'Week') {
            // Calculate total days in the week
            const totalDaysInWeek = 7;
            newMissedCount = totalDaysInWeek - newAcceptCount - newRejectCount - newPendingCount;
        } else {
            // For Date filter option, check if the task exists for the selected date
            const selectedDate = dayjs(currentDate).format('YYYY-MM-DD');
            const taskExists = filtered.some(task => task.date === selectedDate);
            if (!taskExists) {
                newMissedCount = 1;
            }
        }
    
        setAcceptCount(newAcceptCount);
        setRejectCount(newRejectCount);
        setPendingCount(newPendingCount);
        setMissedCount(newMissedCount);
    
        setFilteredTasks(filtered);
    }, [filterOption, currentDate, currentMonth, currentWeek, taskList, approvedKeys, rejectedKeys]);
    
    useEffect(() => {
        const calculatePerformanceData = () => {
            const performanceData = [];
    
            if (filterOption === 'Month') {
                const totalDaysInMonth = dayjs(currentMonth).daysInMonth();
                const totalWorkingHours = totalDaysInMonth * 9; // Assuming 9 hours of work per day
    
                for (let i = 1; i <= totalDaysInMonth; i++) {
                    const date = dayjs(currentMonth).date(i).format('YYYY-MM-DD');
                    const tasksForDate = filteredTasks.filter(task => task.date === date);
                    const totalTaskHours = tasksForDate.reduce((acc, task) => acc + parseFloat(task.totalHours), 0);
                    const extraHoursPercentage = totalTaskHours < 9 ? 0 : ((totalTaskHours - 9) / totalWorkingHours) * 100;
                    performanceData.push({ date, percentage: extraHoursPercentage });
                }
            } else if (filterOption === 'Week') {
                const totalDaysInWeek = 7;
                const totalWorkingHours = totalDaysInWeek * 9; // Assuming 9 hours of work per day
    
                for (let i = 0; i < totalDaysInWeek; i++) {
                    const date = dayjs(currentWeek).add(i, 'day').format('YYYY-MM-DD');
                    const tasksForDate = filteredTasks.filter(task => task.date === date);
                    const totalTaskHours = tasksForDate.reduce((acc, task) => acc + parseFloat(task.totalHours), 0);
                    const extraHoursPercentage = totalTaskHours < 9 ? 0 : ((totalTaskHours - 9) / totalWorkingHours) * 100;
                    performanceData.push({ date, percentage: extraHoursPercentage });
                }
            } else {
                const selectedDate = dayjs(currentDate).format('YYYY-MM-DD');
                const tasksForDate = filteredTasks.filter(task => task.date === selectedDate);
                const totalTaskHours = tasksForDate.reduce((acc, task) => acc + parseFloat(task.totalHours), 0);
                const extraHoursPercentage = totalTaskHours < 9 ? 0 : ((totalTaskHours - 9) / 9) * 100;
                performanceData.push({ date: selectedDate, percentage: extraHoursPercentage });
            }
    
            return performanceData;
        };
    
        setPerformanceData(calculatePerformanceData());
    }, [filterOption, currentDate, currentMonth, currentWeek, filteredTasks]);
    
    const handleFilterChange = (value: any) => {
        setFilterOption(value);
    };

    // const calculateTaskPercentages = () => {
    //     let totalHours = 0;
    //     const taskHoursMap: { [taskName: string]: number } = {}; // Object to store total hours for each task type
        
    //     // Calculate total working hours based on filterOption
    //     if (filterOption === 'Month') {
    //         totalHours = dayjs(currentMonth).daysInMonth() * 9; // Assuming 9 hours of work per day
    //     } else if (filterOption === 'Week') {
    //         totalHours = 7 * 9; // Assuming 9 hours of work per day for 7 days
    //     } else {
    //         totalHours = 9; // Assuming 9 hours of work for the selected date
    //     }
        
    //     // Accumulate total task hours for each task type
    //     filteredTasks.forEach(task => {
    //         const taskName = task.task;
    //         const taskHours = parseFloat(task.totalHours);
            
    //         if (!taskHoursMap[taskName]) {
    //             taskHoursMap[taskName] = 0;
    //         }
            
    //         taskHoursMap[taskName] += taskHours;
    //     });
        
    //     // Calculate percentage for each task type
    //     const taskPercentages = Object.keys(taskHoursMap).map(taskName => ({
    //         taskName,
    //         value: totalHours !== 0 ? (taskHoursMap[taskName] / totalHours) * 100 : 0
    //     }));
        
    //     return taskPercentages;
    // }; 
    
    const calculateOverallPercentages = () => {
        const totalTasks = acceptCount + rejectCount + pendingCount;
        const acceptedPercentage = (acceptCount / totalTasks) * 100;
        const rejectedPercentage = (rejectCount / totalTasks) * 100;
        const pendingPercentage = (pendingCount / totalTasks) * 100;
        return [
            { taskName: 'Accepted', value: acceptedPercentage },
            { taskName: 'Rejected', value: rejectedPercentage },
            { taskName: 'Pending', value: pendingPercentage }
        ];
    };
    const calculateTaskPercentages = () => {
        let totalHours = 0;
        let taskHoursMap: { [taskName: string]: number } = {}; // Object to store total hours for each task type
    
        // Calculate total working hours based on filterOption
        if (filterOption === 'Month') {
            totalHours = dayjs(currentMonth).daysInMonth() * 9; // Assuming 9 hours of work per day for the entire month
        } else if (filterOption === 'Week') {
            totalHours = 7 * 9; // Assuming 9 hours of work per day for 7 days
        } else {
            totalHours = 9; // Assuming 9 hours of work for the selected date
        }
    
        // Accumulate total task hours for each task type
        filteredTasks.forEach(task => {
            const taskName = task.task;
            const taskHours = parseFloat(task.totalHours);
    
            if (!taskHoursMap[taskName]) {
                taskHoursMap[taskName] = 0;
            }
    
            taskHoursMap[taskName] += taskHours;
        });
    
        // Calculate percentage for each task type
        const taskPercentages = Object.keys(taskHoursMap).map(taskName => ({
            taskName,
            value: totalHours !== 0 ? (taskHoursMap[taskName] / totalHours) * 100 : 0
        }));
    
        return taskPercentages;
    };
    
    const generateXAxisCategories = () => {
        if (filterOption === 'Month') {
            // Get the start and end dates of the current month
            const startDate = dayjs(currentMonth).startOf('month');
            const endDate = dayjs(currentMonth).endOf('month');
            
            // Generate an array of all dates in the current month
            const datesOfMonth = [];
            let currentDate = startDate;
            while (currentDate.isSame(endDate, 'day') || currentDate.isBefore(endDate, 'day')) {
                datesOfMonth.push(currentDate.format('YYYY-MM-DD'));
                currentDate = currentDate.add(1, 'day');
            }
            console.log("dateoFmonth", datesOfMonth);
            return datesOfMonth;
        } else if (filterOption === 'Week') {
            // Get all dates of the specific week
            const startDate = dayjs(performanceData[0].date).startOf('week');
            const endDate = dayjs(performanceData[performanceData.length - 1].date).endOf('week');
            const datesOfWeek = [];
            let currentDate = startDate;
            while (currentDate.isSame(endDate, 'day') || currentDate.isBefore(endDate, 'day')) {
                datesOfWeek.push(currentDate.format('YYYY-MM-DD'));
                currentDate = currentDate.add(1, 'day');
            }
            return datesOfWeek;
        } else {
            // Get all hours of the specific date
            return Array.from({ length: 24 }, (_, index) => `${index}:00`);
        }
    };

    const getCurrentMonth = (filterOption: string, currentDate: string, currentMonth: string, currentWeek: any) => {
        let month: string;
        if (filterOption === 'Date') {
            month = dayjs(currentDate).format('MMMM');
        } else if (filterOption === 'Week') {
            month = dayjs(currentWeek).format('MMMM');
        } else if (filterOption === 'Month') {
            month = dayjs(currentMonth).format('MMMM');
        } else {
            // Default to current month
            month = dayjs().format('MMMM');
        }
        return month;
    };
    
    const getCurrentYear = (filterOption: string, currentDate: string, currentMonth: string, currentWeek: any) => {
        let year: string;
        if (filterOption === 'Date') {
            year = dayjs(currentDate).format('YYYY');
        } else if (filterOption === 'Week') {
            year = dayjs(currentWeek).format('YYYY');
        } else if (filterOption === 'Month') {
            year = dayjs(currentMonth).format('YYYY');
        } else {
            // Default to current year
            year = dayjs().format('YYYY');
        }
        return year;
    };
    
    const handleCountClick = (status: string, filterOption: string, currentDate: string, currentMonth: string, currentWeek: any) => {
        // Determine the clickedDate based on the filterOption
        let clickedDate;
        if (filterOption === "Month") {
            clickedDate = dayjs(currentMonth).startOf('month').format('YYYY-MM-DD');
        } else if (filterOption === "Week") {
            clickedDate = dayjs(currentWeek).startOf('week').format('YYYY-MM-DD');
        } else {
            clickedDate = dayjs(currentDate).format('YYYY-MM-DD');
        }
        // Navigate to the calendar for the specific month based on the filter option
        const month = getCurrentMonth(filterOption, currentDate, currentMonth, currentWeek);
        const year = getCurrentYear(filterOption, currentDate, currentMonth, currentWeek);
    
        console.log("handleCountClick", month, year);
        setSelectedYear(year);
        setSelectedMonth(month);
        
        // Store the clickedDate in localStorage
        localStorage.setItem('clickedDate', clickedDate);
        
        navigate(`/calendar?month=${month}&year=${year}&status=${status}`);
    };
    
    
    
    
    // const generateXAxisCategories = () => {
    //     if (filterOption === 'Month') {
    //         // Get the start and end dates of the current month
    //         const startDate = currentMonth.startOf('month');
    //         const endDate = currentMonth.endOf('month');
    //         // const startDate = dayjs(currentMonth).startOf('month');
    //         // const endDate = dayjs(currentMonth).endOf('month');
    //         console.log("generateXAxisCategories-month", startDate);
    //         console.log("generateXAxisCategories-month", endDate);
    //         // Generate an array of all dates in the current month
    //         const datesOfMonth = [];
    //         let currentDate = startDate;
    //         while (currentDate.isSame(endDate, 'day') || currentDate.isBefore(endDate, 'day')) {
    //             console.log("1");
    //             datesOfMonth.push(currentDate.format('YYYY-MM-DD'));
    //             currentDate = currentDate.add(1, 'day');
    //         }
    //         return datesOfMonth;
    //     } else if (filterOption === 'Week') {
    //         // Get all dates of the specific week
    //         const startDate = dayjs(performanceData[0].date).startOf('week');
    //         const endDate = dayjs(performanceData[performanceData.length - 1].date).endOf('week');
    //         const datesOfWeek = [];
    //         let currentDate = startDate;
    //         while (currentDate.isSame(endDate, 'day') || currentDate.isBefore(endDate, 'day')) {
    //             datesOfWeek.push(currentDate.format('YYYY-MM-DD'));
    //             currentDate = currentDate.add(1, 'day');
    //         }
    //         return datesOfWeek;
    //     } else {
    //         // Get all hours of the specific date
    //         return Array.from({ length: 24 }, (_, index) => `${index}:00`);
    //     }
    // };
    
    

    // Function to calculate performance data based on filter option
   
    const calculatePerformance = () => {
        const performanceData:any[] = [];

        // Ensure filteredTasks has data
        if (!filteredTasks || filteredTasks.length === 0) {
            return performanceData;
        }

        // Iterate over the filtered tasks and calculate extra hours worked per day/week/month
        filteredTasks.forEach(task => {
            let totalExpectedHours = 0;
            if (filterOption === 'Month') {
                totalExpectedHours = dayjs(task.date).daysInMonth() * 9; // Assuming 9 hours of work per day
            } else if (filterOption === 'Week') {
                totalExpectedHours = 7 * 9; // Assuming 9 hours of work per day for 7 days
            } else {
                totalExpectedHours = 9; // Assuming 9 hours of work for the selected date
            }
            const extraHours = parseFloat(task.totalHours) - totalExpectedHours;
            const percentage = (extraHours / totalExpectedHours) * 100;
            performanceData.push({
                date: dayjs(task.date).format('YYYY-MM-DD'), // Adjust date format as needed
                extraHours,
                percentage,
            });
        });

        return performanceData;
    };
        
    const handleLeftArrowClick = () => {
        if (filterOption === 'Date') {
          console.log("handleLeftArrowClick -prev", currentDate);
          const previousDate = currentDate.subtract(1, 'day');
          console.log("handleLeftArrowClick previousDate",previousDate)
          setCurrentDate(previousDate);
    
        } else if (filterOption === 'Week') {
          const previousWeekStart = currentWeek.subtract(1, 'week').startOf('week');
          const previousWeekEnd = currentWeek.subtract(1, 'week').endOf('week');
          setCurrentWeek(previousWeekStart);
          console.log("previousWeek",previousWeekStart)
        } else if (filterOption === 'Month') {
          const previousMonthStart = currentMonth.subtract(1, 'month').startOf('month');
          const previousMonthEnd = currentMonth.subtract(1, 'month').endOf('month');
          setCurrentMonth(previousMonthStart);
        }
      };
    
      const handleRightArrowClick = () => {
        if (filterOption === 'Date') {
          const nextDate = currentDate.add(1, 'day');
          if(nextDate.isAfter(dayjs(), 'day')){
            notification.warning({
              message: 'Warning',
              description: 'Cannot navigate to future weeks.',
            });
            return;
          }
          setCurrentDate(nextDate);
        } else if (filterOption === 'Week') {
          const nextWeekStart = currentWeek.add(1, 'week').startOf('week');
          const nextWeekEnd = currentWeek.add(1, 'week').endOf('week');
          if (nextWeekStart.isAfter(dayjs(), 'day')) {
            notification.warning({
              message: 'Warning',
              description: 'Cannot navigate to future weeks.',
            });
            return;
          }
          setCurrentWeek(nextWeekStart);
          
        } else if (filterOption === 'Month') {
          const nextMonthStart = currentMonth.add(1, 'month').startOf('month');
          if (nextMonthStart.isAfter(dayjs(), 'day')) {
            notification.warning({
              message: 'Warning',
              description: 'Cannot navigate to future months.',
            });
            return;
          }
          setCurrentMonth(nextMonthStart);
        }
        
      };
  return (
    <>
    {/* <div style={{display:'flex', justifyContent:'space-between'}}>
        <div style={{textAlign:'left', margin:'40px 20px 0px 20px'}}>
            <h3 style={{fontSize:'20px', marginBottom:'0px',fontWeight:'bold', fontFamily:'poppins'}}>Welcome {userName ? userName.charAt(0).toUpperCase() + userName.slice(1) : ""}
                <span className="wave" role="img" aria-label="Waving hand">👋</span>
            </h3>
            {/* <h3 style={{ fontSize: '20px', marginBottom:'0px'}}>
                {userName}
                <span className="wave" role="img" aria-label="Waving hand">👋</span>
            </h3> 
        </div>
    </div> */}

    <div style={{margin:'30px 0px 0px 0px'}}>
            <Card className="main-card">
            <div style={{ display: "flex", height:'55px' }}>
                <div>
                <h3 style={{textAlign:'left', marginTop:'0px', marginBottom:'0px'}}>Welcome {userName ? userName.charAt(0).toUpperCase() + userName.slice(1) : ""}
                <span className="wave" role="img" aria-label="Waving hand">👋</span></h3>
                <p>
                    All of us do not have equal talent, but all of us have an equal
                    opportunities to improve our <strong>Talent</strong>
                </p>
                </div>
                <img
                src={asset}
                alt="..."
                style={{ marginLeft: "auto", marginTop: "-5px" }}
                />
            </div>
            </Card>
    </div>

    <div style={{display:'flex', justifyContent:'space-between'}}>
        <div style={{display:'flex', justifyContent:'flex-end', height:'47px', margin:'0px 20px 10px 20px'}}>
        {/* id='submit-less' */}
            <ConfigProvider theme={config}>
                <Button id='submit-less' onClick={handleLeftArrowClick}> 
                    <LeftOutlined />
                </Button>
                {/* <select 
                    id='submit' 
                    style={{ appearance: 'none', WebkitAppearance: 'none', MozAppearance: 'none' }} 
                    onChange={(e) => handleFilterChange(e.target.value)} value={filterOption}
                >
                    <option style={{textAlign:'center'}} value='Date'>Date</option>
                    <option style={{textAlign:'center'}} value='Week'>Week</option>
                    <option style={{textAlign:'center'}} value='Month'>Month</option>
                </select> */}
                <Button id='submit-less' onClick={handleRightArrowClick}>
                    <RightOutlined />
                </Button>
            </ConfigProvider>
                <div className='employeetask'>
                    { filterOption === 'Month' ? (
                    <div style={{display:'flex', justifyContent:'flex-start'}}>
                        <div style={{margin: '10px 20px', fontSize:'16px', fontFamily:'poppins'}}>From: {dayjs(currentMonth).format('YYYY-MM-DD')}</div>
                        <div style={{ margin: '10px 20px', fontSize:'16px', fontFamily:'poppins'}}>To: {dayjs(currentMonth).endOf('month').format('YYYY-MM-DD')}</div>
                    </div>
                    ) : filterOption === 'Week' ? (
                        <div style={{display:'flex', justifyContent:'flex-start'}}>
                            <div style={{margin: '10px 20px', fontSize:'16px', fontFamily:'poppins'}}>From: {dayjs(currentWeek).format('YYYY-MM-DD')}</div>
                            <div style={{margin: '10px 20px', fontSize:'16px', fontFamily:'poppins' }}>To: {dayjs(currentWeek).endOf('week').format('YYYY-MM-DD')}</div>
                        </div>
                    )  : (
                        <div style={{margin: '10px 20px', fontSize:'16px', fontFamily:'poppins'}}>Date: {currentDate.format('YYYY-MM-DD')}</div>
                    )
                    }
                </div>
        </div>
        
        <div style={{display:'flex', justifyContent:'flex-end', height:'15%', marginRight:'20px', marginTop:'10px'}}>
                {/* <button type='button' id='submit-less' onClick={handleLeftArrowClick}>
                    <LeftOutlined />
                </button> */}
                <ConfigProvider theme={config}>
                <Select 
                    id='submit' 
                    style={{color:'white', appearance: 'none', WebkitAppearance: 'none', MozAppearance: 'none' }} 
                    onChange={(value) => handleFilterChange(value)} 
                    value={filterOption}
                    dropdownStyle={{ textAlign: 'center' }} // Style the dropdown menu
                >
                    <Option value='Date'>Date</Option>
                    <Option value='Week'>Week</Option>
                    <Option value='Month'>Month</Option>
                </Select>
                </ConfigProvider>

                {/* <button type='button' id='submit-less' onClick={handleRightArrowClick}>
                    <RightOutlined />
                </button> */}
        </div>
    </div>
    
    {/* <div style={{ maxHeight: "300px", overflowY: "auto" }}>
    <Card className="main-card" style={{ overflow: "hidden" }}>
        <div id="scroll-container" style={{ display: "flex" }}>
            <div id="scroll-text">
                <p style={{ fontSize: '16px', fontFamily: 'poppins', marginBottom: 0}}>
                    {/* {recentApproved && recentApproved.length > 0 && (
                        <div style={{padding:'20px', color:'green'}}>
                            <strong>{recentApproved.join(", ")}</strong>
                            <span> have been Approved</span>
                        </div>
                    )}
                    {recentRejected && recentRejected.length > 0 && (
                        recentRejected.map((item, index) => (
                            <div key={index} style={{color: 'red'}}>
                                <strong>{item.date}</strong>
                                <span> have been Rejected</span>
                                <div style={{padding:'10px',textAlign:'left', margin:'0px 0px 0px 10px'}}><strong>Reason:</strong>{item.comment}</div>
                            </div>
                        ))
                    )} 
                    Welcome 
                </p>
            </div>
            <img
                src={asset}
                alt="..."
                style={{ marginLeft: "auto", marginTop: "-22px" }}
            />
        </div>
    </Card>
    </div> */}

    {/* <div style={{display:'flex', justifyContent:'space-between'}}>
        <div className='cardStyle'>
            <p style={{fontFamily:'poppins', fontSize:'20px', color:'#0B4266', fontWeight:'bold'}}>Missing</p>
            <p style={{color:'red', fontSize:'54px', fontFamily:'poppins'}}> {missedCount}</p>
        </div>
        <div className='cardStyle'>
            <p style={{fontFamily:'poppins', fontSize:'20px', color:'#0B4266', fontWeight:'bold'}}>Pending</p>
            <p style={{color:'black', fontSize:'54px', fontFamily:'poppins'}}> {pendingCount}</p>
        </div>
        <div className='cardStyle'>
            <p style={{fontFamily:'poppins', fontSize:'20px', color:'#0B4266', fontWeight:'bold'}}>Accepted</p>
            <p style={{color:'green', fontSize:'54px', fontFamily:'poppins'}}> {acceptCount}</p>
        </div>
        <div className='cardStyle'>
            <p style={{fontFamily:'poppins', fontSize:'20px', color:'#0B4266', fontWeight:'bold'}}>Rejected</p>
            <p style={{color:'red', fontSize:'54px', fontFamily:'poppins'}}> {rejectCount}</p>
        </div>
    </div>  */}
    <div style={{ display: 'flex', justifyContent: 'space-between' }}>
        <button className='box' onClick={() => handleCountClick('Missed', filterOption, currentDate.toString(), currentMonth.toString(), currentWeek)} style={{ border: 'none', background: 'none', cursor:'pointer' }} title="Click to view the Calendar">
            <div style={{display:'flex', alignItems:'center', justifyContent:'space-around'}}>
                <p style={{ fontFamily: 'poppins', fontSize: '16px', color: '#0B4266', textAlign:'center', fontWeight:'bold' }}>Not Filled</p>
                <p style={{ color: 'red', fontSize: '34px', fontFamily: 'poppins' }}> {missedCount}</p>
            </div>
        </button>
        <button className='box' onClick={() => handleCountClick('Pending', filterOption, currentDate.toString(), currentMonth.toString(), currentWeek)} style={{ border: 'none', background: 'none', cursor:'pointer' }} title="Click to view the Calendar">
            <div style={{display:'flex', alignItems:'center', justifyContent:'space-around'}}>
                <p style={{ fontFamily: 'poppins', fontSize: '16px', color: '#0B4266', fontWeight:'bold'}}>Pending</p>    
                <p style={{ color: 'black', fontSize: '34px', fontFamily: 'poppins' }}> {pendingCount}</p>
            </div>
        </button>
        <button className='box' onClick={() => handleCountClick('Accepted',filterOption, currentDate.toString(), currentMonth.toString(), currentWeek)} style={{ border: 'none', background: 'none', cursor:'pointer' }} title="Click to view the Calendar">
            <div style={{display:'flex', alignItems:'center', justifyContent:'space-around'}}>
                <p style={{ fontFamily: 'poppins', fontSize: '16px', color: '#0B4266' , fontWeight:'bold'}}>Accepted</p>
                <p style={{ color: 'green', fontSize: '34px', fontFamily: 'poppins' }}> {acceptCount}</p>
            </div>
        </button>
        <button className='box' onClick={() => handleCountClick('Rejected', filterOption, currentDate.toString(), currentMonth.toString(), currentWeek)} style={{ border: 'none', background: 'none', cursor:'pointer' }} title="Click to view the Calendar">
            <div style={{display:'flex', alignItems:'center', justifyContent:'space-around'}}>
                <p style={{ fontFamily: 'poppins', fontSize: '16px', color: '#0B4266', fontWeight:'bold' }}>Rejected</p>
                <p style={{ color: 'red', fontSize: '34px', fontFamily: 'poppins' }}> {rejectCount}</p>
            </div>
        </button>
    </div>

    {/* <div style={{ display: 'flex', justifyContent: 'center', marginTop: '20px' }}>
        <ApexCharts
            options={{
                chart: {
                    type: 'line',
                },
                xaxis: {
                    categories: generateXAxisCategories(),
                },
                yaxis: {
                    title: {
                        text: 'Percentage of Extra Hours Worked',
                    },
                    labels: {
                        formatter: function (value) {
                            return value.toFixed(2); // Fix the decimal to 2 places
                        }
                    }
                },
                dataLabels: {
                    enabled: false,
                },
            }}
            series={[{ name: 'Performance', data: calculatePerformance().map(data => data.percentage) }]}
            type="line"
            width={1000}
            height={400}
        />
    </div> */}
  <div style={{ display: 'flex', justifyContent: 'center', marginTop: '20px', marginBottom:'20px',marginLeft: '20px', marginRight: '20px', boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)', borderRadius: '5px', padding: '20px' }}>
    <ResponsiveContainer width="80%" height={400}>
        <LineChart data={performanceData}>
            <defs>
                <linearGradient id="colorUv" x1="0" y1="0" x2="0" y2="1">
                    <stop offset="5%" stopColor="#8884d8" stopOpacity={0.8} />
                    <stop offset="95%" stopColor="#8884d8" stopOpacity={0} />
                </linearGradient>
            </defs>
            <XAxis dataKey="date">
                {/* Remove x-axis title */}
            </XAxis>
            <YAxis>
                <Label
                    value="Percentage of Extra Hours Worked"
                    angle={-90}
                    offset={0}
                    position="insideLeft"
                    style={{ textAnchor: 'middle', fill: '#333' }}
                />
            </YAxis>
            <CartesianGrid stroke="#eee" strokeDasharray="5 5" />
            <Tooltip />
            <Legend />
            <Line type="monotone" dataKey="percentage" stroke="#333" fillOpacity={1} fill="url(#colorUv)" />
            {/* Remove the Brush component */}
            <ReferenceLine y={0} stroke="#000" />
            {/* Remove x-axis Label */}
            <Label value="Time" offset={0} position="insideBottomRight" />
        </LineChart>
    </ResponsiveContainer>
</div>


    <div style={{display:'flex', justifyContent:'space-between', margin:'20px 20px', alignItems:'center'}}>
        <div style={{ boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)', borderRadius: '5px', padding: '20px', width:'50%'}}>
            <ApexCharts
                options={{
                    chart: {
                        type: 'pie',
                    },
                    labels: calculateTaskPercentages().map(task => task.taskName),
                }}
                series={calculateTaskPercentages().map(task => task.value)}
                type="pie"
                width={600}
                height={300}
            />
        </div>
        <div style={{ boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)', borderRadius: '5px', padding: '20px', width:'48%' }}>
            <ApexCharts
                options={{
                    chart: {
                        type: 'pie',
                    },
                    labels: calculateOverallPercentages().map(task => task.taskName),
                }}
                series={calculateOverallPercentages().map(task => task.value)}
                type="pie"
                width={600}
                height={300}
            />
        </div>
    </div>
    </>
  )
}

export default EmployeeTaskStatus


4/3/3034

AddTask.tsx (without date modification);

import React, { useState, useEffect, useCallback, ChangeEvent } from 'react';
import { Input, TimePicker, Select, notification, DatePicker, Button} from 'antd';
import { SearchOutlined } from '@mui/icons-material';
import dayjs from 'dayjs';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { useMsal } from '@azure/msal-react';
import '../Styles/CreateUser.css';
import DashboardLayout from './Layout';
import Chart from 'react-apexcharts';
import '../Styles/AddTask.css';
import {Table} from 'antd';
import { ColumnsType } from "antd/es/table";
import ApprovalRequest from './ApprovalRequest';
import { EditOutlined, DeleteOutlined,CloseCircleOutlined,LeftOutlined, RightOutlined } from '@ant-design/icons';
import Dashboard from './Dashboard';
import {Modal} from 'antd';
import { RecentRejected, SelectedKeys, RejectedKeys } from './MonthTasks';
import asset from '../../assets/images/asset.svg';
export interface DateTask{
  key: string;
  task: Task[];
}

export interface RequestedOn {
  [key: string]: string[]; // Each key represents a month (e.g., "February 2024") with an array of dates
}

export interface TaskRequestedOn {
  [userId: string]: RequestedOn; // Each key represents a month (e.g., "February 2024") with an array of dates
}


export interface Task {
  key?:string;
  idx: number; // Add this line
  date: string;
  userId: string;
  task: string;
  title: string;
  startTime: string;
  endTime: string;
  totalHours: string;
  description: string;
  reportingTo: string;
  slNo?: number;
}

interface PieChartData {
  options: {
    labels: string[];
  };
  series: number[];
}

type AddTaskProps = {
  setPieChartData: React.Dispatch<React.SetStateAction<{ [key: string]: number }>>;
  setApprovalRequestsData: React.Dispatch<React.SetStateAction<Task[]>>;
  approvalRequestsData: Task[];
};

const AddTask: React.FC<AddTaskProps> = ({ setPieChartData, setApprovalRequestsData }) => {
  const userId = '1234';
  const { Option } = Select; // Destructure the Option component from Select
  const navigate = useNavigate();
  const {confirm}= Modal;
  const location = useLocation();
  const { formattedDate } = location.state || { formattedDate: dayjs() }; // Access formattedDate from location.state
  const [deletedTask, setDeletedTask] = useState(false);
  const [formWidth, setFormWidth] = useState(800);
  const [currentDate, setCurrentDate] = useState(dayjs(formattedDate));
  const [currentWeek, setCurrentWeek] = useState(dayjs().startOf('week'));
  const [currentMonth, setCurrentMonth] = useState(dayjs().startOf('month'));
  const [isFormEnabled, setIsFormEnabled] = useState(false);
  const [cancelButton, setCancelButton] = useState(false);
  const [addTask, setAddTask] = useState<Task>({
    idx: 1, // Set initial idx
    date: currentDate.format('YYYY-MM-DD'),
    userId: userId,
    task: '',
    title: '',
    startTime: '',
    endTime: '',
    totalHours: '',
    description: '',
    reportingTo: '',
  });
  const [deletedTaskIdx, setDeletedTaskIdx] = useState<number | null>(null);
  const [taskList, setTaskList] = useState<Task[]>([]);
  const [filteredTasks, setFilteredTasks] = useState<Task[]>([]);
  const reportingOptions = ['ManagerA', 'ManagerB', 'ManagerC'];
  const taskOptions = ['Task','Project','Learning','Training','Meeting'];
  const [filterOption, setFilterOption] = useState('Date');
  const [isEdited, setIsEdited]= useState<boolean>(false);
  // State to manage the search input
  const [searchInput, setSearchInput] = useState('');
  const [isFormSubmitted, setIsFormSubmitted] = useState(false);
  const [selectedKeysToHide, setSelectedKeysToHide]=useState<string[]>([]);
  const [pieChartDataInForm, setPieChartDataInForm] = useState<PieChartData>({ options: { labels: [] }, series: [] });

 const updateSlNo = (tasks: Task[], deleteTask: boolean): Task[] => {
  return tasks.map((task, index) => ({
    ...task,
    slNo: index + 1,
    idx: deleteTask ? index + 1 : task.idx
  }));
};
const projectTitle = ['Project','TMS', 'LMS','SAASPE', 'Timesheet'];
const meetingTitle = ['Meeting', 'TMS', 'LMS','SAASPE', 'Timesheet', 'HR-Meet', 'Others'];
  useEffect(() => {
    const updateFormWidth = () => {
      const formElement = document.getElementById('myForm');
      if (formElement) {
        const newWidth = formElement.offsetWidth;
        setFormWidth(newWidth);
      }
    };

    window.addEventListener('resize', updateFormWidth);
    updateFormWidth();

    return () => {
      window.removeEventListener('resize', updateFormWidth);
    };
  }, []);

  const borderStyle = {
    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)', // Add box shadow
    margin: '10px 20px',
   // padding: '10px 20px',
    //width: formWidth + 'px',
    width: '1350px',
    height:'540px'
  };

  useEffect(() => {
    const storedKeysString: string | null = localStorage.getItem('selectedKeys');
    if (storedKeysString !== null) {
        const storedKeys: SelectedKeys = JSON.parse(storedKeysString);
        if (storedKeys.hasOwnProperty(userId)) {
            setSelectedKeysToHide(storedKeys[userId]);
        } else {
            console.log("User ID not found in stored keys");
        }
    } else {
        console.log("else-useEffect", storedKeysString);
    }
}, []);

useEffect(() => {
  // Calculate data for the pie chart
  const taskCounts: { [key: string]: number } = {};
  filteredTasks.forEach(task => {
      taskCounts[task.task] = (taskCounts[task.task] || 0) + 1;
  });

  const labels = Object.keys(taskCounts);
  const data = Object.values(taskCounts);

  // Update pie chart data
  setPieChartDataInForm({
      options: {
          labels: labels,
      },
      series: data,
  });
}, [filteredTasks]);

  
  const handleInputChange = (field: keyof Task, value: string) => {
    if (field === 'date') {
      const selectedDate = dayjs(value);
      if (selectedDate.isAfter(dayjs(), 'day')) {
        // Display a notification
        notification.warning({
          message: 'Warning',
          description: 'Cannot select a future date.',
        });
        // Set the selected date to today
        setCurrentDate(dayjs());
      } else {
        // Update the state with the selected date
        setCurrentDate(selectedDate);
      }
    }
  
    // Keep userId constant
    if (field === 'userId') {
      setAddTask((prevTask) => ({ ...prevTask, [field]: value }));
    } else {
      // Update startTime or endTime with the new value
      const updatedTime = value || dayjs().format('hh:mm A');
      setAddTask((prevTask) => ({ ...prevTask, [field]: updatedTime }));
      // Calculate the duration and update totalHours
      const updatedStartTime = field === 'startTime' ? updatedTime : addTask.startTime || dayjs().format('hh:mm A');
      const updatedEndTime = field === 'endTime' ? updatedTime : addTask.endTime || dayjs().format('hh:mm A');
      const duration = dayjs(updatedEndTime, 'hh:mm A').diff(dayjs(updatedStartTime, 'hh:mm A'), 'hour', true);
      setAddTask((prevTask) => ({
        ...prevTask,
        startTime: field === 'startTime' ? updatedTime : addTask.startTime,
        endTime: field === 'endTime' ? updatedTime : addTask.endTime,
        totalHours: duration.toFixed(2),
      }));
    }
  };
  
  useEffect(() => {
    const storedTaskListString = localStorage.getItem('taskList');
    const storedTaskList = storedTaskListString ? JSON.parse(storedTaskListString) : [];

    // Filter tasks based on the userId
    //const userTaskList = storedTaskList.filter((task:Task)=> task.userId === userId);

    // Assuming deletedTask is a state variable
    const updatedTaskList = updateSlNo(storedTaskList, deletedTask);

    setTaskList(updatedTaskList);
    setFilteredTasks(updatedTaskList);
  }, [deletedTask]); // Include deletedTask in the dependency array

  useEffect(() => {
    // Filter tasks based on the addTask.date and userId when it changes
    if (addTask.date) {
        const filtered = taskList.filter(task => task.date === addTask.date && task.userId === userId);
        setFilteredTasks(updateSlNo(filtered, deletedTask)); // Update slNo when loading tasks
    } else {
        // If no date is selected, display all tasks
        setFilteredTasks(updateSlNo(taskList, deletedTask)); // Update slNo when loading tasks
    }
}, [addTask.date, taskList]);


  useEffect(() => {
    // Update addTask with the current date
    if (!isEdited) {
      // Update addTask with the current date only when not in edit mode
      setAddTask((prevAddTask) => ({
        ...prevAddTask,
        date: dayjs(currentDate).format('YYYY-MM-DD'),
    }));
  }
    //setFilteredTasks(taskList);
    // Filter tasks based on the filterOption and currentDate when they change
    let filtered: Task[] = [];

    if (searchInput) {
      // If there is a search input, filter tasks based on date or month
      const searchDate = dayjs(searchInput);
      filtered = taskList.filter((task) => {
          if (filterOption === 'Date') {
            return ((dayjs(task.date).isSame(searchDate, 'day'))&&(task.userId===userId));
            } else if (filterOption === 'Week') {
              const startOfWeek = currentWeek.startOf('week');
              const endOfWeek = currentWeek.endOf('week');
              return (
                (dayjs(task.date).isSame(startOfWeek) || dayjs(task.date).isAfter(startOfWeek)) &&
                (dayjs(task.date).isSame(endOfWeek) || dayjs(task.date).isBefore(endOfWeek)) &&
                task.userId===userId
              );
            } else if (filterOption === 'Month') {
              // Format the searchInput in the same way as the task date
              const formattedSearchMonth = searchDate.format('MMMM');
              return ((dayjs(task.date).format('MMMM') === formattedSearchMonth) && (task.userId===userId));
            }
        return false;
      });
    }  else {
      // If no search input, apply the regular filtering based on filterOption and currentDate
      if (filterOption === 'Date') {
        filtered = taskList.filter((task) => 
          task.date === dayjs(currentDate).format('YYYY-MM-DD') && task.userId===userId);
        console.log("useEffect-date", filtered)
      } else if (filterOption === 'Week') {
        const startOfWeek = currentWeek.startOf('week');
        const endOfWeek = currentWeek.endOf('week');
        filtered = taskList.filter(
          (task) =>
            (dayjs(task.date).isSame(startOfWeek) || dayjs(task.date).isAfter(startOfWeek)) &&
            (dayjs(task.date).isSame(endOfWeek) || dayjs(task.date).isBefore(endOfWeek)) &&
            task.userId ===userId
        );
        console.log("useeffect-week", filtered);
      } else if (filterOption === 'Month') {
        const startOfMonth = currentMonth.startOf('month');
        const endOfMonth = currentMonth.endOf('month');
        filtered = taskList.filter(
          (task) =>
            (dayjs(task.date).isSame(startOfMonth) || dayjs(task.date).isAfter(startOfMonth)) &&
            (dayjs(task.date).isSame(endOfMonth) || dayjs(task.date).isBefore(endOfMonth)) && 
            (task.userId === userId)
        );
        console.log("useeffect", filtered);
      }
    }

    setFilteredTasks(updateSlNo(filtered, deletedTask));
  //  console.log("useeffect filtered-task", filteredTasks);
  }, [isEdited, filterOption, currentDate, currentMonth, currentWeek, taskList, searchInput]);

  const handleFilterChange = (value: any) => {
    setFilterOption(value);
  };

  const handleLeftArrowClick = () => {
    if (filterOption === 'Date') {
      console.log("handleLeftArrowClick -prev", currentDate);
      const previousDate = currentDate.subtract(1, 'day');
      console.log("handleLeftArrowClick previousDate",previousDate)
      setCurrentDate(previousDate);

    } else if (filterOption === 'Week') {
      const previousWeekStart = currentWeek.subtract(1, 'week').startOf('week');
      const previousWeekEnd = currentWeek.subtract(1, 'week').endOf('week');
      setCurrentWeek(previousWeekStart);
      console.log("previousWeek",previousWeekStart)
    } else if (filterOption === 'Month') {
      const previousMonthStart = currentMonth.subtract(1, 'month').startOf('month');
      const previousMonthEnd = currentMonth.subtract(1, 'month').endOf('month');
      setCurrentMonth(previousMonthStart);
    }
  };

  const handleRightArrowClick = () => {
    if (filterOption === 'Date') {
      const nextDate = currentDate.add(1, 'day');
      if(nextDate.isAfter(dayjs(), 'day')){
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future weeks.',
        });
        return;
      }
      setCurrentDate(nextDate);
    } else if (filterOption === 'Week') {
      const nextWeekStart = currentWeek.add(1, 'week').startOf('week');
      const nextWeekEnd = currentWeek.add(1, 'week').endOf('week');
      if (nextWeekStart.isAfter(dayjs(), 'day')) {
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future weeks.',
        });
        return;
      }
      setCurrentWeek(nextWeekStart);
      
    } else if (filterOption === 'Month') {
      const nextMonthStart = currentMonth.add(1, 'month').startOf('month');
      if (nextMonthStart.isAfter(dayjs(), 'day')) {
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future months.',
        });
        return;
      }
      setCurrentMonth(nextMonthStart);
    }
    
  };

  const handleToggleForm = () => {
    setIsFormEnabled((prevIsFormEnabled) => !prevIsFormEnabled);
    setCancelButton((prevIsFormEnabled) => !prevIsFormEnabled);
    // If you want to reset the form when disabling it, you can reset the form state here
    if (!isFormEnabled) {
      setAddTask({
        date: dayjs(currentDate).format('YYYY-MM-DD'),
        userId:userId,
        task: '',
        title:'',
        startTime: '',
        endTime: '',
        totalHours:'',
        description: '',
        reportingTo: '',
        idx: addTask.idx,
      });
    }
  };

  const handleFormSubmit = () => {
    const userId = addTask.userId;

    // Check if the addTask date is included in selectedKeysToHide
    if (selectedKeysToHide.includes(addTask.date)) {
      notification.warning({
          message: 'Restricted',
          description: `The Task Approved: ${addTask.date} & Restrict to Add New Task`,
      });
      return;
  }

  const taskRequestedOn = localStorage.getItem('taskRequestedOn');
  const approvedRequestedOnString = localStorage.getItem('approveTaskRequestedOn');
const approvedRequestedOn: TaskRequestedOn = approvedRequestedOnString ? JSON.parse(approvedRequestedOnString) : {};
console.log("approvedRequestedOn", approvedRequestedOn);  
    // Check if the date is not in the taskList and it's before the currentDate
    // const currentDateFormatted = dayjs().format('YYYY-MM-DD');
    // if (
    //     (!taskList.find(task => (task.userId===addTask.userId) && (task.date === addTask.date)) && dayjs(addTask.date).isBefore(currentDateFormatted))
    // ) {
    //     notification.warning({
    //         message: 'Restricted',
    //         description: 'Cannot add task for a date before the current date and not present in the task list.',
    //     });
    //     return;
    // }

    const currentDateFormatted = dayjs().format('YYYY-MM-DD');
    // Check if the date is not present in the approvedRequestedOn and satisfies the condition
    console.log("approvedRequestedOn", approvedRequestedOn[userId][dayjs(addTask?.date).format('YYYY-MM')]?.includes(addTask.date));
    if (
      (!approvedRequestedOn[userId]?.[dayjs(addTask?.date).format('YYYY-MM')]?.includes(addTask.date)) &&
      (!taskList.find(task => task.userId === addTask.userId && task.date === addTask.date) &&
      dayjs(addTask.date).isBefore(currentDateFormatted))
  ) {
      notification.warning({
          message: 'Restricted',
          description: 'Cannot add task for a date before the current date and not present in the task list.',
      });
      return;
  }
  
  

    // Check for overlapping tasks in the specified time range
    const overlappingTask = taskList.find(task => {
      if(task.userId !== addTask.userId) return false;
      const newTaskStartTime = dayjs(addTask.startTime, 'hh:mm A');
      const newTaskEndTime = dayjs(addTask.endTime, 'hh:mm A');
      const taskStartTime = dayjs(task.startTime, 'hh:mm A');
      const taskEndTime = dayjs(task.endTime, 'hh:mm A');
    
      // Check if the new task overlaps with any existing task
      return (
        !isEdited && task.date === addTask.date &&
        (
          ((newTaskStartTime.isSame(taskStartTime) || newTaskStartTime.isAfter(taskStartTime)) && newTaskStartTime.isBefore(taskEndTime)) ||
          ((newTaskEndTime.isSame(taskStartTime) || newTaskEndTime.isAfter(taskStartTime)) && newTaskEndTime.isBefore(taskEndTime)) ||
          (newTaskStartTime.isBefore(taskStartTime) && (newTaskEndTime.isSame(taskEndTime) || newTaskEndTime.isAfter(taskEndTime)))
        )
      );
    });
      
    if (overlappingTask) {
      notification.warning({
        message: 'Restricted',
        description: 'Task already exists in the specified time range.',
      });
      return;
    }

    if (isEdited) {
      // If editing, update the existing task
      const updatedTaskList = taskList.map(task =>
        (task.idx === addTask.idx) && (task.userId === addTask.userId)
         ? { ...addTask } : task
      );
      setTaskList(updatedTaskList);
      setFilteredTasks(updateSlNo(updatedTaskList, deletedTask));
      localStorage.setItem('taskList', JSON.stringify(updatedTaskList));
      setIsEdited(false);
    } else {
      // Update the taskList
      const updatedTaskList = [
        ...taskList,
        { ...addTask, idx: taskList.length + 1 }
      ];
      setTaskList(updatedTaskList);
      setFilteredTasks(updateSlNo(updatedTaskList, deletedTask));
      localStorage.setItem('taskList', JSON.stringify(updatedTaskList));
    }

    // After successful submission, remove the date from approvedRequestedOn
  // if (approvedRequestedOn[userId]?.[dayjs(addTask?.date).format('YYYY-MM')]?.includes(addTask.date)) {
  //   const updatedApprovedRequestedOn = { ...approvedRequestedOn };
  //   const index = updatedApprovedRequestedOn[userId][dayjs(addTask?.date).format('YYYY-MM')].indexOf(addTask.date);
  //   updatedApprovedRequestedOn[userId][dayjs(addTask?.date).format('YYYY-MM')].splice(index, 1);
  //   localStorage.setItem('approveTaskRequestedOn', JSON.stringify(updatedApprovedRequestedOn));
  // }
  
    // Clear the form with the default date and reset idx
    setAddTask({
      idx: taskList.length + 2, // Set a new idx
      date: dayjs(currentDate).format('YYYY-MM-DD'),
      userId: userId,
      task: '',
      title:'',
      startTime: '',
      endTime: '',
      totalHours: '',
      description: '',
      reportingTo: '',
    });
    setIsEdited(false);
    setIsFormSubmitted(true);
};

const handleRequestForm = () => {
  const userId = addTask.userId;
  const month = dayjs(addTask.date).format('YYYY-MM');
  const currentDateFormatted = dayjs().format('YYYY-MM-DD');

  if (
      !taskList.find(task => task.userId === userId && task.date === addTask.date) &&
      dayjs(addTask.date).isBefore(currentDateFormatted)
  ) {
      const taskRequestedOn: TaskRequestedOn = JSON.parse(localStorage.getItem('taskRequestedOn') || '{}');

      if (!taskRequestedOn[userId]) {
          taskRequestedOn[userId] = {};
      }

      if (!taskRequestedOn[userId][month]) {
          taskRequestedOn[userId][month] = [];
      }
      let datesToRequest: string[] = [];

      if (filterOption === 'Month') {
          // Get the first and last dates of the month
          const firstDayOfMonth = dayjs(addTask.date).startOf('month');
          const lastDayOfMonth = dayjs(addTask.date).endOf('month');
          const presentDate = dayjs().format('YYYY-MM-DD');
          // Generate all dates in the month
          let currentDate = firstDayOfMonth;
          while ((currentDate.isSame(lastDayOfMonth, 'day')|| currentDate.isBefore(lastDayOfMonth,'day')) && !currentDate.isAfter(presentDate)) {
              const currentDateFormatted = currentDate.format('YYYY-MM-DD');
              if (!taskList.some(task => task.userId === userId && task.date === currentDateFormatted)) {
                  // Check if the date is not already present
                  if (!taskRequestedOn[userId][month].includes(currentDateFormatted)) {
                      datesToRequest.push(currentDateFormatted);
                  }
              }
              currentDate = currentDate.add(1, 'day');
          }
      } else if (filterOption === 'Week') {
          // Get the first and last dates of the week
          const startOfWeek = dayjs(addTask.date).startOf('week');
          const endOfWeek = dayjs(addTask.date).endOf('week');
          const presentDate = dayjs().format('YYYY-MM-DD');
          // Generate all dates in the week
          let currentDate = startOfWeek;
          while ((currentDate.isSame(endOfWeek, 'day')|| currentDate.isBefore(endOfWeek, 'day')) && !currentDate.isAfter(presentDate)) {
              const currentDateFormatted = currentDate.format('YYYY-MM-DD');
              if (!taskList.some(task => task.userId === userId && task.date === currentDateFormatted)) {
                  // Check if the date is not already present
                  if (!taskRequestedOn[userId][month].includes(currentDateFormatted)) {
                      datesToRequest.push(currentDateFormatted);
                  }
              }
              currentDate = currentDate.add(1, 'day');
          }
      } else if (filterOption === 'Date') {
          // Generate dates for the specific date option
          const currentDate = dayjs(addTask.date).format('YYYY-MM-DD');
          if (!taskList.some(task => task.userId === userId && task.date === currentDate)) {
              // Check if the date is not already present
              if (!taskRequestedOn[userId][month].includes(currentDate)) {
                  datesToRequest.push(currentDate);
              }
          }
      }

      taskRequestedOn[userId][month] = taskRequestedOn[userId][month].concat(datesToRequest);

      localStorage.setItem('taskRequestedOn', JSON.stringify(taskRequestedOn));
  }
};



  const handleClearSubmit = () => {
    // Clear the form with the default date and set idx
    setAddTask({
      date: dayjs(addTask.date).format('YYYY-MM-DD'),
      userId: userId,
      task: '',
      title:'',
      startTime: '',
      endTime: '',
      totalHours:'',
      description: '',
      reportingTo: '',
      idx: addTask.idx 
    });
  }
  
//   const handleEditTask = (idx: number) => {
//     const taskToEdit = taskList.find((task) => task.idx === idx);
//     const isExistingTask = taskToEdit !== undefined; // Check if taskToEdit is defined
//     // if (taskToEdit) {
//         // const isDateSelected = selectedKeysToHide.includes(taskToEdit.date);
        
//     //     // if (isDateSelected && isExistingTask) {
//     //     //     // Date is selected and it's an existing task, so prevent further action
//     //     //     // You can display a message or handle this case according to your application's logic
//     //     //     return;
//     //     // }

//     //     // setIsEdited(true);
//     //     // setAddTask({
//     //     //     date: taskToEdit.date,
//     //     //     userId: taskToEdit.userId,
//     //     //     task: taskToEdit.task,
//     //     //     startTime: taskToEdit.startTime,
//     //     //     endTime: taskToEdit.endTime,
//     //     //     totalHours: taskToEdit.totalHours,
//     //     //     description: taskToEdit.description,
//     //     //     reportingTo: taskToEdit.reportingTo,
//     //     //     idx: taskToEdit.idx, 
//     //     // });

//     //     // // Now, you can perform additional actions or display a modal for editing
//     //     // setCurrentDate(dayjs(taskToEdit.date));

//     // }

//     if (taskToEdit) {
//       const isDateSelected = selectedKeysToHide.includes(taskToEdit.date);

//       if (isDateSelected && taskToEdit.isNew) {
//           // If the task is newly added and its date is selected, allow editing
//           setIsEdited(true);
//           setAddTask({ ...taskToEdit });
//           setCurrentDate(dayjs(taskToEdit.date));
//       } else if (!isDateSelected) {
//           // If the date is not selected, allow editing
//           setIsEdited(true);
//           setAddTask({ ...taskToEdit });
//           setCurrentDate(dayjs(taskToEdit.date));
//       } else {
//           // Date is selected and it's an existing task, so prevent further action
//           // You can display a message or handle this case according to your application's logic
//           return;
//       }
//   } else {
//       // Handle the case where taskToEdit is undefined
//       // You can display a message or handle this case according to your application's logic
//       return;
//   }
// };

const handleEditTask = (idx: number) => {
  const taskToEdit = taskList.find((task) => (task.idx === idx) && (task.userId === addTask.userId));
  if (taskToEdit) {
    // Check if the date is included in selectedKeysToHide
    if (selectedKeysToHide.includes(taskToEdit.date)) {
      // Date is included in selectedKeysToHide, so prevent further action
      // You can display a message or handle this case according to your application's logic
      return;
    }

    setIsEdited(true);
  
    setAddTask({
        date: taskToEdit.date,
        userId: taskToEdit.userId,
        task: taskToEdit.task,
        title:taskToEdit.title,
        startTime: taskToEdit.startTime,
        endTime: taskToEdit.endTime,
        totalHours: taskToEdit.totalHours,
        description: taskToEdit.description,
        reportingTo: taskToEdit.reportingTo,
        idx: taskToEdit.idx, 
    });

    // Now, you can perform additional actions or display a modal for editing
    setCurrentDate(dayjs(taskToEdit.date));
  }
};

const handleDeleteTask = useCallback((idx: number) => {
  const taskToDelete = taskList.find(task => (task.idx === idx));  //&&(task.userId === addTask.userId)
  
  if (!taskToDelete || selectedKeysToHide.includes(taskToDelete.date)) {
    // Task not found or its date is in selectedKeysToHide, do not delete
    return;
  }

  // Display confirmation modal before deleting the task
  confirm({
    title: 'Delete Task',
    content: 'Are you sure you want to delete the task?',
    okText: 'Yes',
    okButtonProps: {
      style: {
        width: '80px', backgroundColor: '#0B4266', color: 'white'
      },
    },
    cancelText: 'No',
    cancelButtonProps: {
      style: {
        width: '80px', backgroundColor: '#0B4266', color: 'white'
      },
    },
    onOk() {
      // Logic to delete the task if user confirms
      const updatedTaskList = taskList.filter(task => (task.idx !== idx)); //&&(task.userId==addTask.userId)
  
      // Reindex the idx starting from 1
      const reindexedTaskList = updateSlNo(updatedTaskList, true);
  
      setTaskList(reindexedTaskList);
      setFilteredTasks(reindexedTaskList);
  
      // Update localStorage
      localStorage.setItem('taskList', JSON.stringify(reindexedTaskList));
    },
    onCancel() {
      // Logic if user cancels deletion
    },
  });
}, [taskList, selectedKeysToHide]);


// const handleDeleteTask = useCallback((idx: number) => {
//   // Check if the date is included in selectedKeysToHide
//   const isDateIncluded = selectedKeysToHide.some(date => {
//       // Assuming taskList contains tasks with a 'date' property
//       const task = taskList.find(task => task.idx === idx);
//       return task && task.date === date;
//   });

//   // Toggle the deletedTask flag based on the presence of the date in selectedKeysToHide
//   setDeletedTask(!isDateIncluded);

//   // Save idx in state
//   setDeletedTaskIdx(idx);
// }, [selectedKeysToHide, taskList]);


//   useEffect(() => {
//     if (deletedTask) {
//       // Implement the logic to delete the task based on idx
//       const updatedTaskList = taskList.filter(task => {
//         // Check if the task date is not included in selectedKeysToHide and isNew is true
//         return !selectedKeysToHide.includes(task.date);
//       });
  
//       // Reindex the idx starting from 1 and use deletedTask flag
//       const reindexedTaskList = updateSlNo(updatedTaskList, deletedTask);
  
//       setTaskList(reindexedTaskList);
//       setFilteredTasks(reindexedTaskList);
  
//       // Update localStorage
//       localStorage.setItem('taskList', JSON.stringify(reindexedTaskList));
  
//       // Reset the deletedTask flag after updating
//       setDeletedTask(false);
//     }
//   }, [deletedTask, deletedTaskIdx, selectedKeysToHide, taskList]);

  // const handleDeleteTask = useCallback((idx: number) => {
  //   // Display confirmation modal before deleting the task
  //   confirm({
  //     title: 'Delete Task',
  //     content: 'Are you sure you want to delete the task?',
  //     okText: 'Yes',
  //     okButtonProps: {
  //       style: {
  //         width: '80px', backgroundColor: '#0B4266', color: 'white'
  //       },
  //     },
  //     cancelText: 'No',
  //     cancelButtonProps: {
  //       style: {
  //         width: '80px', backgroundColor: '#0B4266', color: 'white'
  //       },
  //     },
  //     onOk() {
  //       // Logic to delete the task if user confirms
  //       const updatedTaskList = taskList.filter(task => task.idx !== idx);
    
  //       // Reindex the idx starting from 1
  //       const reindexedTaskList = updateSlNo(updatedTaskList);
    
  //       setTaskList(reindexedTaskList);
  //       setFilteredTasks(reindexedTaskList);
    
  //       // Update localStorage
  //       localStorage.setItem('taskList', JSON.stringify(reindexedTaskList));
  //     },
  //     onCancel() {
  //       // Logic if user cancels deletion
  //     },
  //   });
  // }, [taskList]);

  
  
  // const handleOverallSubmit = () => {
  //   // Assuming you have an API endpoint for approval requests
  //   //const apiUrl = 'http://localhost:3000/approvalrequests';

  //   // Prepare the data to be sent
  //   const requestData = filteredTasks.map(task => ({
  //     date: task.date,
  //     userId: task.userId,
  //     task: task.task,
  //     startTime: task.startTime,
  //     endTime: task.endTime,
  //     totalHours: task.totalHours,
  //     description: task.description,
  //     reportingTo: task.reportingTo,
  //     idx: task.idx,
  //   }));
  //   // Navigate to the approvalrequests component with the data
  //   navigate('/approvalrequests', { state: { requestData } });
  //   // Make the HTTP POST request to the /approvalrequests endpoint
  //   // fetch(apiUrl, {
  //   //   method: 'POST',
  //   //   headers: {
  //   //     'Content-Type': 'application/json',
  //   //   },
  //   //   body: JSON.stringify(requestData),
  //   // })
  //   //   .then(response => {
  //   //     if (!response.ok) {
  //   //       console.log("network response was not okay");
  //   //       throw new Error('Network response was not ok');
          
  //   //     }
  //   //     return response.json();
  //   //   })
  //   //   .then(data => {
  //   //     // Handle the success response from the server
  //   //     console.log('Submission successful:', data);
  //   //     // You may want to show a success message or redirect the user
  //   //     // Show success notification
  //   //     notification.success({
  //   //       message: 'Submission Successful',
  //   //       description: 'Task details submitted successfully!',
  //   //     });
  //   //   })
  //   //   .catch(error => {
  //   //     // Handle errors during the fetch
  //   //     console.error('Error during submission:', error);
  //   //     // Show error notification
  //   //     notification.error({
  //   //       message: 'Submission Failed',
  //   //       description: 'There was an error submitting the task details.',
  //   //     });
  //   //     // You may want to show an error message to the user
  //   //   });
  // };

//   const handleOverallSubmit = () => {
//     // Prepare the data to be sent
//     const requestData: Task[] = filteredTasks.map(task => ({
//         date: task.date,
//         userId: task.userId,
//         task: task.task,
//         startTime: task.startTime,
//         endTime: task.endTime,
//         totalHours: task.totalHours,
//         description: task.description,
//         reportingTo: task.reportingTo,
//         idx: task.idx,
//     }));

//     // Set the success notification
//     notification.success({
//         message: 'Submission Successful',
//         description: 'Task details submitted successfully!',
//     });
//     navigate('/approvalrequests')
//     // Set the approvalRequestsData state
//     console.log("handleOverAllsubmit", requestData);
//     setApprovalRequestsData(requestData);
//     localStorage.setItem('requestedOn', addTask.date);
//     // Store the approvalRequestsData in local storage
//     localStorage.setItem('approvalRequestsData', JSON.stringify(requestData));

//     // Retrieve rejectedKeys from local storage
//     const rejectedKeysString = localStorage.getItem('rejectedKeys');
//     console.log("rejectedKeysString",rejectedKeysString);
//     if (rejectedKeysString) {
//       let parsedRejectedKeys: RecentRejected[] = JSON.parse(rejectedKeysString);
//       console.log("rejectedKeys", parsedRejectedKeys);
//       // Check if 'submit' exists in rejectedKeys
//       const date = requestData.length > 0 ? requestData[0].date : '';
//       if (parsedRejectedKeys.some((key) => key.date === date)) {
//         // Remove 'date' from rejectedKeys
//         const updatedRejectedKeys = parsedRejectedKeys.filter((key) => key.date !== date);

//         // Update rejectedKeys in local storage
//         localStorage.setItem('rejectedKeys', JSON.stringify(updatedRejectedKeys));
//     }
//     }
// };



const handleOverallSubmit = () => {

  // Filter tasks where userId matches addTask.userId
  const tasksToSend: Task[] = filteredTasks.filter(task => task.userId === addTask.userId);
    // Prepare the data to be sent
    const requestData: Task[] = tasksToSend.map(task => ({
        date: task.date,
        userId: task.userId,
        task: task.task,
        title:task.title,
        startTime: task.startTime,
        endTime: task.endTime,
        totalHours: task.totalHours,
        description: task.description,
        reportingTo: task.reportingTo,
        idx: task.idx,
    }));

    // Group tasks by date
    const groupedTasks: { [date: string]: Task[] } = {};
    requestData.forEach(task => {
        if (groupedTasks.hasOwnProperty(task.date)) {
            groupedTasks[task.date].push(task);
        } else {
            groupedTasks[task.date] = [task];
        }
    });

        // Determine the key based on the filterOption
    let key: string;
    if (filterOption === "Date") {
        key = currentDate.format("MMMM YYYY"); // Format Dayjs object to "February 2024"
    } else if (filterOption === 'Week') {
        key = currentWeek.startOf('week').format("MMMM YYYY"); // Format Dayjs object to "February 2024"
    } else {
        key = currentMonth.startOf('month').format("MMMM YYYY"); // Format Dayjs object to "February 2024"
    }

    let date: string[] = [];
    if (filterOption === "Date") {
        date.push(currentDate.format('YYYY-MM-DD')); // Format Dayjs object to "February 2024"
    } else if (filterOption === 'Week') {
        const fromDate = currentWeek.startOf('week').format("YYYY-MM-DD"); // Format Dayjs object to "February 2024"
        const toDate = currentWeek.endOf('week').format("YYYY-MM-DD");
        date.push(fromDate);
        date.push(toDate);
    } else {
        const fromDate = currentMonth.startOf('month').format("YYYY-MM-DD"); // Format Dayjs object to "February 2024"
        const toDate = currentMonth.endOf('month').format("YYYY-MM-DD");
        date.push(fromDate);
        date.push(toDate);
    }

    // Retrieve requestedOn from local storage
    const requestedOnString = localStorage.getItem('requestedOn');
    const requestedOn: RequestedOn = requestedOnString ? JSON.parse(requestedOnString) : {};

    // Update requestedOn with the new date
    requestedOn[key] = date;

    // Update requestedOn in local storage
    localStorage.setItem('requestedOn', JSON.stringify(requestedOn));


    // Store the approvalRequestsData in local storage as an object
    const approvalRequestedData: { [date: string]: Task[] } = groupedTasks;
    localStorage.setItem('approvalRequestedData', JSON.stringify(approvalRequestedData));

    // Assuming userId is available in your component's scope

    // Retrieve rejectedKeys from local storage for the specific userId
    const rejectedKeysString = localStorage.getItem('rejectedKeys');
    console.log("rejectedKeysString", rejectedKeysString);

    if (rejectedKeysString) {
        const parsedRejectedKeys: RejectedKeys = JSON.parse(rejectedKeysString);
        console.log("rejectedKeys", parsedRejectedKeys);

        // Check if userId exists in rejectedKeys
        if (parsedRejectedKeys.hasOwnProperty(userId)) {
            // Get the rejectedKeys for the specific userId
            const userRejectedKeys = parsedRejectedKeys[userId];

            // Check if 'submit' exists in rejectedKeys for the specific user
            const date = requestData.length > 0 ? requestData[0].date : '';
            if (userRejectedKeys.some((key) => key.date === date)) {
                // Remove 'date' from rejectedKeys for the specific user
                const updatedRejectedKeys = userRejectedKeys.filter((key) => key.date !== date);

                // Update rejectedKeys in local storage for the specific user
                parsedRejectedKeys[userId] = updatedRejectedKeys;
                localStorage.setItem('rejectedKeys', JSON.stringify(parsedRejectedKeys));
            }
        }
    }

    // Set the success notification
    notification.success({
        message: 'Submission Successful',
        description: 'Task details submitted successfully!',
    });

    // Navigate to approval requests page
    navigate('/approvalrequests');
};

  const columns: ColumnsType<Task> = [
    {
      title: 'Sl.no',
      //sorter: (a: Task, b: Task) => (a.slNo && b.slNo ? a.slNo - b.slNo : 0),
      dataIndex: 'slNo',
      key: 'slNo',
      fixed: 'left',
    },
    {
      title: 'Task',
      //sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
      dataIndex: 'task',
      key: 'task',
      fixed: 'left',
    },
    {
      title: 'Title',
      //sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
      dataIndex: 'title',
      key: 'title',
      fixed: 'left',
    },
    {
      title: 'Date',
      //sorter: (a: Task, b: Task) => a.date.localeCompare(b.date),
      dataIndex: 'date',
      key: 'date',
      fixed: 'left',
    },
    {
      title: 'Start Time',
      //sorter: (a: Task, b: Task) => a.startTime.localeCompare(b.startTime),
      dataIndex: 'startTime',
      key: 'startTime',
      fixed: 'left',
    },
    {
      title: 'End Time',
      //sorter: (a: Task, b: Task) => a.endTime.localeCompare(b.endTime),
      dataIndex: 'endTime',
      key: 'endTime',
      fixed: 'left',
    },
    {
      title: 'Total Hours',
      //sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
      dataIndex: 'totalHours',
      key: 'totalHours',
      fixed: 'left',
    },
    {
      title: 'Description',
      //sorter: (a: Task, b: Task) => a.description.localeCompare(b.description),
      dataIndex: 'description',
      key: 'description',
      fixed: 'left',
    },
    {
      title: 'Reporting To',
      //sorter: (a: Task, b: Task) => a.reportingTo.localeCompare(b.reportingTo),
      dataIndex: 'reportingTo',
      key: 'reportingTo',
      fixed: 'left',
    },
    // {
    //   title: 'Actions',
    //   dataIndex: 'actions',
    //   key: 'actions',
    //   render: (_, record, index) => {
    //     const isDateSelected = selectedKeysToHide.includes(record.date); // Assuming record.date represents the date of the task
    //     return (
    //       <div>
    //         <EditOutlined
    //           onClick={() => handleEditTask(record.idx)}
    //           style={{
    //             marginRight: '8px',
    //             cursor: isDateSelected ? 'not-allowed' : 'pointer',
    //             color: isDateSelected ? 'grey' : 'blue',
    //             fontSize: '20px',
    //           }}
    //           disabled={isDateSelected}
    //         />
    //         <DeleteOutlined
    //           onClick={() => handleDeleteTask(record.idx)}
    //           style={{
    //             cursor: isDateSelected ? 'not-allowed' : 'pointer',
    //             color: isDateSelected ? 'grey' : 'red',
    //             fontSize: '20px',
    //           }}
    //           disabled={isDateSelected}
    //         />
    //       </div>
    //     );
    //   },
    // }    
    {
      title: 'Actions',
      dataIndex: 'actions',
      key: 'actions',
      render: (_, record, index) => {
        const isExistingTask = taskList.some(task => task.idx === record.idx);
        const isDateSelected = selectedKeysToHide.includes(record.date);
        
        // Filter tasks by userId
        const userTasks = taskList.filter(task => task.userId === record.userId);
        
        // Check if the user has tasks for the selected date
        const hasUserTasksForDate = userTasks.some(task => task.date === record.date);
    
        return (
          <div>
            <EditOutlined
              onClick={() => handleEditTask(record.idx)}
              style={{
                marginRight: '8px',
                cursor: (isDateSelected || !hasUserTasksForDate) ? 'not-allowed' : 'pointer',
                color: (isDateSelected || !hasUserTasksForDate) ? 'grey' : 'blue', 
                fontSize: '20px',
              }}
              disabled={isDateSelected || !hasUserTasksForDate}
            />
            <DeleteOutlined
              onClick={() => handleDeleteTask(record.idx)}
              style={{
                cursor: (isDateSelected || !hasUserTasksForDate) ? 'not-allowed' : 'pointer',
                color: (isDateSelected || !hasUserTasksForDate) ? 'grey' : 'red',
                fontSize: '20px',
              }}
              disabled={isDateSelected || !hasUserTasksForDate}
            />
          </div>
        );
      },
    }    
    
       
  ]

  return (
    <DashboardLayout>
      <div className='createuser-main'>
        <div className='header'>
          <div>
            <h1>Add Task</h1>
          </div>
          { filterOption === 'Month' ? (
            <div style={{display:'flex', justifyContent:'flex-end'}}>
              <div className='date'>From: {dayjs(currentMonth).format('YYYY-MM-DD')}</div>
              <div className='date' style={{ marginLeft: '40px' }}>To: {dayjs(currentMonth).endOf('month').format('YYYY-MM-DD')}</div>
            </div>
            ) : filterOption === 'Week' ? (
              <div style={{display:'flex', justifyContent:'flex-end'}}>
                <div className='date'>From: {dayjs(currentWeek).format('YYYY-MM-DD')}</div>
                <div className='date' style={{ marginLeft: '40px' }}>To: {dayjs(currentWeek).endOf('week').format('YYYY-MM-DD')}</div>
              </div>
            )  : (
              <div className='date'>Date: {currentDate.format('YYYY-MM-DD')}</div>
            )
          }
        </div>
        {(filterOption === 'Date' || ((filterOption === 'Week' || filterOption === 'Month') && isEdited)) || isFormEnabled  ? ( <form>
            <div>
              {isFormEnabled && (
                <CloseCircleOutlined
                  style={{ margin: '10px 20px', display: 'flex', justifyContent: 'flex-end', color: 'black', width:'900px' }}
                  onClick={handleToggleForm} // Call the handleToggleForm function on click
                />
              )}
              <div className='section-addtask' style={{width:'50%'}}>
                <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label style={{color:'#0B4266'}} htmlFor='addTaskID'>Date</label>
                  </div>
                  {/* <input
                    type="date"
                    style={{ width: '100%' }}
                    className='timepicker'
                  /> */}
                  <Input
                    type='date'
                    placeholder='Enter your Employee ID'
                    value={currentDate.format('YYYY-MM-DD')} 
                    onChange={(e) => handleInputChange('date', e.target.value)}
                  />
                  {/* <DatePicker
                      value={dayjs(currentDate)} // Convert currentDate to Dayjs object
                      format="YYYY-MM-DD" // Specify the date format
                      onChange={(date, dateString) => handleInputChange('date', dateString)} // Use dateString to get the selected date
                      style={{ width: '100%', height:'35%' }} // Adjust the width as needed
                  /> */}
                </div>
                {/* <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label htmlFor='addTaskID'>User ID</label>
                  </div>
                  <Input
                    placeholder='Enter your Employee ID'
                    value={addTask.userId}
                    onChange={(e) => handleInputChange('userId', e.target.value)}  
                  />
                </div> */}
                 <div className='create-layout-addtask'>
                  <div>
                    <label style={{color:'#0B4266'}} htmlFor='task'>Task</label>
                  </div>
                  <div>
                    <select
                      id='task'
                      value={addTask.task}
                      onChange={(e) => handleInputChange('task', e.target.value)}
                    >
                      {taskOptions.map((option) => (
                          <option key={option} value={option}>
                            {option}
                          </option>
                        ))}
                    </select>
                  </div>
                  
                </div>
                <div className='create-layout-addtask'>
                  {addTask.task === 'Meeting' && (
                    <>
                      <div>
                        <label style={{ color:'#0B4266' }} htmlFor='title'>Meeting</label>
                      </div>
                      <div>
                        <select
                          id='task'
                          value={addTask.title}
                          onChange={(e) => handleInputChange('title', e.target.value)}
                        >
                          {meetingTitle.map((option, index) => (  // Use 'index' as the key
                            <option key={index} value={option}>
                              {option}
                            </option>
                          ))}
                        </select>
                      </div>
                    </>
                  )}
                  {(addTask.task === 'Project'|| addTask.task==='Learning' || addTask.task==='Training') && (
                    <>
                      <div>
                        <label style={{ color:'#0B4266' }} htmlFor='title'>{addTask.task}</label>
                      </div>
                      <div>
                        <select
                          id='task'
                          value={addTask.title}
                          onChange={(e) => handleInputChange('title', e.target.value)}  // Corrected 'title' to 'task'
                        >
                          {projectTitle.map((option, index) => (  // Use 'index' as the key
                            <option key={index} value={option}>
                              {option}
                            </option>
                          ))}
                        </select>
                      </div>
                    </>
                  )}
                </div>

              </div>
              <div style={{display:'flex', alignItems:'center'}}>
                <div>
                  <div className='section-addtask' style={{width:'125%'}}>
                    <div className='create-layout-addtask-left'>
                      <div>
                        <label htmlFor='startTime'>Start Time</label>
                      </div>
                      <TimePicker
                        value={
                          addTask.startTime
                            ? dayjs(addTask.startTime, 'hh:mm A') // Convert to dayjs here
                            : null
                        }
                        onChange={(time, timeString) =>
                          handleInputChange('startTime', timeString)
                        }
                        className='timepicker'
                        format='hh:mm A' // Set the format to include AM/PM
                      />
                    </div>
                    <div className='create-layout-addtask'>
                      <div>
                        <label style={{color:'#0B4266'}} htmlFor='endTime'>End Time</label>
                      </div>
                      <TimePicker
                        value={
                          addTask.endTime
                            ? dayjs(addTask.endTime, 'HH:mm A') // Convert to dayjs here
                            : null
                        }
                        onChange={(time, timeString) =>
                          handleInputChange('endTime', timeString)
                        }
                        className='timepicker'
                        format='hh:mm A' 
                        rootClassName='timer'
                      />
                    </div>
                  </div>
                  <div className='section-addtask' style={{width:'125%'}}>
                    
                  <div className='create-layout-addtask-left  '>
                      <div style={{marginBottom:'10px'}}>
                        <label style={{color:'#0B4266'}} htmlFor='totalHours'>Total Hours</label>
                      </div>
                      <Input
                        placeholder='Enter your Total Hours'
                        value={addTask.totalHours}
                        onChange={(e) => handleInputChange('totalHours', e.target.value)}
                        
                      />
                    </div>
                    <div className='create-layout-addtask-reportingTo  '>
                      <div className='create-layout-reportingTo'>
                        <label style={{color:'#0B4266'}} htmlFor='reportingTo'>Reporting To</label>
                      </div>
                      <select
                        id='reportingTo-addtask'
                        value={addTask.reportingTo}
                        onChange={(e) => handleInputChange('reportingTo', e.target.value)}
                      >
                        <option value=''>Select Reporting To</option>
                        {reportingOptions.map((option) => (
                          <option key={option} value={option}>
                            {option}
                          </option>
                        ))}
                      </select>
                    </div> 
                  </div>  
                  <div>
                    <div className='create-layout-description'>
                      <div>
                        <label style={{color:'#0B4266'}}>Description</label>
                      </div>
                      <textarea
                        value={addTask.description}
                        onChange={(e) => handleInputChange('description', e.target.value)}
                        className='description-input'
                        style={{width:'230%'}}
                      />
                    </div>
                  </div>
                </div>
                <div className='chart-container' style={{ marginLeft: "150px",width:'750px'}}>
                  {/* <img
                  src={asset}
                  alt="..."
                  style={{ marginLeft: "auto",width:'750px', height:'200px'}}
                  /> */}
                  <Chart
                      options={pieChartDataInForm.options}
                      series={pieChartDataInForm.series}
                      type="pie"
                      width="380"
      
                      
                  />

                </div>
              </div>
            </div>
            <div className='button' style={{marginBottom:'10px'}}>
              <Button  id='cancel-addtask' onClick={handleClearSubmit} style={{width:'7%'}}>
                Clear
              </Button>
              {isEdited ? (
              <Button id={addTask.totalHours? 'submit-addtask-active':'submit-addtask'} onClick={handleFormSubmit}>
                Save
              </Button>
            ):(
              <Button  id={addTask.totalHours? 'submit-addtask-active':'submit-addtask'} onClick={handleFormSubmit}>
                Add Task
              </Button>
            )}
            </div>

        </form>):null}
        <>
        <div>
          <div style={{ display:'flex', justifyContent:'space-between', margin:'10px 20px' }}>
            <div style={{display:'flex'}}>
              <Button id='submit-less' onClick={handleLeftArrowClick}> 
                      <LeftOutlined />
                  </Button>
                  {/* <select 
                      id='submit' 
                      style={{ appearance: 'none', WebkitAppearance: 'none', MozAppearance: 'none' }} 
                      onChange={(e) => handleFilterChange(e.target.value)} value={filterOption}
                  >
                      <option style={{textAlign:'center'}} value='Date'>Date</option>
                      <option style={{textAlign:'center'}} value='Week'>Week</option>
                      <option style={{textAlign:'center'}} value='Month'>Month</option>
                  </select> */}
                  <Button id='submit-less' onClick={handleRightArrowClick}>
                      <RightOutlined />
                  </Button>

            </div>
            
            {/* <Input
            className="search-addtask"
            placeholder="Search by Date"
            allowClear
            suffix={<SearchOutlined style={{ color: "#04172480" }} />}
            onChange={(e) => {
            //  console.log("Search input value:", e.target.value);
              setSearchInput(e.target.value);
            }}
          /> */}
         
          <div style={{display:'flex', justifyContent:'flex-end'}}>
          {/* <button type='button' id='submit-less' onClick={handleLeftArrowClick}>
            <LeftOutlined />
          </button> */}

        {/* <Select
           
            style={{
              marginTop: '10px',
              display: 'flex',
              padding: '0.5em 2em',
              border: 'transparent',
              boxShadow: '2px 2px 4px rgba(0,0,0,0.4)',
              justifyContent: 'center',
              alignItems: 'center',
              gap: '10px',
              borderRadius: '4px',
              color:'white',
              background: '#0B4266',
              cursor: 'pointer',
              appearance: 'none',
              WebkitAppearance: 'none',
              MozAppearance: 'none',
            }}
            defaultValue="Date"
            onChange={handleFilterChange}
        >
          <Select.Option value="Date">Date</Select.Option>
          <Select.Option value="Week">Week</Select.Option>
          <Select.Option value="Month">Month</Select.Option>
        </Select> */}
        <Button
              id='submit-addtask-active'
              style={{marginRight:'10px'}}
              onClick={handleRequestForm}
            >
              Request
        </Button>
        {!cancelButton && !(filterOption === 'Date' && !isFormEnabled) && (
            <Button
              id='cancel-new'
              onClick={handleToggleForm}
              disabled={isFormEnabled} // Disable the button when the form is enabled
            >
              Add Task
            </Button>
          )}
          <Select 
                    id='submit' 
                    style={{color:'white', appearance: 'none', WebkitAppearance: 'none', MozAppearance: 'none', marginTop:'10px', height:'95%', width:'120px' }} 
                    onChange={(value) => handleFilterChange(value)} 
                    value={filterOption}
                    dropdownStyle={{ textAlign: 'center' }} // Style the dropdown menu
                >
                    <Option value='Date'>Date</Option>
                    <Option value='Week'>Week</Option>
                    <Option value='Month'>Month</Option>
                </Select>
          {/* <button type='button' id='submit-less' onClick={handleRightArrowClick}>
            <RightOutlined />
          </button> */}
          </div>
        </div>
      </div>
        <Table
            style={{fontSize:'12px', fontFamily:'poppins', fontWeight:'normal', color: '#0B4266'}}
            className='addtask-table'
            columns={columns}
            dataSource={filteredTasks}
            pagination={false}
          />
            <Button id='submit-overall' onClick={handleOverallSubmit}>
              Submit
            </Button>
        </>
      </div>
    </DashboardLayout>
  );
};
export default AddTask;

AddTask.tsx (with date modification)

import React, { useState, useEffect, useCallback, ChangeEvent } from 'react';
import { Input, TimePicker, Select, notification, DatePicker, Button} from 'antd';
import { SearchOutlined } from '@mui/icons-material';
import dayjs from 'dayjs';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { useMsal } from '@azure/msal-react';
import '../Styles/CreateUser.css';
import DashboardLayout from './Layout';
import Chart from 'react-apexcharts';
import '../Styles/AddTask.css';
import {Table} from 'antd';
import { ColumnsType } from "antd/es/table";
import ApprovalRequest from './ApprovalRequest';
import { EditOutlined, DeleteOutlined,CloseCircleOutlined,LeftOutlined, RightOutlined } from '@ant-design/icons';
import Dashboard from './Dashboard';
import {Modal} from 'antd';
import { RecentRejected, SelectedKeys, RejectedKeys } from './MonthTasks';
import asset from '../../assets/images/asset.svg';
import { last } from 'pdf-lib';
export interface DateTask{
  key: string;
  task: Task[];
}

export interface RequestedOn {
  [key: string]: string[]; // Each key represents a month (e.g., "February 2024") with an array of dates
}

export interface TaskRequestedOn {
  [userId: string]: RequestedOn; // Each key represents a month (e.g., "February 2024") with an array of dates
}


export interface Task {
  key?:string;
  idx: number; // Add this line
  date: string;
  userId: string;
  task: string;
  title: string;
  startTime: string;
  endTime: string;
  totalHours: string;
  description: string;
  reportingTo: string;
  slNo?: number;
}

interface PieChartData {
  options: {
    labels: string[];
  };
  series: number[];
}

type AddTaskProps = {
  setPieChartData: React.Dispatch<React.SetStateAction<{ [key: string]: number }>>;
  setApprovalRequestsData: React.Dispatch<React.SetStateAction<Task[]>>;
  approvalRequestsData: Task[];
};

const AddTask: React.FC<AddTaskProps> = ({ setPieChartData, setApprovalRequestsData }) => {
  const userId = '1234';
  const { Option } = Select; // Destructure the Option component from Select
  const navigate = useNavigate();
  const {confirm}= Modal;
  const location = useLocation();
  const { formattedDate } = location.state || { formattedDate: dayjs() }; // Access formattedDate from location.state
  const [deletedTask, setDeletedTask] = useState(false);
  const [formWidth, setFormWidth] = useState(800);
  const [currentDate, setCurrentDate] = useState(dayjs(formattedDate));
  const [currentWeek, setCurrentWeek] = useState(dayjs().startOf('week'));
  const [currentMonth, setCurrentMonth] = useState(dayjs().startOf('month'));
  const [isFormEnabled, setIsFormEnabled] = useState(false);
  const [cancelButton, setCancelButton] = useState(false);
  const [addTask, setAddTask] = useState<Task>({
    idx: 1, // Set initial idx
    date: currentDate.format('YYYY-MM-DD'),
    userId: userId,
    task: '',
    title: '',
    startTime: '',
    endTime: '',
    totalHours: '',
    description: '',
    reportingTo: '',
  });
  const [deletedTaskIdx, setDeletedTaskIdx] = useState<number | null>(null);
  const [taskList, setTaskList] = useState<Task[]>([]);
  const [filteredTasks, setFilteredTasks] = useState<Task[]>([]);
  const reportingOptions = ['ManagerA', 'ManagerB', 'ManagerC'];
  const taskOptions = ['Task','Project','Learning','Training','Meeting'];
  const [filterOption, setFilterOption] = useState('Date');
  const [isEdited, setIsEdited]= useState<boolean>(false);
  // State to manage the search input
  const [searchInput, setSearchInput] = useState('');
  const [isFormSubmitted, setIsFormSubmitted] = useState(false);
  const [selectedKeysToHide, setSelectedKeysToHide]=useState<string[]>([]);
  const [pieChartDataInForm, setPieChartDataInForm] = useState<PieChartData>({ options: { labels: [] }, series: [] });

 const updateSlNo = (tasks: Task[], deleteTask: boolean): Task[] => {
  return tasks.map((task, index) => ({
    ...task,
    slNo: index + 1,
    idx: deleteTask ? index + 1 : task.idx
  }));
};
const projectTitle = ['Project','TMS', 'LMS','SAASPE', 'Timesheet'];
const meetingTitle = ['Meeting', 'TMS', 'LMS','SAASPE', 'Timesheet', 'HR-Meet', 'Others'];
  useEffect(() => {
    const updateFormWidth = () => {
      const formElement = document.getElementById('myForm');
      if (formElement) {
        const newWidth = formElement.offsetWidth;
        setFormWidth(newWidth);
      }
    };

    window.addEventListener('resize', updateFormWidth);
    updateFormWidth();

    return () => {
      window.removeEventListener('resize', updateFormWidth);
    };
  }, []);

  const borderStyle = {
    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)', // Add box shadow
    margin: '10px 20px',
   // padding: '10px 20px',
    //width: formWidth + 'px',
    width: '1350px',
    height:'540px'
  };

  useEffect(() => {
    const storedKeysString: string | null = localStorage.getItem('selectedKeys');
    if (storedKeysString !== null) {
        const storedKeys: SelectedKeys = JSON.parse(storedKeysString);
        if (storedKeys.hasOwnProperty(userId)) {
            setSelectedKeysToHide(storedKeys[userId]);
        } else {
            console.log("User ID not found in stored keys");
        }
    } else {
        console.log("else-useEffect", storedKeysString);
    }
}, []);

useEffect(() => {
  // Calculate data for the pie chart
  const taskCounts: { [key: string]: number } = {};
  filteredTasks.forEach(task => {
      taskCounts[task.task] = (taskCounts[task.task] || 0) + 1;
  });

  const labels = Object.keys(taskCounts);
  const data = Object.values(taskCounts);

  // Update pie chart data
  setPieChartDataInForm({
      options: {
          labels: labels,
      },
      series: data,
  });
}, [filteredTasks]);

  
  const handleInputChange = (field: keyof Task, value: string) => {
    if (field === 'date') {
      const selectedDate = dayjs(value);
      if (selectedDate.isAfter(dayjs(), 'day')) {
        // Display a notification
        notification.warning({
          message: 'Warning',
          description: 'Cannot select a future date.',
        });
        // Set the selected date to today
        setCurrentDate(dayjs());
      } else {
        // Update the state with the selected date
        setCurrentDate(selectedDate);
      }
    }
  
    // Keep userId constant
    if (field === 'userId') {
      setAddTask((prevTask) => ({ ...prevTask, [field]: value }));
    } else {
      // Update startTime or endTime with the new value
      const updatedTime = value || dayjs().format('hh:mm A');
      setAddTask((prevTask) => ({ ...prevTask, [field]: updatedTime }));
      // Calculate the duration and update totalHours
      const updatedStartTime = field === 'startTime' ? updatedTime : addTask.startTime || dayjs().format('hh:mm A');
      const updatedEndTime = field === 'endTime' ? updatedTime : addTask.endTime || dayjs().format('hh:mm A');
      const duration = dayjs(updatedEndTime, 'hh:mm A').diff(dayjs(updatedStartTime, 'hh:mm A'), 'hour', true);
      setAddTask((prevTask) => ({
        ...prevTask,
        startTime: field === 'startTime' ? updatedTime : addTask.startTime,
        endTime: field === 'endTime' ? updatedTime : addTask.endTime,
        totalHours: duration.toFixed(2),
      }));
    }
  };
  
  useEffect(() => {
    const storedTaskListString = localStorage.getItem('taskList');
    const storedTaskList = storedTaskListString ? JSON.parse(storedTaskListString) : [];

    // Filter tasks based on the userId
    //const userTaskList = storedTaskList.filter((task:Task)=> task.userId === userId);

    // Assuming deletedTask is a state variable
    const updatedTaskList = updateSlNo(storedTaskList, deletedTask);

    setTaskList(updatedTaskList);
    setFilteredTasks(updatedTaskList);
  }, [deletedTask]); // Include deletedTask in the dependency array

  useEffect(() => {
    // Filter tasks based on the addTask.date and userId when it changes
    if (addTask.date) {
        const filtered = taskList.filter(task => task.date === addTask.date && task.userId === userId);
        setFilteredTasks(updateSlNo(filtered, deletedTask)); // Update slNo when loading tasks
    } else {
        // If no date is selected, display all tasks
        setFilteredTasks(updateSlNo(taskList, deletedTask)); // Update slNo when loading tasks
    }
}, [addTask.date, taskList]);


  useEffect(() => {
    // Update addTask with the current date
    if (!isEdited) {
      // Update addTask with the current date only when not in edit mode
      setAddTask((prevAddTask) => ({
        ...prevAddTask,
        date: dayjs(currentDate).format('YYYY-MM-DD'),
    }));
  }
    //setFilteredTasks(taskList);
    // Filter tasks based on the filterOption and currentDate when they change
    let filtered: Task[] = [];

    if (searchInput) {
      // If there is a search input, filter tasks based on date or month
      const searchDate = dayjs(searchInput);
      filtered = taskList.filter((task) => {
          if (filterOption === 'Date') {
            return ((dayjs(task.date).isSame(searchDate, 'day'))&&(task.userId===userId));
            } else if (filterOption === 'Week') {
              const startOfWeek = currentWeek.startOf('week');
              const endOfWeek = currentWeek.endOf('week');
              return (
                (dayjs(task.date).isSame(startOfWeek) || dayjs(task.date).isAfter(startOfWeek)) &&
                (dayjs(task.date).isSame(endOfWeek) || dayjs(task.date).isBefore(endOfWeek)) &&
                task.userId===userId
              );
            } else if (filterOption === 'Month') {
              // Format the searchInput in the same way as the task date
              const formattedSearchMonth = searchDate.format('MMMM');
              return ((dayjs(task.date).format('MMMM') === formattedSearchMonth) && (task.userId===userId));
            }
        return false;
      });
    }  else {
      // If no search input, apply the regular filtering based on filterOption and currentDate
      if (filterOption === 'Date') {
        filtered = taskList.filter((task) => 
          task.date === dayjs(currentDate).format('YYYY-MM-DD') && task.userId===userId);
        console.log("useEffect-date", filtered)
      } else if (filterOption === 'Week') {
        const startOfWeek = currentWeek.startOf('week');
        const endOfWeek = currentWeek.endOf('week');
        filtered = taskList.filter(
          (task) =>
            (dayjs(task.date).isSame(startOfWeek) || dayjs(task.date).isAfter(startOfWeek)) &&
            (dayjs(task.date).isSame(endOfWeek) || dayjs(task.date).isBefore(endOfWeek)) &&
            task.userId ===userId
        );
        console.log("useeffect-week", filtered);
      } else if (filterOption === 'Month') {
        const startOfMonth = currentMonth.startOf('month');
        const endOfMonth = currentMonth.endOf('month');
        filtered = taskList.filter(
          (task) =>
            (dayjs(task.date).isSame(startOfMonth) || dayjs(task.date).isAfter(startOfMonth)) &&
            (dayjs(task.date).isSame(endOfMonth) || dayjs(task.date).isBefore(endOfMonth)) && 
            (task.userId === userId)
        );
        console.log("useeffect", filtered);
      }
    }

    setFilteredTasks(updateSlNo(filtered, deletedTask));
  //  console.log("useeffect filtered-task", filteredTasks);
  }, [isEdited, filterOption, currentDate, currentMonth, currentWeek, taskList, searchInput]);

  const handleFilterChange = (value: any) => {
    setFilterOption(value);
  };

  const handleLeftArrowClick = () => {
    if (filterOption === 'Date') {
      console.log("handleLeftArrowClick -prev", currentDate);
      const previousDate = currentDate.subtract(1, 'day');
      console.log("handleLeftArrowClick previousDate",previousDate)
      setCurrentDate(previousDate);

    } else if (filterOption === 'Week') {
      const previousWeekStart = currentWeek.subtract(1, 'week').startOf('week');
      const previousWeekEnd = currentWeek.subtract(1, 'week').endOf('week');
      setCurrentWeek(previousWeekStart);
      console.log("previousWeek",previousWeekStart)
    } else if (filterOption === 'Month') {
      const previousMonthStart = currentMonth.subtract(1, 'month').startOf('month');
      const previousMonthEnd = currentMonth.subtract(1, 'month').endOf('month');
      setCurrentMonth(previousMonthStart);
    }
  };

  const handleRightArrowClick = () => {
    if (filterOption === 'Date') {
      const nextDate = currentDate.add(1, 'day');
      if(nextDate.isAfter(dayjs(), 'day')){
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future weeks.',
        });
        return;
      }
      setCurrentDate(nextDate);
    } else if (filterOption === 'Week') {
      const nextWeekStart = currentWeek.add(1, 'week').startOf('week');
      const nextWeekEnd = currentWeek.add(1, 'week').endOf('week');
      if (nextWeekStart.isAfter(dayjs(), 'day')) {
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future weeks.',
        });
        return;
      }
      setCurrentWeek(nextWeekStart);
      
    } else if (filterOption === 'Month') {
      const nextMonthStart = currentMonth.add(1, 'month').startOf('month');
      if (nextMonthStart.isAfter(dayjs(), 'day')) {
        notification.warning({
          message: 'Warning',
          description: 'Cannot navigate to future months.',
        });
        return;
      }
      setCurrentMonth(nextMonthStart);
    }
    
  };

  const handleToggleForm = () => {
    setIsFormEnabled((prevIsFormEnabled) => !prevIsFormEnabled);
    setCancelButton((prevIsFormEnabled) => !prevIsFormEnabled);
    // If you want to reset the form when disabling it, you can reset the form state here
    if (!isFormEnabled) {
      setAddTask({
        date: dayjs(currentDate).format('YYYY-MM-DD'),
        userId:userId,
        task: '',
        title:'',
        startTime: '',
        endTime: '',
        totalHours:'',
        description: '',
        reportingTo: '',
        idx: addTask.idx,
      });
    }
  };

  const handleFormSubmit = () => {
    const userId = addTask.userId;

    // Check if the addTask date is included in selectedKeysToHide
    if (selectedKeysToHide.includes(addTask.date)) {
      notification.warning({
          message: 'Restricted',
          description: `The Task Approved: ${addTask.date} & Restrict to Add New Task`,
      });
      return;
  }

  const taskRequestedOn = localStorage.getItem('taskRequestedOn');
  const approvedRequestedOnString = localStorage.getItem('approveTaskRequestedOn');
const approvedRequestedOn: TaskRequestedOn = approvedRequestedOnString ? JSON.parse(approvedRequestedOnString) : {};
console.log("approvedRequestedOn", approvedRequestedOn);  
    // Check if the date is not in the taskList and it's before the currentDate
    // const currentDateFormatted = dayjs().format('YYYY-MM-DD');
    // if (
    //     (!taskList.find(task => (task.userId===addTask.userId) && (task.date === addTask.date)) && dayjs(addTask.date).isBefore(currentDateFormatted))
    // ) {
    //     notification.warning({
    //         message: 'Restricted',
    //         description: 'Cannot add task for a date before the current date and not present in the task list.',
    //     });
    //     return;
    // }

    const currentDateFormatted = dayjs().format('YYYY-MM-DD');
    // Check if the date is not present in the approvedRequestedOn and satisfies the condition
    console.log("approvedRequestedOn", approvedRequestedOn[userId][dayjs(addTask?.date).format('YYYY-MM')]?.includes(addTask.date));
    if (
      (!approvedRequestedOn[userId]?.[dayjs(addTask?.date).format('YYYY-MM')]?.includes(addTask.date)) &&
      (!taskList.find(task => task.userId === addTask.userId && task.date === addTask.date) &&
      dayjs(addTask.date).isBefore(currentDateFormatted))
  ) {
      notification.warning({
          message: 'Restricted',
          description: 'Cannot add task for a date before the current date and not present in the task list.',
      });
      return;
  }
  
  

    // Check for overlapping tasks in the specified time range
    const overlappingTask = taskList.find(task => {
      if(task.userId !== addTask.userId) return false;
      const newTaskStartTime = dayjs(addTask.startTime, 'hh:mm A');
      const newTaskEndTime = dayjs(addTask.endTime, 'hh:mm A');
      const taskStartTime = dayjs(task.startTime, 'hh:mm A');
      const taskEndTime = dayjs(task.endTime, 'hh:mm A');
    
      // Check if the new task overlaps with any existing task
      return (
        !isEdited && task.date === addTask.date &&
        (
          ((newTaskStartTime.isSame(taskStartTime) || newTaskStartTime.isAfter(taskStartTime)) && newTaskStartTime.isBefore(taskEndTime)) ||
          ((newTaskEndTime.isSame(taskStartTime) || newTaskEndTime.isAfter(taskStartTime)) && newTaskEndTime.isBefore(taskEndTime)) ||
          (newTaskStartTime.isBefore(taskStartTime) && (newTaskEndTime.isSame(taskEndTime) || newTaskEndTime.isAfter(taskEndTime)))
        )
      );
    });
      
    if (overlappingTask) {
      notification.warning({
        message: 'Restricted',
        description: 'Task already exists in the specified time range.',
      });
      return;
    }

    if (isEdited) {
      // If editing, update the existing task
      const updatedTaskList = taskList.map(task =>
        (task.idx === addTask.idx) && (task.userId === addTask.userId)
         ? { ...addTask } : task
      );
      setTaskList(updatedTaskList);
      setFilteredTasks(updateSlNo(updatedTaskList, deletedTask));
      localStorage.setItem('taskList', JSON.stringify(updatedTaskList));
      setIsEdited(false);
    } else {
      // Update the taskList
      const updatedTaskList = [
        ...taskList,
        { ...addTask, idx: taskList.length + 1 }
      ];
      setTaskList(updatedTaskList);
      setFilteredTasks(updateSlNo(updatedTaskList, deletedTask));
      localStorage.setItem('taskList', JSON.stringify(updatedTaskList));
    }

    // After successful submission, remove the date from approvedRequestedOn
  // if (approvedRequestedOn[userId]?.[dayjs(addTask?.date).format('YYYY-MM')]?.includes(addTask.date)) {
  //   const updatedApprovedRequestedOn = { ...approvedRequestedOn };
  //   const index = updatedApprovedRequestedOn[userId][dayjs(addTask?.date).format('YYYY-MM')].indexOf(addTask.date);
  //   updatedApprovedRequestedOn[userId][dayjs(addTask?.date).format('YYYY-MM')].splice(index, 1);
  //   localStorage.setItem('approveTaskRequestedOn', JSON.stringify(updatedApprovedRequestedOn));
  // }
  
    // Clear the form with the default date and reset idx
    setAddTask({
      idx: taskList.length + 2, // Set a new idx
      date: dayjs(currentDate).format('YYYY-MM-DD'),
      userId: userId,
      task: '',
      title:'',
      startTime: '',
      endTime: '',
      totalHours: '',
      description: '',
      reportingTo: '',
    });
    setIsEdited(false);
    setIsFormSubmitted(true);
};

useEffect(() => {
  handleRequestForm();
}, [currentDate, currentWeek, currentMonth]);



const handleRequestForm = () => {
  const userId = addTask.userId;
  const month = dayjs(addTask.date).format('YYYY-MM');
  const currentDateFormatted = dayjs().format('YYYY-MM-DD');
  console.log("handleRequestForm userId month",userId, month)
  // Load existing taskRequestedOn from localStorage
  const taskRequestedOn: TaskRequestedOn = JSON.parse(localStorage.getItem('taskRequestedOn') || '{}');
  // Load existing approvedRequestedOn from localStorage
  const approvedRequestedOn: TaskRequestedOn = JSON.parse(localStorage.getItem('approveRequestedOn') || '{}');
  console.log("handleRequestForm taskRequestedOn",taskRequestedOn)
  console.log("handleRequestForm approvedRequestedOn",approvedRequestedOn)
  // Ensure taskRequestedOn structure is initialized for the user and month
  if (!taskRequestedOn[userId]) {
    taskRequestedOn[userId] = {};
  }
  if (!taskRequestedOn[userId][month]) {
    taskRequestedOn[userId][month] = [];
  }

  // Ensure approvedRequestedOn structure is initialized for the user and month
  if (!approvedRequestedOn[userId]) {
    approvedRequestedOn[userId] = {};
  }
  if (!approvedRequestedOn[userId][month]) {
    approvedRequestedOn[userId][month] = [];
  }

  // Iterate through dates based on filter option
  let startOfRange, endOfRange;
  if (filterOption === 'Month') {
    startOfRange = dayjs(addTask.date).startOf('month');
    endOfRange = dayjs(addTask.date).endOf('month');
  } else if (filterOption === 'Week') {
    startOfRange = dayjs(addTask.date).startOf('week');
    endOfRange = dayjs(addTask.date).endOf('week');
  } else if (filterOption === 'Date') {
    startOfRange = dayjs(addTask.date);
    endOfRange = dayjs(addTask.date);
  }
  console.log("handleRequestForm startOfRange endOfRange" ,startOfRange, endOfRange)
  let currentDate = startOfRange;
  while ((currentDate?.isSame(endOfRange, 'day') || currentDate?.isBefore(endOfRange,'day'))&& (currentDate?.isSame(dayjs(), 'day')|| currentDate?.isBefore(dayjs(),'day'))) {
    const currentDateFormatted = currentDate.format('YYYY-MM-DD');
    // Check if date is not in taskList and not in approvedRequestedOn
    if (!taskList.some(task => task.userId === userId && task.date === currentDateFormatted) &&
        (!approvedRequestedOn[userId]?.[month]?.includes(currentDateFormatted))) {
      // Add date to taskRequestedOn if not already present
      if (!taskRequestedOn[userId][month].includes(currentDateFormatted)) {
        taskRequestedOn[userId][month].push(currentDateFormatted);
      }
    }
    currentDate = currentDate.add(1, 'day');
  }
  console.log("handleRequestForm taskRequestedOn-final",taskRequestedOn)
  // Update taskRequestedOn in localStorage
  localStorage.setItem('taskRequestedOn', JSON.stringify(taskRequestedOn));
};



  const handleClearSubmit = () => {
    // Clear the form with the default date and set idx
    setAddTask({
      date: dayjs(addTask.date).format('YYYY-MM-DD'),
      userId: userId,
      task: '',
      title:'',
      startTime: '',
      endTime: '',
      totalHours:'',
      description: '',
      reportingTo: '',
      idx: addTask.idx 
    });
  }
  
//   const handleEditTask = (idx: number) => {
//     const taskToEdit = taskList.find((task) => task.idx === idx);
//     const isExistingTask = taskToEdit !== undefined; // Check if taskToEdit is defined
//     // if (taskToEdit) {
//         // const isDateSelected = selectedKeysToHide.includes(taskToEdit.date);
        
//     //     // if (isDateSelected && isExistingTask) {
//     //     //     // Date is selected and it's an existing task, so prevent further action
//     //     //     // You can display a message or handle this case according to your application's logic
//     //     //     return;
//     //     // }

//     //     // setIsEdited(true);
//     //     // setAddTask({
//     //     //     date: taskToEdit.date,
//     //     //     userId: taskToEdit.userId,
//     //     //     task: taskToEdit.task,
//     //     //     startTime: taskToEdit.startTime,
//     //     //     endTime: taskToEdit.endTime,
//     //     //     totalHours: taskToEdit.totalHours,
//     //     //     description: taskToEdit.description,
//     //     //     reportingTo: taskToEdit.reportingTo,
//     //     //     idx: taskToEdit.idx, 
//     //     // });

//     //     // // Now, you can perform additional actions or display a modal for editing
//     //     // setCurrentDate(dayjs(taskToEdit.date));

//     // }

//     if (taskToEdit) {
//       const isDateSelected = selectedKeysToHide.includes(taskToEdit.date);

//       if (isDateSelected && taskToEdit.isNew) {
//           // If the task is newly added and its date is selected, allow editing
//           setIsEdited(true);
//           setAddTask({ ...taskToEdit });
//           setCurrentDate(dayjs(taskToEdit.date));
//       } else if (!isDateSelected) {
//           // If the date is not selected, allow editing
//           setIsEdited(true);
//           setAddTask({ ...taskToEdit });
//           setCurrentDate(dayjs(taskToEdit.date));
//       } else {
//           // Date is selected and it's an existing task, so prevent further action
//           // You can display a message or handle this case according to your application's logic
//           return;
//       }
//   } else {
//       // Handle the case where taskToEdit is undefined
//       // You can display a message or handle this case according to your application's logic
//       return;
//   }
// };

const handleEditTask = (idx: number) => {
  const taskToEdit = taskList.find((task) => (task.idx === idx) && (task.userId === addTask.userId));
  if (taskToEdit) {
    // Check if the date is included in selectedKeysToHide
    if (selectedKeysToHide.includes(taskToEdit.date)) {
      // Date is included in selectedKeysToHide, so prevent further action
      // You can display a message or handle this case according to your application's logic
      return;
    }

    setIsEdited(true);
  
    setAddTask({
        date: taskToEdit.date,
        userId: taskToEdit.userId,
        task: taskToEdit.task,
        title:taskToEdit.title,
        startTime: taskToEdit.startTime,
        endTime: taskToEdit.endTime,
        totalHours: taskToEdit.totalHours,
        description: taskToEdit.description,
        reportingTo: taskToEdit.reportingTo,
        idx: taskToEdit.idx, 
    });

    // Now, you can perform additional actions or display a modal for editing
    setCurrentDate(dayjs(taskToEdit.date));
  }
};

const handleDeleteTask = useCallback((idx: number) => {
  const taskToDelete = taskList.find(task => (task.idx === idx));  //&&(task.userId === addTask.userId)
  
  if (!taskToDelete || selectedKeysToHide.includes(taskToDelete.date)) {
    // Task not found or its date is in selectedKeysToHide, do not delete
    return;
  }

  // Display confirmation modal before deleting the task
  confirm({
    title: 'Delete Task',
    content: 'Are you sure you want to delete the task?',
    okText: 'Yes',
    okButtonProps: {
      style: {
        width: '80px', backgroundColor: '#0B4266', color: 'white'
      },
    },
    cancelText: 'No',
    cancelButtonProps: {
      style: {
        width: '80px', backgroundColor: '#0B4266', color: 'white'
      },
    },
    onOk() {
      // Logic to delete the task if user confirms
      const updatedTaskList = taskList.filter(task => (task.idx !== idx)); //&&(task.userId==addTask.userId)
  
      // Reindex the idx starting from 1
      const reindexedTaskList = updateSlNo(updatedTaskList, true);
  
      setTaskList(reindexedTaskList);
      setFilteredTasks(reindexedTaskList);
  
      // Update localStorage
      localStorage.setItem('taskList', JSON.stringify(reindexedTaskList));
    },
    onCancel() {
      // Logic if user cancels deletion
    },
  });
}, [taskList, selectedKeysToHide]);


// const handleDeleteTask = useCallback((idx: number) => {
//   // Check if the date is included in selectedKeysToHide
//   const isDateIncluded = selectedKeysToHide.some(date => {
//       // Assuming taskList contains tasks with a 'date' property
//       const task = taskList.find(task => task.idx === idx);
//       return task && task.date === date;
//   });

//   // Toggle the deletedTask flag based on the presence of the date in selectedKeysToHide
//   setDeletedTask(!isDateIncluded);

//   // Save idx in state
//   setDeletedTaskIdx(idx);
// }, [selectedKeysToHide, taskList]);


//   useEffect(() => {
//     if (deletedTask) {
//       // Implement the logic to delete the task based on idx
//       const updatedTaskList = taskList.filter(task => {
//         // Check if the task date is not included in selectedKeysToHide and isNew is true
//         return !selectedKeysToHide.includes(task.date);
//       });
  
//       // Reindex the idx starting from 1 and use deletedTask flag
//       const reindexedTaskList = updateSlNo(updatedTaskList, deletedTask);
  
//       setTaskList(reindexedTaskList);
//       setFilteredTasks(reindexedTaskList);
  
//       // Update localStorage
//       localStorage.setItem('taskList', JSON.stringify(reindexedTaskList));
  
//       // Reset the deletedTask flag after updating
//       setDeletedTask(false);
//     }
//   }, [deletedTask, deletedTaskIdx, selectedKeysToHide, taskList]);

  // const handleDeleteTask = useCallback((idx: number) => {
  //   // Display confirmation modal before deleting the task
  //   confirm({
  //     title: 'Delete Task',
  //     content: 'Are you sure you want to delete the task?',
  //     okText: 'Yes',
  //     okButtonProps: {
  //       style: {
  //         width: '80px', backgroundColor: '#0B4266', color: 'white'
  //       },
  //     },
  //     cancelText: 'No',
  //     cancelButtonProps: {
  //       style: {
  //         width: '80px', backgroundColor: '#0B4266', color: 'white'
  //       },
  //     },
  //     onOk() {
  //       // Logic to delete the task if user confirms
  //       const updatedTaskList = taskList.filter(task => task.idx !== idx);
    
  //       // Reindex the idx starting from 1
  //       const reindexedTaskList = updateSlNo(updatedTaskList);
    
  //       setTaskList(reindexedTaskList);
  //       setFilteredTasks(reindexedTaskList);
    
  //       // Update localStorage
  //       localStorage.setItem('taskList', JSON.stringify(reindexedTaskList));
  //     },
  //     onCancel() {
  //       // Logic if user cancels deletion
  //     },
  //   });
  // }, [taskList]);

  
  
  // const handleOverallSubmit = () => {
  //   // Assuming you have an API endpoint for approval requests
  //   //const apiUrl = 'http://localhost:3000/approvalrequests';

  //   // Prepare the data to be sent
  //   const requestData = filteredTasks.map(task => ({
  //     date: task.date,
  //     userId: task.userId,
  //     task: task.task,
  //     startTime: task.startTime,
  //     endTime: task.endTime,
  //     totalHours: task.totalHours,
  //     description: task.description,
  //     reportingTo: task.reportingTo,
  //     idx: task.idx,
  //   }));
  //   // Navigate to the approvalrequests component with the data
  //   navigate('/approvalrequests', { state: { requestData } });
  //   // Make the HTTP POST request to the /approvalrequests endpoint
  //   // fetch(apiUrl, {
  //   //   method: 'POST',
  //   //   headers: {
  //   //     'Content-Type': 'application/json',
  //   //   },
  //   //   body: JSON.stringify(requestData),
  //   // })
  //   //   .then(response => {
  //   //     if (!response.ok) {
  //   //       console.log("network response was not okay");
  //   //       throw new Error('Network response was not ok');
          
  //   //     }
  //   //     return response.json();
  //   //   })
  //   //   .then(data => {
  //   //     // Handle the success response from the server
  //   //     console.log('Submission successful:', data);
  //   //     // You may want to show a success message or redirect the user
  //   //     // Show success notification
  //   //     notification.success({
  //   //       message: 'Submission Successful',
  //   //       description: 'Task details submitted successfully!',
  //   //     });
  //   //   })
  //   //   .catch(error => {
  //   //     // Handle errors during the fetch
  //   //     console.error('Error during submission:', error);
  //   //     // Show error notification
  //   //     notification.error({
  //   //       message: 'Submission Failed',
  //   //       description: 'There was an error submitting the task details.',
  //   //     });
  //   //     // You may want to show an error message to the user
  //   //   });
  // };

//   const handleOverallSubmit = () => {
//     // Prepare the data to be sent
//     const requestData: Task[] = filteredTasks.map(task => ({
//         date: task.date,
//         userId: task.userId,
//         task: task.task,
//         startTime: task.startTime,
//         endTime: task.endTime,
//         totalHours: task.totalHours,
//         description: task.description,
//         reportingTo: task.reportingTo,
//         idx: task.idx,
//     }));

//     // Set the success notification
//     notification.success({
//         message: 'Submission Successful',
//         description: 'Task details submitted successfully!',
//     });
//     navigate('/approvalrequests')
//     // Set the approvalRequestsData state
//     console.log("handleOverAllsubmit", requestData);
//     setApprovalRequestsData(requestData);
//     localStorage.setItem('requestedOn', addTask.date);
//     // Store the approvalRequestsData in local storage
//     localStorage.setItem('approvalRequestsData', JSON.stringify(requestData));

//     // Retrieve rejectedKeys from local storage
//     const rejectedKeysString = localStorage.getItem('rejectedKeys');
//     console.log("rejectedKeysString",rejectedKeysString);
//     if (rejectedKeysString) {
//       let parsedRejectedKeys: RecentRejected[] = JSON.parse(rejectedKeysString);
//       console.log("rejectedKeys", parsedRejectedKeys);
//       // Check if 'submit' exists in rejectedKeys
//       const date = requestData.length > 0 ? requestData[0].date : '';
//       if (parsedRejectedKeys.some((key) => key.date === date)) {
//         // Remove 'date' from rejectedKeys
//         const updatedRejectedKeys = parsedRejectedKeys.filter((key) => key.date !== date);

//         // Update rejectedKeys in local storage
//         localStorage.setItem('rejectedKeys', JSON.stringify(updatedRejectedKeys));
//     }
//     }
// };



const handleOverallSubmit = () => {

  // Filter tasks where userId matches addTask.userId
  const tasksToSend: Task[] = filteredTasks.filter(task => task.userId === addTask.userId);
    // Prepare the data to be sent
    const requestData: Task[] = tasksToSend.map(task => ({
        date: task.date,
        userId: task.userId,
        task: task.task,
        title:task.title,
        startTime: task.startTime,
        endTime: task.endTime,
        totalHours: task.totalHours,
        description: task.description,
        reportingTo: task.reportingTo,
        idx: task.idx,
    }));

    // Group tasks by date
    const groupedTasks: { [date: string]: Task[] } = {};
    requestData.forEach(task => {
        if (groupedTasks.hasOwnProperty(task.date)) {
            groupedTasks[task.date].push(task);
        } else {
            groupedTasks[task.date] = [task];
        }
    });

        // Determine the key based on the filterOption
    let key: string;
    if (filterOption === "Date") {
        key = currentDate.format("MMMM YYYY"); // Format Dayjs object to "February 2024"
    } else if (filterOption === 'Week') {
        key = currentWeek.startOf('week').format("MMMM YYYY"); // Format Dayjs object to "February 2024"
    } else {
        key = currentMonth.startOf('month').format("MMMM YYYY"); // Format Dayjs object to "February 2024"
    }

    let date: string[] = [];
    if (filterOption === "Date") {
        date.push(currentDate.format('YYYY-MM-DD')); // Format Dayjs object to "February 2024"
    } else if (filterOption === 'Week') {
        const fromDate = currentWeek.startOf('week').format("YYYY-MM-DD"); // Format Dayjs object to "February 2024"
        const toDate = currentWeek.endOf('week').format("YYYY-MM-DD");
        date.push(fromDate);
        date.push(toDate);
    } else {
        const fromDate = currentMonth.startOf('month').format("YYYY-MM-DD"); // Format Dayjs object to "February 2024"
        const toDate = currentMonth.endOf('month').format("YYYY-MM-DD");
        date.push(fromDate);
        date.push(toDate);
    }

    // Retrieve requestedOn from local storage
    const requestedOnString = localStorage.getItem('requestedOn');
    const requestedOn: RequestedOn = requestedOnString ? JSON.parse(requestedOnString) : {};

    // Update requestedOn with the new date
    requestedOn[key] = date;

    // Update requestedOn in local storage
    localStorage.setItem('requestedOn', JSON.stringify(requestedOn));


    // Store the approvalRequestsData in local storage as an object
    const approvalRequestedData: { [date: string]: Task[] } = groupedTasks;
    localStorage.setItem('approvalRequestedData', JSON.stringify(approvalRequestedData));

    // Assuming userId is available in your component's scope

    // Retrieve rejectedKeys from local storage for the specific userId
    const rejectedKeysString = localStorage.getItem('rejectedKeys');
    console.log("rejectedKeysString", rejectedKeysString);

    if (rejectedKeysString) {
        const parsedRejectedKeys: RejectedKeys = JSON.parse(rejectedKeysString);
        console.log("rejectedKeys", parsedRejectedKeys);

        // Check if userId exists in rejectedKeys
        if (parsedRejectedKeys.hasOwnProperty(userId)) {
            // Get the rejectedKeys for the specific userId
            const userRejectedKeys = parsedRejectedKeys[userId];

            // Check if 'submit' exists in rejectedKeys for the specific user
            const date = requestData.length > 0 ? requestData[0].date : '';
            if (userRejectedKeys.some((key) => key.date === date)) {
                // Remove 'date' from rejectedKeys for the specific user
                const updatedRejectedKeys = userRejectedKeys.filter((key) => key.date !== date);

                // Update rejectedKeys in local storage for the specific user
                parsedRejectedKeys[userId] = updatedRejectedKeys;
                localStorage.setItem('rejectedKeys', JSON.stringify(parsedRejectedKeys));
            }
        }
    }

    // Set the success notification
    notification.success({
        message: 'Submission Successful',
        description: 'Task details submitted successfully!',
    });

    // Navigate to approval requests page
    navigate('/approvalrequests');
};

  const columns: ColumnsType<Task> = [
    {
      title: 'Sl.no',
      //sorter: (a: Task, b: Task) => (a.slNo && b.slNo ? a.slNo - b.slNo : 0),
      dataIndex: 'slNo',
      key: 'slNo',
      fixed: 'left',
    },
    {
      title: 'Task',
      //sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
      dataIndex: 'task',
      key: 'task',
      fixed: 'left',
    },
    {
      title: 'Title',
      //sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
      dataIndex: 'title',
      key: 'title',
      fixed: 'left',
    },
    {
      title: 'Date',
      //sorter: (a: Task, b: Task) => a.date.localeCompare(b.date),
      dataIndex: 'date',
      key: 'date',
      fixed: 'left',
    },
    {
      title: 'Start Time',
      //sorter: (a: Task, b: Task) => a.startTime.localeCompare(b.startTime),
      dataIndex: 'startTime',
      key: 'startTime',
      fixed: 'left',
    },
    {
      title: 'End Time',
      //sorter: (a: Task, b: Task) => a.endTime.localeCompare(b.endTime),
      dataIndex: 'endTime',
      key: 'endTime',
      fixed: 'left',
    },
    {
      title: 'Total Hours',
      //sorter: (a: Task, b: Task) => a.task.localeCompare(b.task),
      dataIndex: 'totalHours',
      key: 'totalHours',
      fixed: 'left',
    },
    {
      title: 'Description',
      //sorter: (a: Task, b: Task) => a.description.localeCompare(b.description),
      dataIndex: 'description',
      key: 'description',
      fixed: 'left',
    },
    {
      title: 'Reporting To',
      //sorter: (a: Task, b: Task) => a.reportingTo.localeCompare(b.reportingTo),
      dataIndex: 'reportingTo',
      key: 'reportingTo',
      fixed: 'left',
    },
    // {
    //   title: 'Actions',
    //   dataIndex: 'actions',
    //   key: 'actions',
    //   render: (_, record, index) => {
    //     const isDateSelected = selectedKeysToHide.includes(record.date); // Assuming record.date represents the date of the task
    //     return (
    //       <div>
    //         <EditOutlined
    //           onClick={() => handleEditTask(record.idx)}
    //           style={{
    //             marginRight: '8px',
    //             cursor: isDateSelected ? 'not-allowed' : 'pointer',
    //             color: isDateSelected ? 'grey' : 'blue',
    //             fontSize: '20px',
    //           }}
    //           disabled={isDateSelected}
    //         />
    //         <DeleteOutlined
    //           onClick={() => handleDeleteTask(record.idx)}
    //           style={{
    //             cursor: isDateSelected ? 'not-allowed' : 'pointer',
    //             color: isDateSelected ? 'grey' : 'red',
    //             fontSize: '20px',
    //           }}
    //           disabled={isDateSelected}
    //         />
    //       </div>
    //     );
    //   },
    // }    
    {
      title: 'Actions',
      dataIndex: 'actions',
      key: 'actions',
      render: (_, record, index) => {
        const isExistingTask = taskList.some(task => task.idx === record.idx);
        const isDateSelected = selectedKeysToHide.includes(record.date);
        
        // Filter tasks by userId
        const userTasks = taskList.filter(task => task.userId === record.userId);
        
        // Check if the user has tasks for the selected date
        const hasUserTasksForDate = userTasks.some(task => task.date === record.date);
    
        return (
          <div>
            <EditOutlined
              onClick={() => handleEditTask(record.idx)}
              style={{
                marginRight: '8px',
                cursor: (isDateSelected || !hasUserTasksForDate) ? 'not-allowed' : 'pointer',
                color: (isDateSelected || !hasUserTasksForDate) ? 'grey' : 'blue', 
                fontSize: '20px',
              }}
              disabled={isDateSelected || !hasUserTasksForDate}
            />
            <DeleteOutlined
              onClick={() => handleDeleteTask(record.idx)}
              style={{
                cursor: (isDateSelected || !hasUserTasksForDate) ? 'not-allowed' : 'pointer',
                color: (isDateSelected || !hasUserTasksForDate) ? 'grey' : 'red',
                fontSize: '20px',
              }}
              disabled={isDateSelected || !hasUserTasksForDate}
            />
          </div>
        );
      },
    }    
    
       
  ]

  return (
    <DashboardLayout>
      <div className='createuser-main'>
        <div className='header'>
          <div>
            <h1>Add Task</h1>
          </div>
          { filterOption === 'Month' ? (
            <div style={{display:'flex', justifyContent:'flex-end'}}>
              <div className='date'>From: {dayjs(currentMonth).format('YYYY-MM-DD')}</div>
              <div className='date' style={{ marginLeft: '40px' }}>To: {dayjs(currentMonth).endOf('month').format('YYYY-MM-DD')}</div>
            </div>
            ) : filterOption === 'Week' ? (
              <div style={{display:'flex', justifyContent:'flex-end'}}>
                <div className='date'>From: {dayjs(currentWeek).format('YYYY-MM-DD')}</div>
                <div className='date' style={{ marginLeft: '40px' }}>To: {dayjs(currentWeek).endOf('week').format('YYYY-MM-DD')}</div>
              </div>
            )  : (
              <div className='date'>Date: {currentDate.format('YYYY-MM-DD')}</div>
            )
          }
        </div>
        {(filterOption === 'Date' || ((filterOption === 'Week' || filterOption === 'Month') && isEdited)) || isFormEnabled  ? ( <form>
            <div>
              {isFormEnabled && (
                <CloseCircleOutlined
                  style={{ margin: '10px 20px', display: 'flex', justifyContent: 'flex-end', color: 'black', width:'900px' }}
                  onClick={handleToggleForm} // Call the handleToggleForm function on click
                />
              )}
              <div className='section-addtask' style={{width:'50%'}}>
                <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label style={{color:'#0B4266'}} htmlFor='addTaskID'>Date</label>
                  </div>
                  {/* <input
                    type="date"
                    style={{ width: '100%' }}
                    className='timepicker'
                  /> */}
                  <Input
                    type='date'
                    placeholder='Enter your Date'
                    value={
                      filterOption === 'Month'
                        ? currentMonth.format('YYYY-MM-01')
                        : filterOption === 'Week'
                        ? currentWeek.startOf('week').format('YYYY-MM-DD')
                        : currentDate.format('YYYY-MM-DD')
                    }
                    onChange={(e) => handleInputChange('date', e.target.value)}
                  />
                  {/* <DatePicker
                      value={dayjs(currentDate)} // Convert currentDate to Dayjs object
                      format="YYYY-MM-DD" // Specify the date format
                      onChange={(date, dateString) => handleInputChange('date', dateString)} // Use dateString to get the selected date
                      style={{ width: '100%', height:'35%' }} // Adjust the width as needed
                  /> */}
                </div>
                {/* <div className='create-layout-addtask-left  '>
                  <div style={{marginBottom:'10px'}}>
                    <label htmlFor='addTaskID'>User ID</label>
                  </div>
                  <Input
                    placeholder='Enter your Employee ID'
                    value={addTask.userId}
                    onChange={(e) => handleInputChange('userId', e.target.value)}  
                  />
                </div> */}
                 <div className='create-layout-addtask'>
                  <div>
                    <label style={{color:'#0B4266'}} htmlFor='task'>Task</label>
                  </div>
                  <div>
                    <select
                      id='task'
                      value={addTask.task}
                      onChange={(e) => handleInputChange('task', e.target.value)}
                    >
                      {taskOptions.map((option) => (
                          <option key={option} value={option}>
                            {option}
                          </option>
                        ))}
                    </select>
                  </div>
                  
                </div>
                <div className='create-layout-addtask'>
                  {addTask.task === 'Meeting' && (
                    <>
                      <div>
                        <label style={{ color:'#0B4266' }} htmlFor='title'>Meeting</label>
                      </div>
                      <div>
                        <select
                          id='task'
                          value={addTask.title}
                          onChange={(e) => handleInputChange('title', e.target.value)}
                        >
                          {meetingTitle.map((option, index) => (  // Use 'index' as the key
                            <option key={index} value={option}>
                              {option}
                            </option>
                          ))}
                        </select>
                      </div>
                    </>
                  )}
                  {(addTask.task === 'Project'|| addTask.task==='Learning' || addTask.task==='Training') && (
                    <>
                      <div>
                        <label style={{ color:'#0B4266' }} htmlFor='title'>{addTask.task}</label>
                      </div>
                      <div>
                        <select
                          id='task'
                          value={addTask.title}
                          onChange={(e) => handleInputChange('title', e.target.value)}  // Corrected 'title' to 'task'
                        >
                          {projectTitle.map((option, index) => (  // Use 'index' as the key
                            <option key={index} value={option}>
                              {option}
                            </option>
                          ))}
                        </select>
                      </div>
                    </>
                  )}
                </div>

              </div>
              <div style={{display:'flex', alignItems:'center'}}>
                <div>
                  <div className='section-addtask' style={{width:'125%'}}>
                    <div className='create-layout-addtask-left'>
                      <div>
                        <label htmlFor='startTime'>Start Time</label>
                      </div>
                      <TimePicker
                        value={
                          addTask.startTime
                            ? dayjs(addTask.startTime, 'hh:mm A') // Convert to dayjs here
                            : null
                        }
                        onChange={(time, timeString) =>
                          handleInputChange('startTime', timeString)
                        }
                        className='timepicker'
                        format='hh:mm A' // Set the format to include AM/PM
                      />
                    </div>
                    <div className='create-layout-addtask'>
                      <div>
                        <label style={{color:'#0B4266'}} htmlFor='endTime'>End Time</label>
                      </div>
                      <TimePicker
                        value={
                          addTask.endTime
                            ? dayjs(addTask.endTime, 'HH:mm A') // Convert to dayjs here
                            : null
                        }
                        onChange={(time, timeString) =>
                          handleInputChange('endTime', timeString)
                        }
                        className='timepicker'
                        format='hh:mm A' 
                        rootClassName='timer'
                      />
                    </div>
                  </div>
                  <div className='section-addtask' style={{width:'125%'}}>
                    
                  <div className='create-layout-addtask-left  '>
                      <div style={{marginBottom:'10px'}}>
                        <label style={{color:'#0B4266'}} htmlFor='totalHours'>Total Hours</label>
                      </div>
                      <Input
                        placeholder='Enter your Total Hours'
                        value={addTask.totalHours}
                        onChange={(e) => handleInputChange('totalHours', e.target.value)}
                        
                      />
                    </div>
                    <div className='create-layout-addtask-reportingTo  '>
                      <div className='create-layout-reportingTo'>
                        <label style={{color:'#0B4266'}} htmlFor='reportingTo'>Reporting To</label>
                      </div>
                      <select
                        id='reportingTo-addtask'
                        value={addTask.reportingTo}
                        onChange={(e) => handleInputChange('reportingTo', e.target.value)}
                      >
                        <option value=''>Select Reporting To</option>
                        {reportingOptions.map((option) => (
                          <option key={option} value={option}>
                            {option}
                          </option>
                        ))}
                      </select>
                    </div> 
                  </div>  
                  <div>
                    <div className='create-layout-description'>
                      <div>
                        <label style={{color:'#0B4266'}}>Description</label>
                      </div>
                      <textarea
                        value={addTask.description}
                        onChange={(e) => handleInputChange('description', e.target.value)}
                        className='description-input'
                        style={{width:'230%'}}
                      />
                    </div>
                  </div>
                </div>
                <div className='chart-container' style={{ marginLeft: "150px",width:'750px'}}>
                  {/* <img
                  src={asset}
                  alt="..."
                  style={{ marginLeft: "auto",width:'750px', height:'200px'}}
                  /> */}
                  <Chart
                      options={pieChartDataInForm.options}
                      series={pieChartDataInForm.series}
                      type="pie"
                      width="380"
      
                      
                  />

                </div>
              </div>
            </div>
            <div className='button' style={{marginBottom:'10px'}}>
              <Button  id='cancel-addtask' onClick={handleClearSubmit} style={{width:'7%'}}>
                Clear
              </Button>
              {isEdited ? (
              <Button id={addTask.totalHours? 'submit-addtask-active':'submit-addtask'} onClick={handleFormSubmit}>
                Save
              </Button>
            ):(
              <Button  id={addTask.totalHours? 'submit-addtask-active':'submit-addtask'} onClick={handleFormSubmit}>
                Add Task
              </Button>
            )}
            </div>

        </form>):null}
        <>
        <div>
          <div style={{ display:'flex', justifyContent:'space-between', margin:'10px 20px' }}>
            <div style={{display:'flex'}}>
              <Button id='submit-less' onClick={handleLeftArrowClick}> 
                      <LeftOutlined />
                  </Button>
                  {/* <select 
                      id='submit' 
                      style={{ appearance: 'none', WebkitAppearance: 'none', MozAppearance: 'none' }} 
                      onChange={(e) => handleFilterChange(e.target.value)} value={filterOption}
                  >
                      <option style={{textAlign:'center'}} value='Date'>Date</option>
                      <option style={{textAlign:'center'}} value='Week'>Week</option>
                      <option style={{textAlign:'center'}} value='Month'>Month</option>
                  </select> */}
                  <Button id='submit-less' onClick={handleRightArrowClick}>
                      <RightOutlined />
                  </Button>

            </div>
            
            {/* <Input
            className="search-addtask"
            placeholder="Search by Date"
            allowClear
            suffix={<SearchOutlined style={{ color: "#04172480" }} />}
            onChange={(e) => {
            //  console.log("Search input value:", e.target.value);
              setSearchInput(e.target.value);
            }}
          /> */}
         
          <div style={{display:'flex', justifyContent:'flex-end'}}>
          {/* <button type='button' id='submit-less' onClick={handleLeftArrowClick}>
            <LeftOutlined />
          </button> */}

        {/* <Select
           
            style={{
              marginTop: '10px',
              display: 'flex',
              padding: '0.5em 2em',
              border: 'transparent',
              boxShadow: '2px 2px 4px rgba(0,0,0,0.4)',
              justifyContent: 'center',
              alignItems: 'center',
              gap: '10px',
              borderRadius: '4px',
              color:'white',
              background: '#0B4266',
              cursor: 'pointer',
              appearance: 'none',
              WebkitAppearance: 'none',
              MozAppearance: 'none',
            }}
            defaultValue="Date"
            onChange={handleFilterChange}
        >
          <Select.Option value="Date">Date</Select.Option>
          <Select.Option value="Week">Week</Select.Option>
          <Select.Option value="Month">Month</Select.Option>
        </Select> */}
        <Button
              id='submit-addtask-active'
              style={{marginRight:'10px'}}
              onClick={handleRequestForm}
            >
              Request
        </Button>
        {!cancelButton && !(filterOption === 'Date' && !isFormEnabled) && (
            <Button
              id='cancel-new'
              onClick={handleToggleForm}
              disabled={isFormEnabled} // Disable the button when the form is enabled
            >
              Add Task
            </Button>
          )}
          <Select 
                    id='submit' 
                    style={{color:'white', appearance: 'none', WebkitAppearance: 'none', MozAppearance: 'none', marginTop:'10px', height:'95%', width:'120px' }} 
                    onChange={(value) => handleFilterChange(value)} 
                    value={filterOption}
                    dropdownStyle={{ textAlign: 'center' }} // Style the dropdown menu
                >
                    <Option value='Date'>Date</Option>
                    <Option value='Week'>Week</Option>
                    <Option value='Month'>Month</Option>
                </Select>
          {/* <button type='button' id='submit-less' onClick={handleRightArrowClick}>
            <RightOutlined />
          </button> */}
          </div>
        </div>
      </div>
        <Table
            style={{fontSize:'12px', fontFamily:'poppins', fontWeight:'normal', color: '#0B4266'}}
            className='addtask-table'
            columns={columns}
            dataSource={filteredTasks}
            pagination={false}
          />
            <Button id='submit-overall' onClick={handleOverallSubmit}>
              Submit
            </Button>
        </>
      </div>
    </DashboardLayout>
  );
};
export default AddTask;




